This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-08 16:03:32

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
.gitignore
ARCHITECTURE.md
assets
  sounds
    SDS Start Music.wav
    SDS1.wav
    SDS2.wav
    SDS3.wav
    win.wav
client
  assets
    sounds
      SDS Start Music.wav
      SDS1.wav
      SDS2.wav
      SDS3.wav
      win.wav
  index.html
  js
    AudioManager.js
    Boid.js
    GameState.js
    GameTimer.js
    InputHandler.js
    main.js
    MobileControls.js
    OptimizedSheep.js
    PerformanceMonitor.js
    SceneManager.js
    StaminaUI.js
    StartScreen.js
    StructureBuilder.js
    TerrainBuilder.js
    Vector2D.js
debug-client.html
DEPLOYMENT.md
index.html
js
  AudioManager.js
  Boid.js
  GameState.js
  GameTimer.js
  InputHandler.js
  main.js
  MobileControls.js
  MultiplayerUI.js
  NetworkManager.js
  OptimizedSheep.js
  PerformanceMonitor.js
  SceneManager.js
  Sheepdog.js
  StaminaUI.js
  StartScreen.js
  StructureBuilder.js
  TerrainBuilder.js
  Vector2D.js
MOBILE_CONTROLS.md
package.json
README.md
server
  GameSimulation.js
  index.js
  package.json
  RoomManager.js
  shared
    BoundaryCollision.js
    FlockingAlgorithms.js
    GameStateValidation.js
    index.js
    MovementPhysics.js
    test.js
    Vector2D.js
shared
  BoundaryCollision.js
  FlockingAlgorithms.js
  GameStateValidation.js
  index.js
  MovementPhysics.js
  test.js
  Vector2D.js
start-client-server.ps1
start-game-server.ps1
start-multiplayer-servers.ps1
task-list.md
```

# Repository Files


## .gitignore

```text
# Node.js dependencies
server/node_modules/
server/package-lock.json

# Server build artifacts  
server/.fly/
server/Dockerfile
server/.dockerignore

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/

# nyc test coverage
.nyc_output

# Dependency directories
node_modules/

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env

# VS Code
.vscode/

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Temporary files
*.tmp
*.temp
```

## ARCHITECTURE.md

````markdown
# Sheep Dog Simulation - Technical Architecture

## Overview
A sophisticated real-time 3D sheep herding simulation built with Three.js, implementing advanced flocking behavior algorithms, immersive environmental rendering, competitive gameplay mechanics, and polished user experience features. The simulation features 200 autonomous sheep agents with emergent flocking behavior rendered using high-performance GPU-based instanced rendering, a player-controlled sheepdog with stamina and sprint mechanics, timer-based scoring, cinematic start screen, and an expansive 3D world with realistic environmental elements.

## Modular Architecture

The simulation uses a clean, modular architecture optimized for performance and maintainability. Each module has a single responsibility and clear interfaces, with the sheep system utilizing cutting-edge GPU-based rendering for maximum efficiency.

### Module Overview

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   SceneManager  │    │ TerrainBuilder  │    │StructureBuilder│
│                 │    │                 │    │                 │
│ • 3D Rendering  │    │ • Environment   │    │ • Fences/Gates  │
│ • Camera System │    │ • Grass/Trees   │    │ • Pastures      │
│ • Lighting      │    │ • Mountains     │    │ • Structures    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                    ┌─────────────────┐
                    │   main.js       │
                    │                 │
                    │ • Orchestration │
                    │ • Game Loop     │
                    │ • Module Coord  │
                    └─────────────────┘
                                 │
         ┌───────────────────────┼───────────────────────┐
         │                       │                       │
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   GameState     │    │   GameTimer     │    │  InputHandler   │
│                 │    │                 │    │                 │
│ • Game Logic    │    │ • Timing System │    │ • User Input    │
│ • Sheep Mgmt    │    │ • Best Scores   │    │ • WASD Control  │
│ • Completion    │    │ • Persistence   │    │ • Sprint/Pause  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
         ┌───────────────────────┼───────────────────────┐
         │                       │                       │
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   StartScreen   │    │   StaminaUI     │    │PerformanceMonitor│
│                 │    │                 │    │                 │
│ • Start Screen  │    │ • Stamina Bar   │    │ • FPS Tracking  │
│ • Cinematic Cam │    │ • UI Updates    │    │ • Stats Display │
│ • Game Launch   │    │ • Visual States │    │ • Metrics       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

## Core Modules

### 1. SceneManager.js (141 lines)
**3D Scene and Rendering Management**

**Responsibilities:**
- Three.js scene initialization and configuration
- Camera system with dynamic following and zoom
- Lighting setup (ambient + directional with shadows)
- Window resize handling and viewport management
- Mouse wheel zoom controls

**Key Features:**
- **Dynamic Camera**: Smooth interpolation following sheepdog with configurable zoom (20-150 units)
- **Advanced Lighting**: Multi-light setup with shadow mapping (2048x2048 resolution)
- **Fog System**: Atmospheric depth with extended range (200-600 units)
- **Performance Optimized**: Efficient render loop with minimal state changes

**API:**
```javascript
class SceneManager {
    updateCamera(sheepdog)     // Follow sheepdog with smooth interpolation
    setupMouseControls()       // Enable zoom controls
    render()                   // Render scene to canvas
    add(object)               // Add object to scene
    getScene()                // Access Three.js scene
    getCamera()               // Access camera for start screen
}
```

### 2. TerrainBuilder.js (397 lines)
**Environment and Terrain Generation**

**Responsibilities:**
- Flat terrain generation (1000x1000 units)
- Instanced grass system with wind animation
- Multi-layered mountain generation
- Realistic tree creation (deciduous and pine)
- Environmental details (rocks, atmospheric effects)

**Key Features:**
- **Massive Grass System**: 800,000 instanced grass blades with shader-based wind animation
- **Procedural Mountains**: Three-layer mountain system with geometric variation
- **Realistic Trees**: Separate trunks and multi-layer foliage (200 deciduous + 80 pine)
- **Distance Scaling**: Grass and details scale with distance for realistic perspective

**Grass Shader System:**
```glsl
// Vertex Shader Features:
- Wind displacement with multi-frequency sine waves
- Blade tip emphasis with cosine-based power curves
- Complex multi-directional wind patterns
- Instance matrix transformations for positioning

// Fragment Shader Features:
- Base-to-tip color gradients
- Positional color variation with noise
- Fog integration with depth-based blending
- Performance-optimized calculations
```

**API:**
```javascript
class TerrainBuilder {
    createTerrain()           // Generate base terrain
    createGrass()            // Create instanced grass system
    createMountains()        // Generate mountain layers
    createTrees()            // Create tree forests
    updateGrassAnimation()   // Update wind animation
    getGrassInstanceCount()  // Get grass count for performance monitoring
}
```

### 3. StructureBuilder.js (471 lines)
**Game Structures and Boundaries**

**Responsibilities:**
- Field boundary fence system with posts and rails
- Gate construction with detection zones
- Pasture area creation with custom textures
- Fence rail connection algorithms

**Key Features:**
- **Modular Fence System**: Procedural fence generation with configurable spacing
- **Gate Mechanics**: Golden threshold markers with passage detection
- **Custom Textures**: Canvas-generated pasture textures with gradient effects
- **Structural Integrity**: Proper rail connections and post placement

**API:**
```javascript
class StructureBuilder {
    createFieldBoundaryFence(bounds, gate)  // Generate perimeter fencing
    createGateAndPasture(gate, pasture)     // Create goal structures
    createFenceRail(x1, z1, x2, z2, ...)   // Connect fence segments
}
```

### 4. GameState.js (242 lines)
**Game Logic and State Management**

**Responsibilities:**
- Game configuration and boundaries
- Optimized sheep system coordination
- Completion detection and progress tracking
- UI updates and completion messaging
- Pause state management

**Key Features:**
- **Centralized Configuration**: All game parameters in one location
- **Optimized Sheep Management**: Always uses high-performance GPU rendering
- **Progress Monitoring**: Real-time sheep count and completion detection
- **UI Integration**: Automatic UI updates and completion messages
- **Pause Support**: Coordinated pause state across systems

**Configuration:**
```javascript
// Field boundaries and game areas
bounds: { minX: -100, maxX: 100, minZ: -100, maxZ: 100 }
gate: { position: Vector2D(0, 100), width: 8, height: 4 }
pasture: { minX: -30, maxX: 30, minZ: 102, maxZ: 130 }

// Simulation parameters
params: {
    speed: 0.1,              // Sheep movement speed
    cohesion: 1.0,           // Flock cohesion strength
    separationDistance: 2.0   // Minimum separation distance
}
```

### 5. GameTimer.js (181 lines)
**Timing System and Score Tracking**

**Responsibilities:**
- Precision timing with performance.now()
- Best time persistence in localStorage
- New record detection and celebration
- Timer display formatting and UI updates
- Pause state handling

**Key Features:**
- **High Precision**: Millisecond-accurate timing
- **Persistent Storage**: Best times saved across browser sessions
- **Visual Feedback**: New record animations and celebrations
- **Error Handling**: Graceful fallback for localStorage issues
- **Pause Integration**: Respects pause state for accurate timing

**API:**
```javascript
class GameTimer {
    start()                  // Begin timing
    stop()                   // End timing and check for records
    update()                 // Update display during gameplay
    reset()                  // Reset timer for new game
    setPaused(isPaused)      // Handle pause state
    formatTime(seconds)      // Format time for display
    getBestTime()           // Retrieve best time
}
```

### 6. OptimizedSheep.js (788 lines)
**High-Performance GPU-Based Sheep System**

**Responsibilities:**
- Single InstancedMesh for all 200 sheep (1 draw call!)
- GPU-based animation via vertex shaders
- Merged geometry with vertex colors
- Efficient per-instance data management

**Key Features:**
- **Instanced Rendering**: All sheep rendered in a single draw call
- **GPU Animation**: Vertex shader-based movement and behavior animation
- **Merged Geometry**: Body, head, and legs combined into single geometry
- **Vertex Colors**: Per-vertex coloring for material variation
- **Efficient Updates**: Minimal CPU-GPU data transfer

**Shader System:**
```glsl
// Vertex Shader Features:
- Per-instance animation data (phase, speed, state, direction)
- Leg animation with galloping motion
- Body bounce and head bob
- Facing direction and look-at behavior
- Instance matrix transformations

// Fragment Shader Features:
- Toon shading with stepped lighting
- Vertex color support for material variation
- Fog integration for atmospheric depth
- Performance-optimized lighting calculations
```

**Performance Metrics:**
```javascript
// Rendering Efficiency:
- 200 sheep: 1 draw call (vs 200+ in traditional approach)
- GPU animation: 0 CPU overhead for movement
- Memory usage: ~50MB for all sheep data
- Target: 60 FPS with full flock + environment
```

### 7. PerformanceMonitor.js (377 lines)
**Real-time Performance Tracking and Statistics**

**Responsibilities:**
- Stats.js integration for FPS and memory monitoring
- Custom simulation-specific performance metrics
- Real-time display of rendering statistics
- Performance data collection and analysis

**Key Features:**
- **Stats.js Integration**: Professional FPS/memory tracking with fallback support
- **Custom Metrics Panel**: Simulation-specific statistics (sheep count, grass instances, draw calls)
- **Frame Time Analysis**: Rolling average, min/max frame time tracking
- **Memory Monitoring**: JavaScript heap usage when available
- **Toggle Controls**: Show/hide performance displays with 'P' key

**Performance Metrics:**
```javascript
metrics: {
    sheepCount: 200,         // Total sheep in simulation
    activeSheepCount: 0,     // Currently active sheep
    grassInstances: 800000,  // Number of grass blade instances
    drawCalls: 0,            // WebGL draw calls per frame
    triangles: 0,            // Total triangles rendered
    avgFrameTime: 0,         // Rolling average frame time
    minFrameTime: Infinity,  // Minimum frame time recorded
    maxFrameTime: 0          // Maximum frame time recorded
}
```

### 8. StartScreen.js (136 lines)
**Start Screen and Pre-Game Experience**

**Responsibilities:**
- Start screen overlay management
- Cinematic camera system for pre-game showcase
- Game launch coordination
- UI transition management

**Key Features:**
- **Cinematic Camera**: Smooth orbital camera movement around the field
- **Interactive UI**: Start button and Enter key support
- **Smooth Transitions**: Fade animations between start screen and gameplay
- **Game Coordination**: Callback system for game initialization

**API:**
```javascript
class StartScreen {
    updateCinematicCamera()      // Update orbital camera movement
    startGame()                  // Initiate game start sequence
    setGameStartCallback(fn)     // Register game start handler
    isStartScreenActive()        // Check if start screen is active
    reset()                      // Reset to start screen state
}
```

### 9. StaminaUI.js (105 lines)
**Stamina System User Interface**

**Responsibilities:**
- Stamina bar display and updates
- Visual state management (normal, low, critical, sprinting)
- Performance-optimized UI updates
- Stamina percentage and status display

**Key Features:**
- **Visual States**: Color-coded stamina levels with animations
- **Performance Optimized**: Only updates DOM when values change
- **State Indicators**: Different colors and labels for various stamina states
- **Smooth Animations**: CSS transitions for visual feedback

**API:**
```javascript
class StaminaUI {
    update(staminaInfo)     // Update display based on sheepdog stamina
    show()                  // Show stamina bar when game starts
    hide()                  // Hide stamina bar
    reset()                 // Reset to full stamina display
}
```

### 10. Sheepdog.js (683 lines)
**Enhanced Player Controller with Stamina System**

**Responsibilities:**
- Player movement with acceleration and deceleration
- Stamina system with sprint mechanics
- Detailed 3D model with procedural animations
- Idle behavior system with multiple animation states

**Key Features:**
- **Stamina System**: Sprint mechanics with stamina drain and regeneration
- **Smooth Movement**: Acceleration-based movement with boundary constraints
- **Detailed Model**: Procedural dog mesh with realistic proportions and materials
- **Rich Animations**: Running, idle, breathing, looking around, ear twitching, stretching
- **Visual Feedback**: Tongue visibility when running, different animation speeds

**Stamina Mechanics:**
```javascript
// Stamina Configuration:
maxStamina: 100,
staminaDrainRate: 30,      // Per second when sprinting
staminaRegenRate: 20,      // Per second when not sprinting (40 when idle)
minStaminaToSprint: 10,    // Minimum stamina to start sprinting
maxSpeed: 15,              // Normal movement speed
sprintSpeed: 25            // Sprint movement speed
```

### 11. InputHandler.js (182 lines)
**Enhanced Input Management with Pause System**

**Responsibilities:**
- WASD movement input handling
- Sprint control (Shift key)
- Pause system (Escape key)
- Performance monitor toggle (P key)
- Focus and blur event handling

**Key Features:**
- **Pause System**: Escape key toggles pause with visual indicator
- **Sprint Control**: Shift key for stamina-based sprinting
- **State Management**: Proper key state clearing on pause/blur
- **Callback System**: Pause state notifications to other systems

**API:**
```javascript
class InputHandler {
    getMovementDirection()   // Get normalized movement vector
    isSprinting()           // Check if sprint key is pressed
    isPausedState()         // Check current pause state
    togglePause()           // Toggle pause state
    onPauseToggle(callback) // Register pause state change callback
}
```

### 12. main.js (192 lines)
**Enhanced Orchestration and Game Loop**

**Responsibilities:**
- Module initialization and coordination
- Start screen to game transition management
- Main game loop and update cycle
- Pause state coordination
- Performance monitoring integration

**Enhanced Structure:**
```javascript
class SheepDogSimulation {
    constructor() {
        // Initialize all modules including new ones
        this.startScreen = new StartScreen(this.sceneManager);
        this.staminaUI = new StaminaUI();
        // ... other modules
        
        // Set up pause handling across systems
        this.setupPauseHandling();
    }
    
    startGame() {
        // Transition from start screen to active game
        // Add sheepdog to scene, start timer, show stamina UI
    }
    
    update(deltaTime) {
        // Coordinate all systems with pause awareness
        // Handle start screen vs active game states
    }
}
```

## AI and Behavior Systems

### Boid System (js/Boid.js - 248 lines)
**Enhanced Flocking Algorithm**
- **Separation**: Exponential repulsion to avoid crowding
- **Alignment**: Weighted average heading calculation
- **Cohesion**: Center-of-mass attraction with distance weighting
- **Boundary Avoidance**: Soft and hard boundary systems
- **Performance**: Spatial optimization with perception radius limiting

### Optimized Sheep Agent (js/OptimizedSheep.js)
**GPU-Accelerated State Machine**
```javascript
States:
- Active (0): Normal flocking + dog avoidance + gate attraction
- Retiring (1): Seeking pasture position (50% speed reduction)
- Grazing (2): Gentle wandering in pasture with minimal movement

Behavioral Parameters:
- Flee radius: 8 units from sheepdog
- Gate attraction: 0.5 force multiplier when herded
- Boundary constraints: Hard stop at fence edges (except gate area)
- Grazing behavior: 0.2% chance per frame for gentle movement
```

### Enhanced Sheepdog Controller (js/Sheepdog.js)
**Advanced Player Input System**
- **Movement**: WASD input with smooth acceleration/deceleration
- **Sprint System**: Shift key with stamina management
- **Visual Model**: Detailed procedural dog mesh with realistic animations
- **Influence**: Affects sheep within 8-unit flee radius
- **Idle Behaviors**: Multiple idle animation states for immersion

## User Experience Systems

### Start Screen System
- **Cinematic Camera**: Orbital camera showcasing the field before gameplay
- **Interactive UI**: Professional start screen with instructions and branding
- **Smooth Transitions**: Fade animations between start screen and gameplay
- **Keyboard Support**: Enter key and click support for accessibility

### Stamina System
- **Visual Feedback**: Color-coded stamina bar with state indicators
- **Gameplay Impact**: Sprint speed vs stamina management decisions
- **Recovery Mechanics**: Faster regeneration when idle vs moving
- **UI Integration**: Real-time updates with performance optimization

### Pause System
- **Universal Pause**: Escape key pauses all game systems
- **Visual Indicator**: Clear pause overlay with resume instructions
- **State Preservation**: Proper pause/resume of timers and animations
- **Input Handling**: Prevents movement input during pause

## Rendering Pipeline

### Performance Optimizations

#### GPU-Based Rendering
- **Sheep System**: Single InstancedMesh for all 200 sheep (1 draw call)
- **Vertex Shader Animation**: All sheep movement calculated on GPU
- **Instanced Grass**: Single draw call for 800,000 grass instances
- **Shared Geometries**: Reused base geometries for environmental objects
- **Memory Efficiency**: ~150MB total for entire scene

#### Advanced Techniques
- **Merged Geometry**: Sheep body parts combined into single geometry
- **Vertex Colors**: Per-vertex material variation without texture switching
- **Instance Attributes**: Custom per-sheep data (animation, state, direction)
- **Frustum Culling**: Disabled for instanced meshes to prevent pop-in

#### Shadow System
- **Optimized Mapping**: 2048x2048 shadow maps with 240-unit coverage
- **Selective Casting**: Only essential objects cast shadows
- **PCF Soft Shadows**: Smooth shadow edges for visual quality

### Shader Systems

#### Optimized Sheep Shader
```glsl
// Vertex Shader Features:
- Instance data: animPhase, speed, state, uniqueId
- Animation data: walkCycle, bounce, direction, blinkTimer
- Leg animation with galloping motion (vertexId 100-139)
- Body bounce animation (vertexId 0-49)
- Head bob and look direction (vertexId 50-99)

// Fragment Shader Features:
- Toon shading with 3-step lighting
- Vertex color support for material variation
- Fog integration with depth-based blending
- Optimized lighting calculations
```

#### Grass Animation Shader
```glsl
// Wind simulation with multiple frequencies
float windX = sin(worldPos.z * 0.1 + time * 2.0) * cos(worldPos.x * 0.1 + time * 1.5);
float windZ = cos(worldPos.x * 0.15 + time * 2.5) * sin(worldPos.z * 0.15 + time * 2.0);

// Blade tip emphasis
float dispPower = 1.0 - cos(uv.y * PI / 2.0);
displacement = windX * (0.15 * dispPower);
```

## Game Logic Systems

### Gate Passage Detection
```javascript
// Multi-criteria validation:
1. Position within gate passage zone (4-unit width)
2. Positive Z velocity (moving toward pasture)
3. Not already passed (state tracking)
4. Velocity threshold for intentional movement
```

### Completion System
- **Progress Tracking**: Real-time count of retired sheep
- **State Validation**: Multiple checks for completion
- **Timer Integration**: Automatic timer stop on completion
- **UI Updates**: Dynamic progress display and completion messages

### Boundary System
```javascript
// Hierarchical boundary enforcement:
Hard Boundaries: -100 to +100 (x,z) - absolute limits (except for passed sheep)
Soft Boundaries: 3-unit margin with exponential repulsion
Gate Exception: 8-unit opening at (0, 100)
Pasture Area: (-30 to 30, 102 to 130) - goal zone with gentle containment
```

### Grazing System
```javascript
// Post-gate behavior:
- Gentle wandering: 0.2% chance per frame for movement
- Pasture containment: Soft forces to stay within bounds
- Reduced speed: 0.02 units for realistic grazing
- Continuous animation: Maintained visual activity
```

## Data Structures and Algorithms

### Vector2D Mathematics (js/Vector2D.js - 102 lines)
**Optimized 2D Vector Operations**
```javascript
class Vector2D {
    add(vector)              // Vector addition
    subtract(vector)         // Vector subtraction
    multiply(scalar)         // Scalar multiplication
    normalize()              // Unit vector conversion
    magnitude()              // Length calculation
    distance(vector)         // Distance between vectors
    limit(max)              // Magnitude limiting
    angle()                 // Calculate angle for rotation
}
```

### Spatial Optimization
- **Neighbor Detection**: Efficient radius-based queries
- **Perception Limiting**: Configurable awareness radius
- **Update Batching**: Grouped behavior calculations
- **GPU Offloading**: Animation calculations moved to vertex shaders

## Performance Characteristics

### Target Specifications
- **Frame Rate**: 60 FPS sustained
- **Sheep Count**: 200 autonomous agents (1 draw call)
- **Grass Instances**: 800,000 animated blades (1 draw call)
- **Total Draw Calls**: <10 for entire scene
- **Memory Usage**: ~150MB for full scene

### Bottleneck Analysis
- **Primary**: Grass rendering (800k instances)
- **Secondary**: Shadow calculations (2048² maps)
- **Tertiary**: JavaScript behavior updates (200 agents)
- **Eliminated**: Individual sheep rendering overhead

### Optimization Strategies
- **GPU-Based Animation**: Vertex shader calculations
- **Instanced Rendering**: Massive geometry reduction
- **Shared Resources**: Memory efficiency
- **Simplified Physics**: 2D calculations with 3D rendering
- **Culling Systems**: Visibility and distance-based optimizations

## Extension Architecture

### Adding New Features
```javascript
// 1. Create new module class
class WeatherSystem {
    constructor(scene) { this.scene = scene; }
    update() { /* weather logic */ }
}

// 2. Initialize in main.js
this.weatherSystem = new WeatherSystem(this.sceneManager.getScene());

// 3. Update in game loop
this.weatherSystem.update();
```

### Behavior Extensions
- **New Agent Types**: Extend Boid class
- **Environmental Effects**: Add to TerrainBuilder
- **Game Mechanics**: Extend GameState
- **Visual Effects**: Enhance SceneManager or create new shader systems

## Dependencies and Compatibility

### Core Dependencies
- **Three.js v0.176.0**: 3D rendering engine
- **Stats.js v0.17.0**: Performance monitoring
- **WebGL 1.0+**: Hardware acceleration requirement
- **ES6 Classes**: Modern JavaScript features

### Browser Support
- **Chrome 80+**: Full feature support
- **Firefox 75+**: Full feature support  
- **Safari 13+**: Full feature support
- **Edge 80+**: Full feature support

### Performance Requirements
- **GPU**: WebGL-capable graphics (integrated minimum)
- **RAM**: 4GB+ recommended for smooth operation
- **CPU**: Modern multi-core for 60 FPS target

## Development Workflow

### Module Development
1. **Single Responsibility**: Each module handles one aspect
2. **Clear Interfaces**: Well-defined public APIs
3. **Error Handling**: Graceful degradation
4. **Documentation**: Comprehensive inline comments

### Testing Strategy
- **Unit Testing**: Individual module validation
- **Integration Testing**: Module interaction verification
- **Performance Testing**: Frame rate and memory monitoring
- **Cross-Browser Testing**: Compatibility validation

### Code Quality
- **ES6 Standards**: Modern JavaScript practices
- **Consistent Naming**: Descriptive method and variable names
- **Modular Design**: Loose coupling, high cohesion
- **Performance Focus**: Optimization-aware development

## File Structure
```
sheep-dog/
├── index.html              # Main HTML container with enhanced UI
├── js/
│   ├── main.js             # SheepDogSimulation controller (192 lines)
│   ├── SceneManager.js     # 3D scene and rendering management (141 lines)
│   ├── TerrainBuilder.js   # Environment creation and grass system (397 lines)
│   ├── StructureBuilder.js # Game structures (fences, gates, pastures) (471 lines)
│   ├── GameState.js        # Game logic and state management (242 lines)
│   ├── GameTimer.js        # Timer system and best time tracking (181 lines)
│   ├── PerformanceMonitor.js # Real-time performance tracking (377 lines)
│   ├── StartScreen.js      # Start screen and cinematic camera (136 lines)
│   ├── StaminaUI.js        # Stamina bar UI management (105 lines)
│   ├── Boid.js             # Base flocking agent (248 lines)
│   ├── OptimizedSheep.js   # GPU-based sheep system (788 lines)
│   ├── Sheepdog.js         # Enhanced player controller with stamina (683 lines)
│   ├── InputHandler.js     # Keyboard input with pause system (182 lines)
│   └── Vector2D.js         # 2D math utilities (102 lines)
├── assets/
│   ├── images/
│   │   └── favicon.png     # Game favicon
│   └── sounds/             # Reserved for future audio assets
├── package.json            # Dependencies and scripts
├── README.md               # User documentation
└── ARCHITECTURE.md         # This document
```

## Dependencies
- **Three.js v0.176.0**: 3D rendering engine
- **Stats.js v0.17.0**: Performance monitoring (FPS, memory, custom metrics)
- **HTTP Server**: Development server (Python or Node.js, port 8000)

## Performance Characteristics
- **Target**: 60 FPS with 200 sheep + 800k grass instances
- **Bottlenecks**: Grass rendering, shadow calculations
- **Optimizations**: GPU-based sheep rendering, instanced rendering, shared resources

## Extension Points
- **New Behaviors**: Extend Boid class for different agent types
- **Environmental**: Add weather, day/night cycles via shader uniforms
- **Gameplay**: Multiple levels, different objectives, obstacles, power-ups
- **Rendering**: Enhanced materials, particle effects, post-processing
- **Audio**: Sound effects and ambient audio integration
- **UI**: Additional game modes, settings, achievements
````

## client/index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#00BFFF">
    <title>Sheep Dog Sim</title>
    <link rel="icon" type="image/png" href="assets/images/favicon.png">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            /* Prevent text selection on mobile */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Prevent touch callouts */
            -webkit-touch-callout: none;
            /* Prevent tap highlight */
            -webkit-tap-highlight-color: transparent;
        }
        
        #canvas-container {
            position: relative;
            width: 100%;
            height: 100vh;
            /* Prevent scrolling */
            touch-action: none;
            /* Prevent overscroll bounce on iOS */
            overscroll-behavior: none;
        }
        
        /* Prevent zoom on inputs and buttons */
        input, button, select, textarea {
            font-size: 16px;
            -webkit-appearance: none;
            border-radius: 0;
        }
        
        /* Start Screen Overlay */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
            /* Mobile safe area and scrolling */
            padding-top: max(20px, env(safe-area-inset-top));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
            padding-left: max(20px, env(safe-area-inset-left));
            padding-right: max(20px, env(safe-area-inset-right));
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        #game-title {
            font-size: 4.5rem;
            font-weight: 900;
            margin-bottom: 1rem;
            color: #00BFFF;
            font-family: 'Arial Black', Arial, sans-serif;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 3px 3px 0px #000;
        }
        
        /* Mobile responsive title */
        @media (max-width: 768px) {
            #start-screen {
                padding: 10px;
                justify-content: flex-start;
                padding-top: 5vh;
                padding-bottom: 5vh;
                min-height: 100vh;
                box-sizing: border-box;
                overflow-y: auto;
            }
            
            #game-title {
                font-size: 2.2rem;
                letter-spacing: 1px;
                margin-bottom: 0.5rem;
            }
            
            #game-subtitle {
                font-size: 0.9rem;
                margin-bottom: 1.5rem;
            }
            
            #start-instructions {
                max-width: 95%;
                padding: 1.2rem;
                margin-bottom: 1.5rem;
            }
            
            #start-instructions h3 {
                font-size: 1.1rem;
                margin-bottom: 0.8rem;
            }
            
            #start-instructions p {
                font-size: 0.85rem;
                margin: 0.6rem 0;
            }
            
            #start-button {
                padding: 15px 30px;
                font-size: 1.2rem;
                margin-top: 1rem;
                margin-bottom: 2rem;
            }
        }
        
        /* Mobile portrait adjustments */
        @media (max-width: 480px) and (orientation: portrait) {
            #start-screen {
                padding: 5px;
                justify-content: flex-start;
                padding-top: 2vh;
                padding-bottom: 3vh;
                min-height: 100vh;
                max-height: 100vh;
                overflow-y: auto;
                display: flex;
                flex-direction: column;
            }
            
            #game-title {
                font-size: 1.8rem;
                margin-bottom: 0.3rem;
            }
            
            #game-subtitle {
                font-size: 0.8rem;
                margin-bottom: 1rem;
            }
            
            #start-instructions {
                padding: 1rem;
                margin-bottom: 1rem;
                flex-shrink: 0;
            }
            
            #start-instructions h3 {
                font-size: 1rem;
            }
            
            #start-instructions p {
                font-size: 0.8rem;
                margin: 0.4rem 0;
            }
            
            #start-button {
                padding: 12px 25px;
                font-size: 1rem;
                margin-top: 1rem;
                margin-bottom: 2rem;
                flex-shrink: 0;
            }
        }
        
        /* Extra small screens - ensure everything fits */
        @media (max-width: 360px) and (max-height: 640px) {
            #start-screen {
                padding: 3px;
                padding-top: 1vh;
                padding-bottom: 2vh;
            }
            
            #game-title {
                font-size: 1.5rem;
                margin-bottom: 0.2rem;
            }
            
            #game-subtitle {
                font-size: 0.7rem;
                margin-bottom: 0.8rem;
            }
            
            #start-instructions {
                padding: 0.8rem;
                margin-bottom: 0.8rem;
            }
            
            #start-instructions h3 {
                font-size: 0.9rem;
                margin-bottom: 0.5rem;
            }
            
            #start-instructions p {
                font-size: 0.75rem;
                margin: 0.3rem 0;
            }
            
            #start-button {
                padding: 10px 20px;
                font-size: 0.9rem;
                margin-top: 0.8rem;
                margin-bottom: 1.5rem;
            }
        }
        
        /* Very short screens - ultra compact layout */
        @media (max-height: 600px) {
            #start-screen {
                padding: 2px;
                padding-top: 1vh;
                padding-bottom: 1vh;
                justify-content: space-between;
            }
            
            #game-title {
                font-size: 1.4rem;
                margin-bottom: 0.1rem;
            }
            
            #game-subtitle {
                font-size: 0.65rem;
                margin-bottom: 0.5rem;
            }
            
            #start-instructions {
                padding: 0.6rem;
                margin-bottom: 0.5rem;
            }
            
            #start-instructions h3 {
                font-size: 0.85rem;
                margin-bottom: 0.3rem;
            }
            
            #start-instructions p {
                font-size: 0.7rem;
                margin: 0.2rem 0;
                line-height: 1.2;
            }
            
            #start-button {
                padding: 8px 16px;
                font-size: 0.85rem;
                margin-top: 0.5rem;
                margin-bottom: 1rem;
            }
        }
        
        /* Landscape mobile - horizontal layout adjustments */
        @media (max-height: 500px) and (orientation: landscape) {
            #start-screen {
                flex-direction: row;
                align-items: center;
                justify-content: space-around;
                padding: 5px;
            }
            
            #start-screen > div:first-child {
                flex: 1;
                text-align: left;
            }
            
            #start-instructions {
                flex: 1;
                margin: 0 10px;
            }
            
            #start-button {
                flex-shrink: 0;
                margin: 0;
            }
        }
        
        #game-subtitle {
            font-size: 1.4rem;
            margin-bottom: 2rem;
            color: #FFF;
            font-family: Arial, sans-serif;
            font-weight: normal;
        }
        
        #start-instructions {
            background: rgba(255, 255, 255, 0.95);
            padding: 2rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            color: #333;
            border: 3px solid #00BFFF;
            max-width: 500px;
        }
        
        #start-instructions h3 {
            margin: 0 0 1rem 0;
            font-size: 1.5rem;
            color: #00BFFF;
            font-family: 'Arial Black', Arial, sans-serif;
            font-weight: 900;
        }
        
        #start-instructions p {
            margin: 0.8rem 0;
            font-size: 1rem;
            line-height: 1.4;
            font-family: Arial, sans-serif;
            color: #333;
        }
        
        #start-button {
            background: #00BFFF;
            border: 3px solid #FFF;
            color: #FFF;
            padding: 20px 40px;
            font-size: 1.5rem;
            font-weight: 900;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-family: 'Arial Black', Arial, sans-serif;
            text-shadow: 2px 2px 0px #000;
            /* Mobile touch improvements */
            min-height: 44px;
            min-width: 44px;
            /* Ensure button is always accessible */
            margin-bottom: max(20px, env(safe-area-inset-bottom, 20px));
            flex-shrink: 0;
        }
        
        #start-button:hover {
            background: #FFF;
            color: #00BFFF;
            border: 3px solid #00BFFF;
            text-shadow: none;
        }
        
        #start-button:active {
            transform: translateY(2px);
        }
        
        /* Mute Toggle in Controls */
        #mute-toggle {
            margin: 5px 0;
            font-size: 14px;
            color: #333;
            cursor: pointer;
            user-select: none;
            transition: color 0.2s ease;
        }
        
        #mute-toggle:hover {
            color: #00BFFF;
        }
        
        #mute-toggle.muted {
            color: #FF6B35;
        }
        
        /* Game UI Elements - Clean style */
        .game-ui {
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .game-ui.visible {
            opacity: 1;
        }
        
        /* Stats hidden by default */
        #stats {
            display: none;
        }
        
        #stats.visible {
            display: block;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00BFFF;
            font-family: Arial, sans-serif;
            /* Mobile adjustments */
            max-width: calc(100vw - 160px);
            z-index: 999;
        }
        
        /* Mobile responsive instructions */
        @media (max-width: 768px) {
            #instructions {
                bottom: 10px;
                left: 10px;
                right: 10px;
                max-width: none;
                padding: 10px;
                font-size: 12px;
            }
            
            #instructions h3 {
                font-size: 14px;
                margin-bottom: 8px;
            }
            
            #instructions p {
                margin: 3px 0;
                font-size: 11px;
            }
        }
        
        #instructions h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #00BFFF;
            font-weight: 900;
        }
        
        #instructions p {
            margin: 5px 0;
            font-size: 14px;
            color: #333;
        }
        
        #completion-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            color: #333;
            padding: 30px 50px;
            border-radius: 8px;
            font-size: 24px;
            font-weight: 900;
            display: none;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            text-align: center;
            line-height: 1.4;
            border: 4px solid #00BFFF;
            font-family: 'Arial Black', Arial, sans-serif;
            z-index: 1002;
            max-width: 90vw;
            box-sizing: border-box;
        }
        
        /* Mobile responsive completion message */
        @media (max-width: 768px) {
            #completion-message {
                padding: 20px 30px;
                font-size: 18px;
            }
        }
        
        #restart-button {
            background: #00BFFF;
            border: 2px solid #333;
            color: white;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 900;
            cursor: pointer;
            margin-top: 15px;
            transition: all 0.2s ease;
            font-family: 'Arial Black', Arial, sans-serif;
            text-transform: uppercase;
            /* Mobile touch improvements */
            min-height: 44px;
            min-width: 44px;
        }
        
        #restart-button:hover {
            background: #333;
            border: 2px solid #00BFFF;
        }
        
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            border: 2px solid #00BFFF;
            font-family: Arial, sans-serif;
            font-weight: bold;
            color: #333;
            z-index: 999;
        }
        
        #timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 900;
            text-align: center;
            border: 2px solid #00BFFF;
            font-family: 'Arial Black', Arial, sans-serif;
            z-index: 999;
        }
        
        /* Combined mobile UI for timer and sheep count */
        #mobile-combined-ui {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 900;
            text-align: center;
            border: 2px solid #00BFFF;
            font-family: 'Arial Black', Arial, sans-serif;
            z-index: 999;
            display: none;
            min-width: 200px;
        }
        
        #mobile-timer-display {
            color: #00BFFF;
            font-size: 16px;
            margin-bottom: 2px;
        }
        
        #mobile-sheep-count {
            font-size: 12px;
            color: #333;
            margin-bottom: 2px;
        }
        
        #mobile-best-time {
            font-size: 10px;
            color: #666;
            font-weight: normal;
            font-family: Arial, sans-serif;
        }
        
        /* Mobile responsive timer */
        @media (max-width: 768px) {
            #timer {
                display: none; /* Hide desktop timer on mobile */
            }
            
            #stats {
                display: none !important; /* Hide desktop stats on mobile */
            }
            
            #mobile-combined-ui {
                display: block; /* Show combined UI on mobile */
            }
            
            #timer.desktop-only {
                top: 10px;
                padding: 10px 15px;
                font-size: 14px;
            }
            
            #timer-display {
                font-size: 16px;
            }
            
            #best-time {
                font-size: 10px;
            }
        }
        
        #timer-display {
            color: #00BFFF;
            margin-bottom: 5px;
            font-size: 20px;
        }
        
        #best-time {
            font-size: 12px;
            color: #666;
            font-weight: normal;
            font-family: Arial, sans-serif;
        }
        
        .new-record {
            color: #FF6B35 !important;
            animation: recordFlash 1s ease-in-out infinite alternate;
        }
        
        @keyframes recordFlash {
            from { opacity: 1; }
            to { opacity: 0.7; }
        }
        
        /* Stamina Bar */
        #stamina-bar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00BFFF;
            font-family: Arial, sans-serif;
            min-width: 200px;
            z-index: 999;
        }
        
        /* Mobile responsive stamina bar */
        @media (max-width: 768px) {
            #stamina-bar {
                bottom: 100px;
                left: 50%;
                transform: translateX(-50%);
                right: auto;
                min-width: 180px;
                padding: 8px 12px;
            }
            
            #stamina-label {
                font-size: 12px;
            }
            
            #stamina-container {
                height: 16px;
            }
            
            #stamina-text {
                font-size: 10px;
            }
        }
        
        /* Landscape mobile - ensure centered layout */
        @media (max-width: 768px) and (orientation: landscape) {
            #stamina-bar {
                bottom: 80px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                right: auto !important;
                min-width: 200px !important;
                padding: 8px 12px !important;
            }
            
            #mobile-combined-ui {
                display: block !important;
                top: 10px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                min-width: 280px !important;
                padding: 8px 20px !important;
                font-size: 12px !important;
            }
            
            /* Hide desktop timer and stats in landscape */
            #timer {
                display: none !important;
            }
            
            #stats {
                display: none !important;
            }
        }
        
        #stamina-label {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            text-align: center;
        }
        
        #stamina-container {
            width: 100%;
            height: 20px;
            background: #ddd;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #999;
            margin-bottom: 5px;
        }
        
        #stamina-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            border-radius: 10px;
            transition: width 0.2s ease, background 0.3s ease;
            width: 100%;
        }
        
        #stamina-fill.low {
            background: linear-gradient(90deg, #FF9800, #FFC107);
        }
        
        #stamina-fill.critical {
            background: linear-gradient(90deg, #F44336, #FF5722);
            animation: staminaPulse 0.5s ease-in-out infinite alternate;
        }
        
        #stamina-fill.sprinting {
            background: linear-gradient(90deg, #2196F3, #03A9F4);
            animation: staminaDrain 0.3s ease-in-out infinite alternate;
        }
        
        #stamina-text {
            font-size: 12px;
            color: #666;
            text-align: center;
            font-weight: bold;
        }
        
        @keyframes staminaPulse {
            from { opacity: 1; }
            to { opacity: 0.6; }
        }
        
        @keyframes staminaDrain {
            from { transform: scaleX(1); }
            to { transform: scaleX(0.98); }
        }
        
        /* Mobile Controls Styles */
        #mobile-joystick {
            pointer-events: auto !important;
        }
        
        #mobile-zoom {
            pointer-events: auto !important;
        }
        
        #mobile-sprint {
            pointer-events: auto !important;
        }
        
        /* Mobile Fullscreen Button */
        #mobile-fullscreen {
            position: fixed !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            width: 160px !important;
            height: 80px !important;
            border-radius: 12px !important;
            background: rgba(0, 191, 255, 0.95) !important;
            border: 3px solid white !important;
            color: white !important;
            font-size: 24px !important;
            font-weight: bold !important;
            z-index: 2000 !important;
            display: block !important;
            pointer-events: auto !important;
            box-shadow: 0 6px 12px rgba(0,0,0,0.4) !important;
            transition: all 0.3s ease !important;
            user-select: none !important;
            -webkit-user-select: none !important;
            -webkit-touch-callout: none !important;
            font-family: Arial, sans-serif !important;
            text-align: center !important;
            line-height: 1.2 !important;
            cursor: pointer !important;
            /* Ensure it's above everything */
            position: fixed !important;
        }
        
        #mobile-fullscreen:active {
            transform: translate(-50%, -50%) scale(0.95) !important;
            background: rgba(0, 150, 200, 0.95) !important;
        }
        
        /* Ensure mobile controls are above other UI elements */
        #mobile-joystick,
        #mobile-zoom,
        #mobile-sprint {
            z-index: 1001 !important;
        }
        
        /* Hide desktop-only UI elements on mobile */
        @media (max-width: 768px) and (pointer: coarse) {
            #instructions p:contains("Mouse Wheel"),
            #instructions p:contains("P") {
                display: none;
            }
            
            /* Ensure stats are completely hidden on mobile */
            #stats,
            #stats.visible,
            #stats.game-ui {
                display: none !important;
            }
        }
        
        /* Mobile device detection using is-mobile class */
        /* ALWAYS hide desktop HUD on a touch device */
        body.is-mobile #timer,
        body.is-mobile #stats {
            display: none !important;
        }
        
        body.is-mobile #mobile-combined-ui {
            display: block !important;
            top: calc(env(safe-area-inset-top, 0px) + 5px); /* Closer to top + safe area */
            min-width: auto; /* Allow to shrink */
            padding: 6px 12px; /* Smaller padding */
            border-radius: 6px; /* Smaller border radius */
        }
         
        body.is-mobile #mobile-combined-ui #mobile-timer-display {
            font-size: 14px; /* Smaller timer */
            margin-bottom: 1px;
        }
        
        body.is-mobile #mobile-combined-ui #mobile-sheep-count {
            font-size: 10px; /* Smaller sheep count */
            margin-bottom: 1px;
        }
        
        body.is-mobile #mobile-combined-ui #mobile-best-time {
            font-size: 9px; /* Smaller best time */
        }
        
        /* New Container-Based Mobile Layout */
        
        /* Mobile Left Stack - Portrait Mode (just joystick) */
        @media (max-width: 768px) and (orientation: portrait) {
            #mobile-left-stack {
                position: fixed;
                bottom: calc(env(safe-area-inset-bottom, 0px) + 20px);
                left: calc(env(safe-area-inset-left, 0px) + 20px);
                display: flex;
                flex-direction: column;
                gap: 12px;
                z-index: 1001;
            }
            
            /* Children use relative positioning within stack */
            #mobile-left-stack > * {
                position: relative !important;
                left: auto !important;
                bottom: auto !important;
                right: auto !important;
                top: auto !important;
            }
            
            /* Sprint button positioned independently on bottom-right in portrait */
            #mobile-sprint {
                position: fixed !important;
                bottom: calc(env(safe-area-inset-bottom, 0px) + 20px) !important;
                right: calc(env(safe-area-inset-right, 0px) + 20px) !important;
                left: auto !important;
                top: auto !important;
            }
            
            /* Stamina bar in portrait - bottom center with some clearance */
            body.is-mobile #stamina-bar {
                bottom: calc(env(safe-area-inset-bottom, 0px) + 30px) !important; /* Less space needed now */
                left: 50% !important;
                transform: translateX(-50%) !important;
                right: auto !important;
            }
        }
        
        /* Mobile HUD Right - Landscape Fullscreen */
        @media (max-width: 768px) and (orientation: landscape) {
            body.mobile-fullscreen #mobile-hud-right {
                position: fixed;
                top: calc(env(safe-area-inset-top, 0px) + 10px);
                right: calc(env(safe-area-inset-right, 0px) + 10px);
                display: flex;
                flex-direction: column;
                align-items: flex-end;
                gap: 6px;
                z-index: 1002;
            }
            
            body.mobile-fullscreen #mobile-hud-right #mobile-combined-ui,
            body.mobile-fullscreen #mobile-hud-right #stamina-bar {
                position: relative !important;
                left: auto !important;
                right: auto !important;
                top: auto !important;
                bottom: auto !important;
                transform: none !important;
                min-width: 180px;
            }
        }
        
        /* Default mobile stamina positioning (non-portrait) */
        body.is-mobile #stamina-bar {
            bottom: calc(env(safe-area-inset-bottom, 0px) + 10px);
            left: 50%;
            transform: translateX(-50%);
            right: auto;
            min-width: 150px;
            padding: 5px 10px;
            border-radius: 6px;
        }

        body.is-mobile #stamina-label {
            font-size: 10px;
            margin-bottom: 4px;
        }

        body.is-mobile #stamina-container {
            height: 12px;
            margin-bottom: 3px;
        }

        body.is-mobile #stamina-text {
            font-size: 9px;
        }

        /* Landscape orientation adjustments for mobile */
        @media (orientation: landscape) {
            body.is-mobile #stamina-bar {
                bottom: calc(env(safe-area-inset-bottom, 0px) + 5px) !important;
                min-width: 180px !important;
                padding: 4px 8px !important;
            }

            body.is-mobile #mobile-combined-ui {
                min-width: auto !important;
                padding: 5px 10px !important;
                font-size: 10px !important;
                border-radius: 6px !important;
            }
            body.is-mobile #mobile-combined-ui #mobile-timer-display {
                font-size: 12px !important;
            }
            body.is-mobile #mobile-combined-ui #mobile-sheep-count {
                font-size: 9px !important;
            }
            body.is-mobile #mobile-combined-ui #mobile-best-time {
                font-size: 8px !important;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <!-- Start Screen Overlay -->
        <div id="start-screen">
            <h1 id="game-title">Sheep Dog Simulator</h1>
            <p id="game-subtitle">Guide 200 sheep to safety in this immersive 3D herding experience</p>
            
            <div id="start-instructions">
                <h3>How to Play</h3>
                <p>🐕 Use <strong>WASD</strong> or <strong>touch controls</strong> to move your sheepdog</p>
                <p>🏃 Hold <strong>Shift</strong> or <strong>sprint button</strong> to run faster</p>
                <p>🐑 Herd all 200 sheep through the golden gate into the pasture</p>
                <p>⏱️ Complete the challenge as quickly as possible</p>
                <p>🎯 Sheep will flee from you and flock together naturally</p>
                <p id="music-note" style="font-style: italic; color: #666; margin-top: 1rem;">🎵 Click anywhere to enable music</p>
            </div>
            
            <button id="start-button">Start Herding</button>
        </div>
        
        <!-- Mobile UI Containers -->
        <div id="mobile-left-stack">
            <!-- Sprint and joystick will be moved here by JS -->
        </div>
        
        <div id="mobile-hud-right">
            <!-- Combined UI and stamina bar will be grouped here by JS -->
        </div>
        
        <!-- Game UI Elements -->
        <div id="instructions" class="game-ui">
            <h3>Controls</h3>
            <p><strong>W</strong> - Move Forward</p>
            <p><strong>A</strong> - Move Left</p>
            <p><strong>S</strong> - Move Backward</p>
            <p><strong>D</strong> - Move Right</p>
            <p><strong>Shift</strong> - Sprint (uses stamina)</p>
            <p><strong>Mouse Wheel</strong> - Zoom In/Out</p>
            <p><strong>P</strong> - Toggle Performance Stats</p>
            <p id="mute-toggle">🔊 <strong>Click</strong> - Toggle Sound</p>
        </div>
        
        <div id="timer" class="game-ui">
            <div id="timer-display">00:00</div>
            <div id="best-time">Best: --:--</div>
        </div>
        
        <!-- Combined Mobile UI for timer and sheep count -->
        <div id="mobile-combined-ui" class="game-ui">
            <div id="mobile-timer-display">00:00</div>
            <div id="mobile-sheep-count">Sheep: 0 / 200</div>
            <div id="mobile-best-time">Best: --:--</div>
        </div>
        
        <div id="stats" class="game-ui">
            <p>Sheep Secured: <span id="sheep-count">0</span> / 200</p>
        </div>
        
        <div id="stamina-bar" class="game-ui">
            <div id="stamina-label">Stamina</div>
            <div id="stamina-container">
                <div id="stamina-fill"></div>
            </div>
            <div id="stamina-text">100%</div>
        </div>
        
        <div id="completion-message">
            All sheep successfully herded!
        </div>
    </div>
    
    <!-- Import map for Three.js r176 -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/",
            "stats.js": "https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"
        }
    }
    </script>
    
    <!-- Main application entry point -->
    <script type="module" src="js/main.js"></script>
</body>
</html>
```

## client/js/AudioManager.js

```javascript
import * as THREE from 'three';

/**
 * AudioManager - Handles all game audio with Three.js audio system
 * Provides simple interface for playing sounds with proper 3D audio support
 */
export class AudioManager {
    constructor(camera) {
        // Create audio listener and attach to camera
        this.listener = new THREE.AudioListener();
        camera.add(this.listener);
        
        // Audio loader
        this.loader = new THREE.AudioLoader();
        
        // Audio objects for each sound
        this.sounds = {
            uiClick: null,
            rewardingChime: null,
            sheepBleat: null,
            sheepdogBark: null
        };
        
        // Music tracks
        this.music = {
            startMusic: null,
            gameplay1: null,
            gameplay2: null,
            gameplay3: null,
            winMusic: null
        };
        
        // Track loading state
        this.isLoaded = false;
        this.musicLoaded = false;
        this.loadingPromises = [];
        this.musicLoadingPromises = [];
        
        // Volume settings
        this.masterVolume = 0.7;
        this.sfxVolume = 0.8;
        this.musicVolume = 0.5;
        
        // Specific volume multipliers for different sound types
        this.soundVolumeMultipliers = {
            uiClick: 1.0,
            rewardingChime: 1.0,
            sheepBleat: 0.5,        // 50% lower than normal
            sheepdogBark: 0.5       // 50% lower than normal
        };
        
        // Mute state
        this.isMuted = false;
        this.currentMusic = null; // Track currently playing music
        
        // Cooldown tracking to prevent sound spam
        this.lastPlayTimes = {
            sheepBleat: 0,
            sheepdogBark: 0
        };
        this.cooldowns = {
            sheepBleat: 500, // 500ms cooldown
            sheepdogBark: 300 // 300ms cooldown
        };
        
        // Load mute preference from localStorage
        this.loadMutePreference();
        
        this.loadSounds();
        this.loadMusic();
    }
    
    /**
     * Load all sound files
     */
    loadSounds() {
        const soundFiles = {
            uiClick: 'assets/sounds/11L-clean_UI_click,_wood-1748393658157.mp3',
            rewardingChime: 'assets/sounds/11L-short_rewarding_chim-1748393597911.mp3',
            sheepBleat: 'assets/sounds/11L-agitated_sheep_bleat-1748393501154.mp3',
            sheepdogBark: 'assets/sounds/11L-short_sharp_sheep_do-1748393459422.mp3'
        };
        
        // Load each sound
        Object.keys(soundFiles).forEach(soundKey => {
            const promise = new Promise((resolve, reject) => {
                this.loader.load(
                    soundFiles[soundKey],
                    (buffer) => {
                        // Create Audio object
                        this.sounds[soundKey] = new THREE.Audio(this.listener);
                        this.sounds[soundKey].setBuffer(buffer);
                        
                        // Apply specific volume multiplier for this sound type
                        const volumeMultiplier = this.soundVolumeMultipliers[soundKey] || 1.0;
                        this.sounds[soundKey].setVolume(this.masterVolume * this.sfxVolume * volumeMultiplier);
                        
                        console.log(`Loaded sound: ${soundKey}`);
                        resolve();
                    },
                    (progress) => {
                        // Loading progress
                    },
                    (error) => {
                        console.warn(`Failed to load sound ${soundKey}:`, error);
                        // Create a dummy audio object to prevent errors
                        this.sounds[soundKey] = { 
                            play: () => {}, 
                            stop: () => {}, 
                            isPlaying: false 
                        };
                        resolve(); // Resolve anyway to not block other sounds
                    }
                );
            });
            
            this.loadingPromises.push(promise);
        });
        
        // Wait for all sounds to load
        Promise.all(this.loadingPromises).then(() => {
            this.isLoaded = true;
            console.log('All sounds loaded successfully');
        }).catch((error) => {
            console.warn('Some sounds failed to load:', error);
            this.isLoaded = true; // Still mark as loaded to allow game to continue
        });
    }
    
    /**
     * Load all music files
     */
    loadMusic() {
        const musicFiles = {
            startMusic: 'assets/sounds/SDS Start Music.wav',
            gameplay1: 'assets/sounds/SDS1.wav',
            gameplay2: 'assets/sounds/SDS2.wav',
            gameplay3: 'assets/sounds/SDS3.wav',
            winMusic: 'assets/sounds/win.wav'
        };
        
        // Load each music track
        Object.keys(musicFiles).forEach(musicKey => {
            const promise = new Promise((resolve, reject) => {
                this.loader.load(
                    musicFiles[musicKey],
                    (buffer) => {
                        // Create Audio object
                        this.music[musicKey] = new THREE.Audio(this.listener);
                        this.music[musicKey].setBuffer(buffer);
                        this.music[musicKey].setVolume(this.masterVolume * this.musicVolume);
                        this.music[musicKey].setLoop(true); // Most music should loop
                        
                        console.log(`Loaded music: ${musicKey}`);
                        resolve();
                    },
                    (progress) => {
                        // Loading progress
                        console.log(`Loading music ${musicKey}: ${Math.round(progress.loaded / progress.total * 100)}%`);
                    },
                    (error) => {
                        console.warn(`Failed to load music ${musicKey}:`, error);
                        // Create a dummy audio object to prevent errors
                        this.music[musicKey] = { 
                            play: () => {}, 
                            stop: () => {}, 
                            pause: () => {},
                            setLoop: () => {},
                            setVolume: () => {},
                            isPlaying: false 
                        };
                        resolve(); // Resolve anyway to not block other music
                    }
                );
            });
            
            this.musicLoadingPromises.push(promise);
        });
        
        // Wait for all music to load
        Promise.all(this.musicLoadingPromises).then(() => {
            this.musicLoaded = true;
            console.log('All music loaded successfully');
            
            // Apply mute state to music
            this.updateAllVolumes();
            
            // Set up user interaction listener to start audio context
            this.setupAudioContextActivation();
        }).catch((error) => {
            console.warn('Some music failed to load:', error);
            this.musicLoaded = true; // Still mark as loaded to allow game to continue
        });
    }
    
    /**
     * Play UI click sound
     */
    playUIClick() {
        if (this.sounds.uiClick && !this.sounds.uiClick.isPlaying) {
            this.sounds.uiClick.play();
        }
    }
    
    /**
     * Play rewarding chime sound (for sheep passing gate or game completion)
     */
    playRewardingChime() {
        if (this.sounds.rewardingChime && !this.sounds.rewardingChime.isPlaying) {
            this.sounds.rewardingChime.play();
        }
    }
    
    /**
     * Play sheep bleat sound with cooldown to prevent spam
     */
    playSheepBleat() {
        const now = Date.now();
        if (now - this.lastPlayTimes.sheepBleat < this.cooldowns.sheepBleat) {
            return; // Still in cooldown
        }
        
        if (this.sounds.sheepBleat && !this.sounds.sheepBleat.isPlaying) {
            this.sounds.sheepBleat.play();
            this.lastPlayTimes.sheepBleat = now;
        }
    }
    
    /**
     * Play multiple layered sheep bleats for group herding
     * @param {number} sheepCount - Number of sheep being chased (1-5 max for audio clarity)
     */
    playGroupSheepBleats(sheepCount) {
        const now = Date.now();
        if (now - this.lastPlayTimes.sheepBleat < this.cooldowns.sheepBleat) {
            return; // Still in cooldown
        }
        
        // Limit to 5 simultaneous bleats for audio clarity
        const maxBleats = Math.min(sheepCount, 5);
        
        // Play first bleat immediately
        if (this.sounds.sheepBleat) {
            this.sounds.sheepBleat.play();
        }
        
        // Schedule additional bleats with staggered timing
        for (let i = 1; i < maxBleats; i++) {
            setTimeout(() => {
                if (this.sounds.sheepBleat) {
                    // Create a new audio instance for overlapping sounds
                    const additionalBleat = new THREE.Audio(this.listener);
                    additionalBleat.setBuffer(this.sounds.sheepBleat.buffer);
                    
                    // Apply the same volume multiplier as the main sheep bleat sound
                    const baseVolume = this.isMuted ? 0 : this.masterVolume * this.sfxVolume;
                    const volumeMultiplier = this.soundVolumeMultipliers.sheepBleat || 1.0;
                    const finalVolume = baseVolume * volumeMultiplier * (0.7 + Math.random() * 0.3); // Slight volume variation
                    
                    additionalBleat.setVolume(finalVolume);
                    additionalBleat.play();
                }
            }, i * (100 + Math.random() * 150)); // 100-250ms staggered delays
        }
        
        this.lastPlayTimes.sheepBleat = now;
    }
    
    /**
     * Play sheepdog bark sound with cooldown
     */
    playSheepdogBark() {
        const now = Date.now();
        if (now - this.lastPlayTimes.sheepdogBark < this.cooldowns.sheepdogBark) {
            return; // Still in cooldown
        }
        
        if (this.sounds.sheepdogBark && !this.sounds.sheepdogBark.isPlaying) {
            this.sounds.sheepdogBark.play();
            this.lastPlayTimes.sheepdogBark = now;
        }
    }
    
    /**
     * Play start screen music
     */
    playStartMusic() {
        if (this.music.startMusic && !this.music.startMusic.isPlaying) {
            this.stopAllMusic();
            this.currentMusic = this.music.startMusic;
            this.music.startMusic.play();
        }
    }
    
    /**
     * Play random gameplay background music
     */
    playGameplayMusic() {
        const gameplayTracks = [this.music.gameplay1, this.music.gameplay2, this.music.gameplay3];
        const randomTrack = gameplayTracks[Math.floor(Math.random() * gameplayTracks.length)];
        
        if (randomTrack && !randomTrack.isPlaying) {
            this.stopAllMusic();
            this.currentMusic = randomTrack;
            randomTrack.play();
        }
    }
    
    /**
     * Play win music (doesn't loop)
     */
    playWinMusic() {
        if (this.music.winMusic) {
            this.stopAllMusic();
            this.currentMusic = this.music.winMusic;
            this.music.winMusic.setLoop(false); // Win music plays once
            this.music.winMusic.play();
        }
    }
    
    /**
     * Stop all music
     */
    stopAllMusic() {
        Object.values(this.music).forEach(track => {
            if (track && track.isPlaying) {
                track.stop();
            }
        });
        this.currentMusic = null;
    }
    
    /**
     * Fade out current music (smooth transition)
     */
    fadeOutCurrentMusic(duration = 1000) {
        if (!this.currentMusic || !this.currentMusic.isPlaying) return;
        
        const startVolume = this.currentMusic.getVolume();
        const fadeSteps = 20;
        const stepDuration = duration / fadeSteps;
        const volumeStep = startVolume / fadeSteps;
        
        let currentStep = 0;
        const fadeInterval = setInterval(() => {
            currentStep++;
            const newVolume = startVolume - (volumeStep * currentStep);
            
            if (currentStep >= fadeSteps || newVolume <= 0) {
                this.currentMusic.stop();
                this.currentMusic.setVolume(startVolume); // Reset volume for next play
                this.currentMusic = null;
                clearInterval(fadeInterval);
            } else {
                this.currentMusic.setVolume(newVolume);
            }
        }, stepDuration);
    }
    
    /**
     * Set master volume (0.0 to 1.0)
     */
    setMasterVolume(volume) {
        this.masterVolume = Math.max(0, Math.min(1, volume));
        this.updateAllVolumes();
    }
    
    /**
     * Set SFX volume (0.0 to 1.0)
     */
    setSFXVolume(volume) {
        this.sfxVolume = Math.max(0, Math.min(1, volume));
        this.updateAllVolumes();
    }
    
    /**
     * Set music volume (0.0 to 1.0)
     */
    setMusicVolume(volume) {
        this.musicVolume = Math.max(0, Math.min(1, volume));
        this.updateAllVolumes();
    }
    
    /**
     * Toggle mute state
     */
    toggleMute() {
        this.isMuted = !this.isMuted;
        
        // Stop all currently playing sounds when muting
        if (this.isMuted) {
            this.stopAllSounds();
            this.stopAllMusic();
        }
        
        this.updateAllVolumes();
        this.saveMutePreference();
        return this.isMuted;
    }
    
    /**
     * Set mute state
     */
    setMuted(muted) {
        this.isMuted = muted;
        
        // Stop all currently playing sounds when muting
        if (this.isMuted) {
            this.stopAllSounds();
            this.stopAllMusic();
        }
        
        this.updateAllVolumes();
        this.saveMutePreference();
    }
    
    /**
     * Get current mute state
     */
    isMutedState() {
        return this.isMuted;
    }
    
    /**
     * Load mute preference from localStorage
     */
    loadMutePreference() {
        try {
            const saved = localStorage.getItem('sheepdog-muted');
            if (saved !== null) {
                this.isMuted = JSON.parse(saved);
            }
        } catch (error) {
            console.warn('Failed to load mute preference:', error);
            this.isMuted = false;
        }
    }
    
    /**
     * Save mute preference to localStorage
     */
    saveMutePreference() {
        try {
            localStorage.setItem('sheepdog-muted', JSON.stringify(this.isMuted));
        } catch (error) {
            console.warn('Failed to save mute preference:', error);
        }
    }
    
    /**
     * Update volume for all loaded sounds and music
     */
    updateAllVolumes() {
        const effectiveVolume = this.isMuted ? 0 : this.masterVolume;
        const baseSFXVolume = effectiveVolume * this.sfxVolume;
        const finalMusicVolume = effectiveVolume * this.musicVolume;
        
        // Update sound effects with specific volume multipliers
        Object.keys(this.sounds).forEach(soundKey => {
            const sound = this.sounds[soundKey];
            if (sound && sound.setVolume) {
                const volumeMultiplier = this.soundVolumeMultipliers[soundKey] || 1.0;
                sound.setVolume(baseSFXVolume * volumeMultiplier);
            }
        });
        
        // Update music
        Object.values(this.music).forEach(track => {
            if (track && track.setVolume) {
                track.setVolume(finalMusicVolume);
            }
        });
    }
    
    /**
     * Stop all currently playing sounds
     */
    stopAllSounds() {
        Object.values(this.sounds).forEach(sound => {
            if (sound && sound.isPlaying) {
                sound.stop();
            }
        });
    }
    
    /**
     * Check if audio system is ready
     */
    isReady() {
        return this.isLoaded;
    }
    
    /**
     * Check if music system is ready
     */
    isMusicReady() {
        return this.musicLoaded;
    }
    
    /**
     * Set up audio context activation on user interaction
     */
    setupAudioContextActivation() {
        this.audioContextActivated = false;
        
        const activateAudio = (event) => {
            if (this.listener.context.state === 'suspended') {
                this.listener.context.resume().then(() => {
                    console.log('Audio context activated');
                    this.audioContextActivated = true;
                    
                    // Only start music if this wasn't the start button click
                    const isStartButton = event.target && (
                        event.target.id === 'start-button' || 
                        event.target.closest('#start-button')
                    );
                    
                    if (this.musicLoaded && !this.currentMusic && !isStartButton) {
                        this.playStartMusic();
                    }
                });
            } else {
                this.audioContextActivated = true;
            }
            
            // Remove listeners after first activation
            document.removeEventListener('click', activateAudio);
            document.removeEventListener('keydown', activateAudio);
        };
        
        // Listen for any user interaction
        document.addEventListener('click', activateAudio);
        document.addEventListener('keydown', activateAudio);
    }
    
    /**
     * Manually trigger start music (for delayed start)
     */
    triggerStartMusic() {
        if (this.musicLoaded && !this.currentMusic && this.audioContextActivated) {
            this.playStartMusic();
        }
    }
    
    /**
     * Get audio context state (for debugging)
     */
    getAudioContextState() {
        return this.listener.context.state;
    }
}
```

## client/js/Boid.js

```javascript
import { Vector2D } from './Vector2D.js';

/**
 * Base Boid class implementing flocking behavior
 */
export class Boid {
    constructor(x, z, config = {}) {
        this.position = new Vector2D(x, z);
        this.velocity = Vector2D.random();
        this.acceleration = new Vector2D(0, 0);
        
        // Configuration
        this.maxSpeed = config.maxSpeed || 1.5;
        this.maxForce = config.maxForce || 0.05;
        this.perceptionRadius = config.perceptionRadius || 5;
        
        // Behavior weights
        this.separationWeight = config.separationWeight || 1.5;
        this.alignmentWeight = config.alignmentWeight || 1.0;
        this.cohesionWeight = config.cohesionWeight || 1.0;
        
        // Anti-jittering properties
        this.previousVelocity = this.velocity.clone();
        this.velocitySmoothing = 0.85; // Higher = more smoothing
        this.minMovementThreshold = 0.001; // Minimum velocity to prevent micro-movements
        this.forceAccumulator = new Vector2D(0, 0);
        this.dampingFactor = 0.98; // Velocity damping to reduce oscillations
        
        // Visual representation
        this.mesh = null;
    }

    // Apply a force to the boid with smoothing
    applyForce(force) {
        // Accumulate forces instead of applying directly
        this.forceAccumulator.add(force);
    }

    // Main flocking behavior
    flock(boids, separationDistance) {
        const neighbors = this.getNeighbors(boids);
        
        if (neighbors.length > 0) {
            // Calculate flocking forces
            const separation = this.separate(neighbors, separationDistance);
            const alignment = this.align(neighbors);
            const cohesion = this.cohere(neighbors);
            
            // Weight and apply forces
            separation.multiply(this.separationWeight);
            alignment.multiply(this.alignmentWeight);
            cohesion.multiply(this.cohesionWeight);
            
            this.applyForce(separation);
            this.applyForce(alignment);
            this.applyForce(cohesion);
        }
    }

    // Separation: steer to avoid crowding local flockmates
    separate(neighbors, desiredSeparation) {
        const steer = new Vector2D(0, 0);
        let count = 0;

        for (let neighbor of neighbors) {
            const distance = this.position.distanceTo(neighbor.position);
            
            if (distance > 0 && distance < desiredSeparation) {
                // Calculate vector pointing away from neighbor
                const diff = this.position.clone().subtract(neighbor.position);
                diff.normalize();
                diff.divide(distance); // Weight by distance (closer = stronger)
                steer.add(diff);
                count++;
            }
        }

        if (count > 0) {
            steer.divide(count);
            steer.normalize();
            steer.multiply(this.maxSpeed);
            steer.subtract(this.velocity);
            steer.limit(this.maxForce);
        }

        return steer;
    }

    // Alignment: steer towards the average heading of local flockmates
    align(neighbors) {
        const sum = new Vector2D(0, 0);
        
        for (let neighbor of neighbors) {
            sum.add(neighbor.velocity);
        }
        
        sum.divide(neighbors.length);
        sum.normalize();
        sum.multiply(this.maxSpeed);
        
        const steer = sum.subtract(this.velocity);
        steer.limit(this.maxForce);
        
        return steer;
    }

    // Cohesion: steer to move toward the average position of local flockmates
    cohere(neighbors) {
        const sum = new Vector2D(0, 0);
        
        for (let neighbor of neighbors) {
            sum.add(neighbor.position);
        }
        
        sum.divide(neighbors.length);
        return this.seek(sum);
    }

    // Seek a target position
    seek(target) {
        const desired = target.clone().subtract(this.position);
        desired.normalize();
        desired.multiply(this.maxSpeed);
        
        const steer = desired.subtract(this.velocity);
        steer.limit(this.maxForce);
        
        return steer;
    }

    // Flee from a target position
    flee(target, fleeRadius = 10) {
        const distance = this.position.distanceTo(target);
        
        if (distance < fleeRadius) {
            const desired = this.position.clone().subtract(target);
            desired.normalize();
            desired.multiply(this.maxSpeed);
            
            const steer = desired.subtract(this.velocity);
            steer.limit(this.maxForce * 2); // Stronger flee force
            
            return steer;
        }
        
        return new Vector2D(0, 0);
    }

    // Boundary avoidance
    avoidBoundaries(bounds) {
        const margin = 10; // Increased margin for earlier activation
        const steer = new Vector2D(0, 0);
        const position = this.position;
        
        // Calculate distances to boundaries
        const distToMinX = position.x - bounds.minX;
        const distToMaxX = bounds.maxX - position.x;
        const distToMinZ = position.z - bounds.minZ;
        const distToMaxZ = bounds.maxZ - position.z;
        
        // Apply repulsion force based on proximity to boundary (reduced multipliers)
        if (distToMinX < margin) {
            const force = (margin - distToMinX) / margin;
            steer.x = this.maxSpeed * force * 1.2; // Reduced from 2
        } else if (distToMaxX < margin) {
            const force = (margin - distToMaxX) / margin;
            steer.x = -this.maxSpeed * force * 1.2;
        }
        
        if (distToMinZ < margin) {
            const force = (margin - distToMinZ) / margin;
            steer.z = this.maxSpeed * force * 1.2;
        } else if (distToMaxZ < margin) {
            const force = (margin - distToMaxZ) / margin;
            steer.z = -this.maxSpeed * force * 1.2;
        }
        
        if (steer.magnitude() > 0) {
            steer.normalize();
            steer.multiply(this.maxSpeed * 1.5); // Reduced from 2
            steer.subtract(this.velocity);
            steer.limit(this.maxForce * 2.5); // Reduced from 5
        }
        
        return steer;
    }

    // Get neighboring boids within perception radius
    getNeighbors(boids) {
        const neighbors = [];
        
        for (let boid of boids) {
            if (boid !== this) {
                const distance = this.position.distanceTo(boid.position);
                if (distance < this.perceptionRadius) {
                    neighbors.push(boid);
                }
            }
        }
        
        return neighbors;
    }

    // Update position based on velocity and acceleration
    update(deltaTime = 0.016) {
        // Apply accumulated forces to acceleration with damping
        this.acceleration.add(this.forceAccumulator);
        this.forceAccumulator.multiply(0); // Reset force accumulator
        
        // Store previous velocity for smoothing
        this.previousVelocity = this.velocity.clone();
        
        // Update velocity
        this.velocity.add(this.acceleration);
        this.velocity.limit(this.maxSpeed);
        
        // Apply velocity damping to reduce oscillations
        this.velocity.multiply(this.dampingFactor);
        
        // Smooth velocity with previous velocity to reduce jittering
        const smoothedVelocity = this.previousVelocity.clone()
            .multiply(this.velocitySmoothing)
            .add(this.velocity.clone().multiply(1 - this.velocitySmoothing));
        
        // Only apply movement if above threshold to prevent micro-movements
        if (smoothedVelocity.magnitude() > this.minMovementThreshold) {
            this.velocity = smoothedVelocity;
            this.position.add(this.velocity);
        } else {
            // Stop micro-movements
            this.velocity.multiply(0);
        }
        
        // Reset acceleration
        this.acceleration.multiply(0);
        
        // Update mesh position if it exists
        if (this.mesh) {
            this.mesh.position.x = this.position.x;
            this.mesh.position.z = this.position.z;
            
            // Rotate mesh to face movement direction (only if moving significantly)
            if (this.velocity.magnitude() > this.minMovementThreshold * 10) {
                this.mesh.rotation.y = -this.velocity.angle() + Math.PI / 2;
            }
        }
    }
}
```

## client/js/GameState.js

```javascript
import { Vector2D } from './Vector2D.js';
import { OptimizedSheepSystem } from './OptimizedSheep.js';

/**
 * GameState - Handles game configuration, boundaries, and state management
 */
export class GameState {
    constructor() {
        // Field boundaries
        this.bounds = {
            minX: -100,
            maxX: 100,
            minZ: -100,
            maxZ: 100
        };
        
        // Gate and pasture configuration
        this.gate = {
            position: new Vector2D(0, 100), // At the fence border
            width: 8,
            height: 4,
            // Gate passage zone (invisible box for detection)
            passageZone: {
                minX: -4,
                maxX: 4,
                minZ: 98,
                maxZ: 102
            }
        };
        
        // Sleeping pasture area (beyond the gate)
        this.pasture = {
            centerZ: 115, // Beyond the gate
            minX: -30,
            maxX: 30,
            minZ: 102,
            maxZ: 130
        };
        
        // Simulation parameters
        this.params = {
            speed: 0.1,  // Sheep movement speed
            cohesion: 1.0,
            separationDistance: 2.0
        };
        
        // Game state
        this.sheep = [];
        this.sheepdog = null;
        this.sheepRetired = 0;
        this.gameCompleted = false;
        this.totalSheep = 200;
        this.gameActive = false; // New: tracks if game is actively being played
        this.isPaused = false; // New: tracks if game is paused
        this.audioManager = null;
        
        // Always use optimized sheep system
        this.optimizedSheepSystem = null;
    }
    
    createSheepFlock(scene) {
        // Create optimized sheep system
        this.optimizedSheepSystem = new OptimizedSheepSystem(scene, this.totalSheep);
        this.sheep = this.optimizedSheepSystem.getSheep();
        
        // Set bounds for each sheep instance
        this.sheep.forEach(sheep => sheep.setBounds(this.bounds));
        
        // Set audio manager if available
        if (this.audioManager) {
            this.optimizedSheepSystem.setAudioManager(this.audioManager);
        }
        
        return null; // No individual meshes to return
    }
    
    setPaused(paused) {
        this.isPaused = paused;
    }
    
    isPausedState() {
        return this.isPaused;
    }
    
    updateSheepBehaviors(deltaTime = 0.016) {
        // Don't update sheep behaviors if paused
        if (this.isPaused) {
            return this.sheepRetired;
        }
        
        // Always update sheep behaviors for visual effect
        this.optimizedSheepSystem.update(
            deltaTime,
            this.gameActive ? this.sheepdog : null, // Only pass sheepdog if game is active
            this.gameActive ? this.gate : null,     // Only enable gate mechanics if game is active
            this.gameActive ? this.pasture : null,  // Only enable pasture mechanics if game is active
            this.bounds,  // Always pass bounds so sheep stay in field
            this.params   // Always pass params so sheep can flock
        );
        
        // Only count retired sheep if game is active
        if (this.gameActive) {
            this.sheepRetired = 0;
            
            // Count retired sheep
            for (let sheep of this.sheep) {
                // Check if sheep has passed gate
                if (!sheep.hasPassedGate && !sheep.isRetiring) {
                    if (sheep.checkGatePassageAndRetire(this.gate.passageZone, this.pasture)) {
                        // Sheep just passed through the gate
                        this.sheepRetired++;
                        
                        // Play rewarding chime sound
                        if (this.audioManager) {
                            this.audioManager.playRewardingChime();
                        }
                    }
                }
                
                // Count all sheep that have passed or are retiring
                if (sheep.hasPassedGate || sheep.isRetiring) {
                    this.sheepRetired++;
                }
            }
        }
        
        return this.sheepRetired;
    }
    
    checkCompletion() {
        // Only check completion if game is active and not paused
        if (!this.gameActive || this.isPaused) return false;
        
        if (this.sheepRetired === this.sheep.length && !this.gameCompleted) {
            this.gameCompleted = true;
            
            // Play completion sound and win music
            if (this.audioManager) {
                this.audioManager.playRewardingChime();
                
                // Stop gameplay music and start win music
                setTimeout(() => {
                    this.audioManager.stopAllMusic();
                    this.audioManager.playWinMusic();
                }, 500); // Small delay for the chime to play
            }
            
            return true;
        }
        return false;
    }
    
    updateUI() {
        // Only update UI if game is active and not paused
        if (!this.gameActive || this.isPaused) return;
        
        // Update desktop sheep count
        const sheepCountElement = document.getElementById('sheep-count');
        if (sheepCountElement) {
            sheepCountElement.textContent = this.sheepRetired;
        }
        
        // Update mobile sheep count
        const mobileSheepCountElement = document.getElementById('mobile-sheep-count');
        if (mobileSheepCountElement) {
            mobileSheepCountElement.textContent = `Sheep: ${this.sheepRetired} / ${this.totalSheep}`;
        }
    }
    
    showCompletionMessage(finalTime, isNewRecord) {
        let message = 'All sheep have been guided to the pasture!';
        
        if (finalTime !== null) {
            const timeStr = this.formatTime(finalTime);
            message += `\nTime: ${timeStr}`;
            
            if (isNewRecord) {
                message += '\n🎉 NEW BEST TIME! 🎉';
            }
        }
        
        const completionElement = document.getElementById('completion-message');
        if (completionElement) {
            completionElement.innerHTML = 
                message.replace(/\n/g, '<br>') + '<br><button id="restart-button">Play Again</button>';
            completionElement.style.display = 'block';
            
            // Add event listener for restart button
            const restartButton = document.getElementById('restart-button');
            if (restartButton) {
                restartButton.addEventListener('click', () => {
                    // Trigger a full restart to start screen
                    location.reload();
                });
            }
        }
    }
    
    formatTime(timeInSeconds) {
        const minutes = Math.floor(timeInSeconds / 60);
        const seconds = Math.floor(timeInSeconds % 60);
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    
    // Getters
    getBounds() {
        return this.bounds;
    }
    
    getGate() {
        return this.gate;
    }
    
    getPasture() {
        return this.pasture;
    }
    
    getParams() {
        return this.params;
    }
    
    getSheep() {
        return this.sheep;
    }
    
    getSheepdog() {
        return this.sheepdog;
    }
    
    setSheepdog(sheepdog) {
        this.sheepdog = sheepdog;
    }
    
    getSheepRetired() {
        return this.sheepRetired;
    }
    
    getTotalSheep() {
        return this.totalSheep;
    }
    
    isGameCompleted() {
        return this.gameCompleted;
    }
    
    startGame() {
        this.gameActive = true;
        this.gameCompleted = false;
        this.sheepRetired = 0;
        this.isPaused = false; // Ensure game starts unpaused
        
        // Reset all sheep to their starting positions and states
        if (this.optimizedSheepSystem) {
            this.optimizedSheepSystem.resetAllSheep();
        }
    }
    
    isGameActive() {
        return this.gameActive;
    }
    
    setAudioManager(audioManager) {
        this.audioManager = audioManager;
        
        // If sheep system already exists, pass audio manager to it
        if (this.optimizedSheepSystem) {
            this.optimizedSheepSystem.setAudioManager(audioManager);
        }
    }
    
    reset() {
        this.sheep = [];
        this.sheepdog = null;
        this.sheepRetired = 0;
        this.gameCompleted = false;
        this.gameActive = false;
        this.isPaused = false;
        this.optimizedSheepSystem = null;
    }
}
```

## client/js/GameTimer.js

```javascript
/**
 * GameTimer - Handles timer functionality and best time tracking
 */
export class GameTimer {
    constructor() {
        this.startTime = null;
        this.currentTime = 0;
        this.timerRunning = false;
        this.isPaused = false;
        this.pausedTime = 0; // Total time spent paused
        this.pauseStartTime = null;
        this.bestTime = this.loadBestTime();
        
        this.initializeTimer();
    }
    
    initializeTimer() {
        this.updateTimerDisplay();
        this.updateBestTimeDisplay();
    }
    
    start() {
        if (!this.timerRunning) {
            this.startTime = performance.now();
            this.timerRunning = true;
            this.pausedTime = 0; // Reset paused time when starting
        }
    }
    
    stop() {
        if (this.timerRunning) {
            this.timerRunning = false;
            this.isPaused = false; // Clear pause state when stopping
            this.pauseStartTime = null;
            
            const finalTime = this.currentTime;
            
            // Check if this is a new best time
            if (this.bestTime === null || finalTime < this.bestTime) {
                this.bestTime = finalTime;
                this.saveBestTime(this.bestTime);
                this.updateBestTimeDisplay();
                this.showNewRecordAnimation();
            }
            
            return finalTime;
        }
        return null;
    }
    
    pause() {
        if (this.timerRunning && !this.isPaused) {
            this.isPaused = true;
            this.pauseStartTime = performance.now();
        }
    }
    
    resume() {
        if (this.timerRunning && this.isPaused) {
            this.isPaused = false;
            if (this.pauseStartTime !== null) {
                this.pausedTime += performance.now() - this.pauseStartTime;
                this.pauseStartTime = null;
            }
        }
    }
    
    setPaused(paused) {
        if (paused) {
            this.pause();
        } else {
            this.resume();
        }
    }
    
    update() {
        if (this.timerRunning && this.startTime !== null && !this.isPaused) {
            const currentPausedTime = this.pauseStartTime !== null ? 
                this.pausedTime + (performance.now() - this.pauseStartTime) : 
                this.pausedTime;
            
            this.currentTime = (performance.now() - this.startTime - currentPausedTime) / 1000; // Convert to seconds
            this.updateTimerDisplay();
        }
    }
    
    updateTimerDisplay() {
        const timeToDisplay = this.timerRunning ? this.currentTime : 0;
        const minutes = Math.floor(timeToDisplay / 60);
        const seconds = Math.floor(timeToDisplay % 60);
        const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        // Update desktop timer
        const timerElement = document.getElementById('timer-display');
        if (timerElement) {
            timerElement.textContent = formattedTime;
            
            // Add visual indication when paused
            if (this.isPaused && this.timerRunning) {
                timerElement.style.opacity = '0.6';
                timerElement.style.color = '#ffaa00';
            } else {
                timerElement.style.opacity = '1';
                timerElement.style.color = '';
            }
        }
        
        // Update mobile timer
        const mobileTimerElement = document.getElementById('mobile-timer-display');
        if (mobileTimerElement) {
            mobileTimerElement.textContent = formattedTime;
            
            // Add visual indication when paused
            if (this.isPaused && this.timerRunning) {
                mobileTimerElement.style.opacity = '0.6';
                mobileTimerElement.style.color = '#ffaa00';
            } else {
                mobileTimerElement.style.opacity = '1';
                mobileTimerElement.style.color = '';
            }
        }
    }
    
    updateBestTimeDisplay() {
        const bestTimeText = this.bestTime !== null ? 
            `Best: ${this.formatTime(this.bestTime)}` : 
            'Best: --:--';
        
        // Update desktop best time
        const bestTimeElement = document.getElementById('best-time');
        if (bestTimeElement) {
            bestTimeElement.textContent = bestTimeText;
        }
        
        // Update mobile best time
        const mobileBestTimeElement = document.getElementById('mobile-best-time');
        if (mobileBestTimeElement) {
            mobileBestTimeElement.textContent = bestTimeText;
        }
    }
    
    showNewRecordAnimation() {
        // Animate desktop element
        const bestTimeElement = document.getElementById('best-time');
        if (bestTimeElement) {
            bestTimeElement.classList.add('new-record');
            setTimeout(() => {
                bestTimeElement.classList.remove('new-record');
            }, 3000);
        }
        
        // Animate mobile element
        const mobileBestTimeElement = document.getElementById('mobile-best-time');
        if (mobileBestTimeElement) {
            mobileBestTimeElement.classList.add('new-record');
            setTimeout(() => {
                mobileBestTimeElement.classList.remove('new-record');
            }, 3000);
        }
    }
    
    loadBestTime() {
        try {
            const saved = localStorage.getItem('sheepdog-best-time');
            return saved ? parseFloat(saved) : null;
        } catch (error) {
            console.warn('Could not load best time from localStorage:', error);
            return null;
        }
    }
    
    saveBestTime(time) {
        try {
            localStorage.setItem('sheepdog-best-time', time.toString());
        } catch (error) {
            console.warn('Could not save best time to localStorage:', error);
        }
    }
    
    formatTime(timeInSeconds) {
        const minutes = Math.floor(timeInSeconds / 60);
        const seconds = Math.floor(timeInSeconds % 60);
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    
    getCurrentTime() {
        return this.currentTime;
    }
    
    getBestTime() {
        return this.bestTime;
    }
    
    isRunning() {
        return this.timerRunning;
    }
    
    isPausedState() {
        return this.isPaused;
    }
    
    reset() {
        this.startTime = null;
        this.currentTime = 0;
        this.timerRunning = false;
        this.isPaused = false;
        this.pausedTime = 0;
        this.pauseStartTime = null;
        this.updateTimerDisplay();
    }
}
```

## client/js/InputHandler.js

```javascript
import { Vector2D } from './Vector2D.js';

/**
 * Enhanced input handler for both keyboard and mobile touch controls
 */
export class InputHandler {
    constructor() {
        this.keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            shift: false
        };
        
        this.performanceMonitor = null;
        this.isPaused = false;
        this.pauseCallbacks = [];
        this.mobileControls = null;
        this.setupEventListeners();
    }

    setupEventListeners() {
        // Keydown event
        window.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            
            // Handle pause toggle with Escape key
            if (event.key === 'Escape') {
                this.togglePause();
                event.preventDefault();
                return;
            }
            
            // Only process other keys if not paused
            if (this.isPaused) {
                event.preventDefault();
                return;
            }
            
            if (key in this.keys) {
                this.keys[key] = true;
                event.preventDefault();
            } else if (event.key === 'Shift') {
                this.keys.shift = true;
                event.preventDefault();
            } else if (key === 'p' && this.performanceMonitor) {
                // Toggle performance monitor with 'P' key
                this.performanceMonitor.toggle();
                event.preventDefault();
            }
        });

        // Keyup event
        window.addEventListener('keyup', (event) => {
            const key = event.key.toLowerCase();
            
            // Don't process movement key releases if paused
            if (this.isPaused && key in this.keys) {
                event.preventDefault();
                return;
            }
            
            if (key in this.keys) {
                this.keys[key] = false;
                event.preventDefault();
            } else if (event.key === 'Shift') {
                this.keys.shift = false;
                event.preventDefault();
            }
        });

        // Reset keys when window loses focus
        window.addEventListener('blur', () => {
            for (let key in this.keys) {
                this.keys[key] = false;
            }
        });
    }

    // Set mobile controls reference
    setMobileControls(mobileControls) {
        this.mobileControls = mobileControls;
    }

    // Toggle pause state
    togglePause() {
        this.isPaused = !this.isPaused;
        
        // Clear all movement keys when pausing
        if (this.isPaused) {
            for (let key in this.keys) {
                this.keys[key] = false;
            }
        }
        
        // Notify all registered callbacks about pause state change
        this.pauseCallbacks.forEach(callback => callback(this.isPaused));
        
        // Show/hide pause indicator
        this.updatePauseUI();
    }

    // Register a callback to be called when pause state changes
    onPauseToggle(callback) {
        this.pauseCallbacks.push(callback);
    }

    // Update pause UI indicator
    updatePauseUI() {
        let pauseIndicator = document.getElementById('pause-indicator');
        
        if (this.isPaused) {
            if (!pauseIndicator) {
                pauseIndicator = document.createElement('div');
                pauseIndicator.id = 'pause-indicator';
                
                // Different pause message for mobile vs desktop
                const isMobile = this.mobileControls && this.mobileControls.getIsTouchDevice();
                const pauseMessage = isMobile ? 
                    '⏸️ PAUSED<br><small>Tap to resume</small>' : 
                    '⏸️ PAUSED<br><small>Press ESC to resume</small>';
                
                pauseIndicator.innerHTML = pauseMessage;
                pauseIndicator.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    font-size: 24px;
                    text-align: center;
                    z-index: 1000;
                    font-family: Arial, sans-serif;
                `;
                
                // Add touch event for mobile resume
                if (isMobile) {
                    pauseIndicator.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.togglePause();
                    });
                }
                
                document.body.appendChild(pauseIndicator);
            }
            pauseIndicator.style.display = 'block';
        } else {
            if (pauseIndicator) {
                pauseIndicator.style.display = 'none';
            }
        }
    }

    // Get movement direction based on current input state (keyboard + mobile)
    getMovementDirection() {
        // Return zero movement if paused
        if (this.isPaused) {
            return new Vector2D(0, 0);
        }
        
        // Start with keyboard input
        const direction = new Vector2D(0, 0);
        
        if (this.keys.w) direction.z += 1;
        if (this.keys.s) direction.z -= 1;
        if (this.keys.a) direction.x += 1;
        if (this.keys.d) direction.x -= 1;
        
        // Add mobile input if available and no keyboard input
        if (this.mobileControls && this.mobileControls.getIsTouchDevice()) {
            const mobileDirection = this.mobileControls.getMovementDirection();
            
            // If no keyboard input, use mobile input
            if (direction.magnitude() === 0) {
                direction.x = mobileDirection.x;
                direction.z = mobileDirection.z;
            }
        }
        
        return direction;
    }

    // Check if any movement input is active
    isMoving() {
        // Return false if paused
        if (this.isPaused) {
            return false;
        }
        
        // Check keyboard input
        const keyboardMoving = this.keys.w || this.keys.a || this.keys.s || this.keys.d;
        
        // Check mobile input
        const mobileMoving = this.mobileControls && 
                            this.mobileControls.getIsTouchDevice() && 
                            this.mobileControls.getIsMoving();
        
        return keyboardMoving || mobileMoving;
    }
    
    // Check if sprint input is active (keyboard shift or mobile sprint button)
    isSprinting() {
        // Return false if paused
        if (this.isPaused) {
            return false;
        }
        
        // Check keyboard sprint
        const keyboardSprinting = this.keys.shift;
        
        // Check mobile sprint
        const mobileSprinting = this.mobileControls && 
                               this.mobileControls.getIsTouchDevice() && 
                               this.mobileControls.getIsSprinting();
        
        return keyboardSprinting || mobileSprinting;
    }
    
    // Check if game is paused
    isPausedState() {
        return this.isPaused;
    }
    
    // Set performance monitor reference for toggle functionality
    setPerformanceMonitor(performanceMonitor) {
        this.performanceMonitor = performanceMonitor;
    }
}
```

## client/js/main.js

```javascript
import * as THREE from 'three';
import { SceneManager } from './SceneManager.js';
import { GameState } from './GameState.js';
import { GameTimer } from './GameTimer.js';
import { TerrainBuilder } from './TerrainBuilder.js';
import { StructureBuilder } from './StructureBuilder.js';
import { InputHandler } from './InputHandler.js';
import { MobileControls } from './MobileControls.js';
import { Sheepdog } from './Sheepdog.js';
import { PerformanceMonitor } from './PerformanceMonitor.js';
import { StartScreen } from './StartScreen.js';
import { StaminaUI } from './StaminaUI.js';
import { AudioManager } from './AudioManager.js';

/**
 * Main simulation controller - Enhanced with mobile controls support
 * Uses separate modules for different responsibilities
 */
class SheepDogSimulation {
    constructor() {
        // Initialize all modules
        this.sceneManager = new SceneManager();
        this.gameState = new GameState();
        this.gameTimer = new GameTimer();
        this.terrainBuilder = new TerrainBuilder(this.sceneManager.getScene());
        this.structureBuilder = new StructureBuilder(this.sceneManager.getScene());
        this.inputHandler = new InputHandler();
        this.performanceMonitor = new PerformanceMonitor();
        this.startScreen = new StartScreen(this.sceneManager);
        this.staminaUI = new StaminaUI();
        this.audioManager = new AudioManager(this.sceneManager.getCamera());
        
        // Create mobile controls with sceneManager and audioManager
        this.mobileControls = new MobileControls(this.sceneManager, this.audioManager);
        
        // Add mobile class to body if touch device detected
        if (this.mobileControls.getIsTouchDevice()) {
            document.body.classList.add('is-mobile');
            this.organizeMobileUIContainers();
        }
        
        // Connect mobile controls to input handler and scene manager
        this.inputHandler.setMobileControls(this.mobileControls);
        this.sceneManager.setMobileControls(this.mobileControls);
        
        // Connect performance monitor and game state to input handler
        this.inputHandler.setPerformanceMonitor(this.performanceMonitor);
        
        // Set up pause functionality
        this.setupPauseHandling();
        
        // Set up start screen callback
        this.startScreen.setGameStartCallback(() => {
            this.startGame();
        });
        
        // Pass audio manager to modules that need it
        this.gameState.setAudioManager(this.audioManager);
        this.startScreen.setAudioManager(this.audioManager);
        
        // Animation timing
        this.lastTime = performance.now();
        
        // Movement state tracking (for consistency with multiplayer version)
        this.playerWasMoving = false;
        
        // Initialize the simulation
        this.init();
        this.animate();
    }
    
    setupPauseHandling() {
        // Register pause callback with input handler
        this.inputHandler.onPauseToggle((isPaused) => {
            // Propagate pause state to timer
            this.gameTimer.setPaused(isPaused);
            
            // Propagate pause state to game state
            this.gameState.setPaused(isPaused);
        });
    }
    
    init() {
        // Create terrain and environment
        this.terrainBuilder.createTerrain();
        this.terrainBuilder.createGrass();
        this.terrainBuilder.createTrees();
        this.terrainBuilder.addEnvironmentDetails();
        
        // Create structures
        this.structureBuilder.createFieldBoundaryFence(
            this.gameState.getBounds(), 
            this.gameState.getGate()
        );
        this.structureBuilder.createGateAndPasture(
            this.gameState.getGate(), 
            this.gameState.getPasture()
        );
        
        // Create sheepdog (but don't add to scene yet in pre-game state)
        const sheepdog = new Sheepdog(0, -30);
        this.sheepdog = sheepdog;
        this.sheepdogMesh = sheepdog.createMesh();
        this.gameState.setSheepdog(sheepdog);
        
        // Connect audio manager to sheepdog
        sheepdog.setAudioManager(this.audioManager);
        
        // Create optimized sheep flock (visible during start screen)
        this.gameState.createSheepFlock(this.sceneManager.getScene());
        
        // Setup controls
        this.sceneManager.setupMouseControls();
        
        // Set grass instance count for performance monitoring
        this.performanceMonitor.setGrassInstanceCount(this.terrainBuilder.getGrassInstanceCount());
    }
    
    startGame() {
        // Add sheepdog to scene when game starts
        this.sceneManager.add(this.sheepdogMesh);
        
        // Enable mobile controls if on touch device
        if (this.mobileControls.getIsTouchDevice()) {
            this.mobileControls.enable();
        }
        
        // Start the game state
        this.gameState.startGame();
        
        // Reset timer and stamina
        this.gameTimer.reset();
        this.staminaUI.reset();
        this.staminaUI.show();
    }
    
    update(deltaTime) {
        // Check if game is paused
        const isPaused = this.inputHandler.isPausedState();
        
        // Update start screen camera if active
        if (this.startScreen.isStartScreenActive()) {
            this.startScreen.updateCinematicCamera();
        } else if (!isPaused) {
            // Handle input only when game is active and not paused
            const movementDirection = this.inputHandler.getMovementDirection();
            const wantsSprint = this.inputHandler.isSprinting();
            const sheepdog = this.gameState.getSheepdog();
            
            // Update sheepdog's awareness of nearby sheep for barking
            sheepdog.updateNearSheepStatus(this.gameState.getSheep());
            
            // Always call move to update position, stamina, and animations
            sheepdog.move(movementDirection, this.gameState.getBounds(), deltaTime, wantsSprint);
            
            // Start timer on first actual movement
            if (movementDirection.magnitude() > 0 && !this.gameTimer.isRunning()) {
                this.gameTimer.start();
            }
            
            // Update camera to follow sheepdog
            this.sceneManager.updateCamera(sheepdog);
        }
        
        // Update timer (respects pause state internally)
        this.gameTimer.update();
        
        // Update sheep behaviors (only if not paused)
        if (!isPaused) {
            this.gameState.updateSheepBehaviors(deltaTime);
        }
        
        // Update UI (only when game is active and not paused)
        if (!isPaused) {
            this.gameState.updateUI();
            
            // Update stamina UI if game is active
            if (!this.startScreen.isStartScreenActive()) {
                const sheepdog = this.gameState.getSheepdog();
                if (sheepdog) {
                    this.staminaUI.update(sheepdog.getStaminaInfo());
                }
            }
        }
        
        // Check for game completion (only when game is active and not paused)
        if (!isPaused && this.gameState.checkCompletion()) {
            const finalTime = this.gameTimer.stop();
            const isNewRecord = this.gameTimer.getBestTime() !== null && 
                               finalTime <= this.gameTimer.getBestTime();
            
            this.gameState.showCompletionMessage(finalTime, isNewRecord);
            
            // Disable mobile controls when game completes
            this.mobileControls.disable();
        }
    }
    
    animate() {
        requestAnimationFrame(() => this.animate());
        
        // Calculate delta time
        const currentTime = performance.now();
        const deltaTime = (currentTime - this.lastTime) / 1000; // Convert to seconds
        this.lastTime = currentTime;
        
        // Check if game is paused
        const isPaused = this.inputHandler.isPausedState();
        
        // Update grass animation (only if not paused)
        if (!isPaused) {
            this.terrainBuilder.updateGrassAnimation();
        }
        
        // Update game logic with deltaTime
        this.update(deltaTime);
        
        // Update performance monitoring (always update for monitoring purposes)
        this.performanceMonitor.updateMetrics(this.gameState, this.sceneManager.getRenderer());
        
        // Render the scene (always render to show pause indicator)
        this.sceneManager.render();
    }
    
    organizeMobileUIContainers() {
        // Wait a moment for mobile controls to be created
        setTimeout(() => {
            // Organize left stack (just joystick) for portrait mode
            // Sprint button stays independent for bottom-right positioning
            const leftStack = document.getElementById('mobile-left-stack');
            const joystick = document.getElementById('mobile-joystick');
            
            if (leftStack && joystick) {
                leftStack.appendChild(joystick);
            }
            
            // Organize right HUD cluster (timer + stamina) for landscape fullscreen
            const hudRight = document.getElementById('mobile-hud-right');
            const combinedUI = document.getElementById('mobile-combined-ui');
            const staminaBar = document.getElementById('stamina-bar');
            
            if (hudRight && combinedUI) {
                hudRight.appendChild(combinedUI);
            }
            if (hudRight && staminaBar) {
                hudRight.appendChild(staminaBar);
            }
        }, 100);
    }
}

// Start simulation when page loads
window.addEventListener('DOMContentLoaded', () => {
    new SheepDogSimulation();
});
```

## client/js/MobileControls.js

```javascript
import { Vector2D } from './Vector2D.js';

/**
 * MobileControls - Handles touch-based input controls for mobile devices
 * Includes virtual joystick for movement and zoom slider for camera control
 */
export class MobileControls {
    constructor(sceneManager, audioManager) {
        this.sceneManager = sceneManager;
        this.audioManager = audioManager;
        this.isTouchDevice = this.detectTouchDevice();
        this.isEnabled = false;
        this.joystick = null;
        this.zoomSlider = null;
        this.movementVector = new Vector2D(0, 0);
        this.isMoving = false;
        this.isSprinting = false;
        this.zoomLevel = 80; // Default camera distance
        this.onZoomChange = null;
        
        // UI elements
        this.joystickContainer = null;
        this.zoomContainer = null;
        this.sprintButton = null;
        this.fullscreenButton = null;
        
        if (this.isTouchDevice) {
            this.createFullscreenButton();
            this.setupFullscreenListeners();
            
            // Add fullscreen change listeners that trigger resize
            if (this.sceneManager) {
                ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'msfullscreenchange']
                    .forEach(evt => document.addEventListener(evt, () => this.sceneManager.onWindowResize()));
            }
            
            this.loadNippleJS().then(() => {
                this.createMobileUI();
                this.setupTouchPrevention();
            });
        }
    }
    
    /**
     * Detect if device supports touch input
     * @returns {boolean} True if touch device detected
     */
    detectTouchDevice() {
        // Multiple detection methods for better accuracy
        const hasTouch = 'ontouchstart' in window || 
                        navigator.maxTouchPoints > 0 || 
                        navigator.msMaxTouchPoints > 0;
        
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        const hasCoarsePointer = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
        
        const isSmallScreen = window.innerWidth <= 768 || window.innerHeight <= 768;
        
        // Device is considered touch-capable if it has touch AND (is mobile OR has coarse pointer OR small screen)
        return hasTouch && (isMobile || hasCoarsePointer || isSmallScreen);
    }
    
    /**
     * Load nipple.js library dynamically
     */
    async loadNippleJS() {
        return new Promise((resolve, reject) => {
            if (window.nipplejs) {
                resolve();
                return;
            }
            
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.2/nipplejs.js';
            script.onload = () => resolve();
            script.onerror = () => reject(new Error('Failed to load nipple.js'));
            document.head.appendChild(script);
        });
    }
    
    /**
     * Create mobile UI elements
     */
    createMobileUI() {
        this.createJoystick();
        this.createZoomSlider();
        this.createSprintButton();
        this.updateMobileInstructions();
    }
    
    /**
     * Create virtual joystick for movement
     */
    createJoystick() {
        // Get safe area insets
        const safeAreaBottom = getComputedStyle(document.documentElement).getPropertyValue('--sab') || 
                              'env(safe-area-inset-bottom, 0px)';
        const safeAreaLeft = 'env(safe-area-inset-left, 0px)';
        
        // Create joystick container
        this.joystickContainer = document.createElement('div');
        this.joystickContainer.id = 'mobile-joystick';
        this.joystickContainer.style.cssText = `
            position: fixed;
            bottom: calc(20px + ${safeAreaBottom});
            left: calc(20px + ${safeAreaLeft});
            width: 120px;
            height: 120px;
            z-index: 1001;
            display: none;
            pointer-events: auto;
        `;
        document.body.appendChild(this.joystickContainer);
        
        // Initialize nipple.js joystick
        if (window.nipplejs) {
            this.joystick = window.nipplejs.create({
                zone: this.joystickContainer,
                mode: 'static',
                position: { left: '50%', top: '50%' },
                color: '#00BFFF',
                size: 120,
                threshold: 0.1,
                fadeTime: 250,
                restOpacity: 0.7
            });
            
            // Handle joystick events
            this.joystick.on('start', () => {
                this.isMoving = true;
            });
            
            this.joystick.on('move', (evt, data) => {
                if (data.vector) {
                    // Convert joystick vector to movement vector
                    // Nipple.js uses screen coordinates, we need game coordinates
                    this.movementVector.x = -data.vector.x; // Invert X for correct direction
                    this.movementVector.z = data.vector.y;  // Y becomes Z in 3D space
                    this.isMoving = true;
                }
            });
            
            this.joystick.on('end', () => {
                this.movementVector.x = 0;
                this.movementVector.z = 0;
                this.isMoving = false;
            });
        }
    }
    
    /**
     * Create zoom slider for camera control
     */
    createZoomSlider() {
        // Get safe area insets
        const safeAreaBottom = getComputedStyle(document.documentElement).getPropertyValue('--sab') || 
                              'env(safe-area-inset-bottom, 0px)';
        const safeAreaRight = 'env(safe-area-inset-right, 0px)';
        
        this.zoomContainer = document.createElement('div');
        this.zoomContainer.id = 'mobile-zoom';
        this.zoomContainer.style.cssText = `
            position: fixed;
            bottom: calc(20px + ${safeAreaBottom});
            right: calc(20px + ${safeAreaRight});
            width: 40px;
            height: 200px;
            z-index: 1001;
            display: none;
            pointer-events: auto;
        `;
        
        // Create slider
        this.zoomSlider = document.createElement('input');
        this.zoomSlider.type = 'range';
        this.zoomSlider.min = '20';
        this.zoomSlider.max = '150';
        this.zoomSlider.value = '80';
        this.zoomSlider.orient = 'vertical';
        this.zoomSlider.style.cssText = `
            width: 200px;
            height: 40px;
            transform: rotate(-90deg) translateX(-80px);
            transform-origin: 20px 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        `;
        
        // Style the slider track and thumb
        const style = document.createElement('style');
        style.textContent = `
            #mobile-zoom input[type="range"]::-webkit-slider-track {
                height: 8px;
                background: #ddd;
                border-radius: 4px;
                border: 1px solid #00BFFF;
            }
            
            #mobile-zoom input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                height: 20px;
                width: 20px;
                border-radius: 50%;
                background: #00BFFF;
                cursor: pointer;
                border: 2px solid white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
            
            #mobile-zoom input[type="range"]::-moz-range-track {
                height: 8px;
                background: #ddd;
                border-radius: 4px;
                border: 1px solid #00BFFF;
            }
            
            #mobile-zoom input[type="range"]::-moz-range-thumb {
                height: 20px;
                width: 20px;
                border-radius: 50%;
                background: #00BFFF;
                cursor: pointer;
                border: 2px solid white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        `;
        document.head.appendChild(style);
        
        // Add zoom labels - REMOVED
        // const zoomLabel = document.createElement('div');
        // zoomLabel.textContent = 'Zoom';
        // zoomLabel.style.cssText = `
        //     position: absolute;
        //     top: -25px;
        //     left: 50%;
        //     transform: translateX(-50%);
        //     font-size: 12px;
        //     color: white;
        //     background: rgba(0, 0, 0, 0.7);
        //     padding: 2px 6px;
        //     border-radius: 4px;
        //     font-family: Arial, sans-serif;
        //     font-weight: bold;
        // `;
        
        // this.zoomContainer.appendChild(zoomLabel);
        this.zoomContainer.appendChild(this.zoomSlider);
        document.body.appendChild(this.zoomContainer);
        
        // Handle zoom changes
        this.zoomSlider.addEventListener('input', (e) => {
            this.zoomLevel = parseInt(e.target.value);
            if (this.onZoomChange) {
                this.onZoomChange(this.zoomLevel);
            }
        });
    }
    
    /**
     * Create sprint button
     */
    createSprintButton() {
        // Get safe area insets
        const safeAreaBottom = getComputedStyle(document.documentElement).getPropertyValue('--sab') || 
                              'env(safe-area-inset-bottom, 0px)';
        const safeAreaLeft = 'env(safe-area-inset-left, 0px)';
        
        this.sprintButton = document.createElement('button');
        this.sprintButton.id = 'mobile-sprint';
        this.sprintButton.textContent = '🏃';
        this.sprintButton.style.cssText = `
            position: fixed;
            bottom: calc(20px + ${safeAreaBottom});
            left: calc(160px + ${safeAreaLeft});
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 191, 255, 0.8);
            border: 3px solid white;
            color: white;
            font-size: 24px;
            z-index: 1001;
            display: none;
            pointer-events: auto;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        `;
        
        // Handle sprint button events
        this.sprintButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.isSprinting = true;
            this.sprintButton.style.background = 'rgba(255, 107, 53, 0.9)';
            this.sprintButton.style.transform = 'scale(0.95)';
        });
        
        this.sprintButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.isSprinting = false;
            this.sprintButton.style.background = 'rgba(0, 191, 255, 0.8)';
            this.sprintButton.style.transform = 'scale(1)';
        });
        
        // Prevent context menu
        this.sprintButton.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        document.body.appendChild(this.sprintButton);
    }
    
    /**
     * Update instructions for mobile devices
     */
    updateMobileInstructions() {
        const instructions = document.getElementById('instructions');
        if (instructions && this.isTouchDevice) {
            // Hide the instructions completely on mobile
            instructions.style.display = 'none';
        }
    }
    
    /**
     * Setup touch event prevention for game canvas
     */
    setupTouchPrevention() {
        const canvas = document.querySelector('canvas');
        if (canvas) {
            // Prevent default touch behaviors on canvas
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
            }, { passive: false });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });
            
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
            }, { passive: false });
        }
        
        // Prevent zoom on double tap
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // Prevent zoom on pinch
        document.addEventListener('gesturestart', (e) => {
            e.preventDefault();
        });
    }
    
    /**
     * Enable mobile controls
     */
    enable() {
        if (!this.isTouchDevice) return;
        
        this.isEnabled = true;
        if (this.joystickContainer) this.joystickContainer.style.display = 'block';
        if (this.zoomContainer) this.zoomContainer.style.display = 'block';
        if (this.sprintButton) this.sprintButton.style.display = 'block';
    }
    
    /**
     * Disable mobile controls
     */
    disable() {
        this.isEnabled = false;
        if (this.joystickContainer) this.joystickContainer.style.display = 'none';
        if (this.zoomContainer) this.zoomContainer.style.display = 'none';
        if (this.sprintButton) this.sprintButton.style.display = 'none';
        
        // Reset movement state
        this.movementVector.x = 0;
        this.movementVector.z = 0;
        this.isMoving = false;
        this.isSprinting = false;
    }
    
    /**
     * Get current movement direction
     */
    getMovementDirection() {
        if (!this.isEnabled) return new Vector2D(0, 0);
        return this.movementVector.clone();
    }
    
    /**
     * Check if currently moving
     */
    getIsMoving() {
        return this.isEnabled && this.isMoving;
    }
    
    /**
     * Check if currently sprinting
     */
    getIsSprinting() {
        return this.isEnabled && this.isSprinting;
    }
    
    /**
     * Set zoom change callback
     */
    setZoomChangeCallback(callback) {
        this.onZoomChange = callback;
    }
    
    /**
     * Get current zoom level
     */
    getZoomLevel() {
        return this.zoomLevel;
    }
    
    /**
     * Check if this is a touch device
     */
    getIsTouchDevice() {
        return this.isTouchDevice;
    }
    
    /**
     * Cleanup mobile controls
     */
    destroy() {
        if (this.joystick) {
            this.joystick.destroy();
        }
        
        if (this.joystickContainer) {
            this.joystickContainer.remove();
        }
        
        if (this.zoomContainer) {
            this.zoomContainer.remove();
        }
        
        if (this.sprintButton) {
            this.sprintButton.remove();
        }
    }
    
    /**
     * Check if fullscreen API is supported
     */
    isFullscreenSupported() {
        const element = document.documentElement;
        return !!(
            element.requestFullscreen ||
            element.webkitRequestFullscreen ||
            element.webkitRequestFullScreen ||
            element.mozRequestFullScreen ||
            element.msRequestFullscreen
        );
    }
    
    /**
     * Create fullscreen button for mobile devices
     */
    createFullscreenButton() {
        // Only show on mobile devices that support fullscreen
        if (!this.isTouchDevice || !this.isFullscreenSupported()) return;
        
        // Don't create if already exists or if already in fullscreen
        if (this.fullscreenButton || this.isFullscreen()) return;
        
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.id = 'mobile-fullscreen';
        this.fullscreenButton.innerHTML = '📱<br><span style="font-size: 14px;">Play Fullscreen</span>';
        this.fullscreenButton.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 160px;
            height: 80px;
            border-radius: 12px;
            background: rgba(0, 191, 255, 0.95);
            border: 3px solid white;
            color: white;
            font-size: 24px;
            font-weight: bold;
            z-index: 2000;
            display: block;
            pointer-events: auto;
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
            transition: all 0.3s ease;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            font-family: Arial, sans-serif;
            text-align: center;
            line-height: 1.2;
            cursor: pointer;
        `;
        
        // Add hover/active effects
        this.fullscreenButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.fullscreenButton.style.transform = 'translate(-50%, -50%) scale(0.95)';
            this.fullscreenButton.style.background = 'rgba(0, 150, 200, 0.95)';
        });
        
        this.fullscreenButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.fullscreenButton.style.transform = 'translate(-50%, -50%) scale(1)';
            this.fullscreenButton.style.background = 'rgba(0, 191, 255, 0.95)';
            
            // Request fullscreen
            this.requestFullscreen();
        });
        
        // Fallback click event for devices that might not support touch events properly
        this.fullscreenButton.addEventListener('click', (e) => {
            e.preventDefault();
            this.requestFullscreen();
        });
        
        // Prevent context menu
        this.fullscreenButton.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        document.body.appendChild(this.fullscreenButton);
    }
    
    /**
     * Request fullscreen with cross-browser compatibility
     */
    requestFullscreen() {
        const element = document.documentElement;
        
        try {
            let fullscreenPromise = null;
            
            // Check for different fullscreen API methods
            if (element.requestFullscreen) {
                fullscreenPromise = element.requestFullscreen();
            } else if (element.webkitRequestFullscreen) {
                // Safari
                fullscreenPromise = element.webkitRequestFullscreen();
            } else if (element.webkitRequestFullScreen) {
                // Older Safari
                fullscreenPromise = element.webkitRequestFullScreen();
            } else if (element.mozRequestFullScreen) {
                // Firefox
                fullscreenPromise = element.mozRequestFullScreen();
            } else if (element.msRequestFullscreen) {
                // IE/Edge
                fullscreenPromise = element.msRequestFullscreen();
            } else {
                console.warn('Fullscreen API not supported on this device');
                // Hide button anyway since user tried to use it
                this.hideFullscreenButton();
                return;
            }
            
            // Handle the fullscreen promise
            if (fullscreenPromise && fullscreenPromise.then) {
                fullscreenPromise.then(() => {
                    /* 1. Force a layout pass for the new viewport and update controls layout */
                    setTimeout(() => {
                        window.dispatchEvent(new Event('resize'));
                        this.updateFullscreenLayout(); // Ensure layout is updated after resize
                    }, 50);
                    
                    /* 2. If start-screen is still active, scroll it back in view */
                    if (document.getElementById('start-screen')) {
                        document.getElementById('start-screen').scrollIntoView({block:'center'});
                    }
                    
                    /* 3. Guarantee AudioContext is resumed */
                    if (this.audioManager && this.audioManager.listener && this.audioManager.listener.context && 
                        this.audioManager.listener.context.state === 'suspended') {
                        this.audioManager.listener.context.resume().catch(() => {});
                    }
                });
            }
            
            // Hide the fullscreen button after requesting fullscreen
            this.hideFullscreenButton();
            
        } catch (error) {
            console.warn('Failed to request fullscreen:', error);
            // Hide button if fullscreen fails
            this.hideFullscreenButton();
        }
    }
    
    /**
     * Hide the fullscreen button
     */
    hideFullscreenButton() {
        if (this.fullscreenButton) {
            this.fullscreenButton.style.opacity = '0';
            this.fullscreenButton.style.pointerEvents = 'none';
            setTimeout(() => {
                if (this.fullscreenButton) {
                    this.fullscreenButton.remove();
                    this.fullscreenButton = null;
                }
            }, 300);
        }
    }
    
    /**
     * Check if device is in fullscreen mode
     */
    isFullscreen() {
        return !!(
            document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement
        );
    }
    
    /**
     * Setup fullscreen change event listeners
     */
    setupFullscreenListeners() {
        // Handle fullscreen change events across different browsers
        const handleFullscreenChange = () => {
            if (!this.isFullscreen() && this.isTouchDevice) {
                // User exited fullscreen, show button again
                setTimeout(() => {
                    this.createFullscreenButton();
                }, 500); // Small delay to avoid flickering
            }
            
            // Update mobile UI positioning for fullscreen
            this.updateFullscreenLayout();
        };
        
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('msfullscreenchange', handleFullscreenChange);
    }
    
    /**
     * Update mobile UI layout for fullscreen mode
     */
    updateFullscreenLayout() {
        if (!this.isTouchDevice) return;
        
        const isFullscreen = this.isFullscreen();
        const body = document.body;
        
        if (isFullscreen) {
            // Add fullscreen class for CSS targeting
            body.classList.add('mobile-fullscreen');
            
            // In the new container system, individual positioning is handled by CSS
            // We only need to ensure elements are not overridden by JS
            
            // Clear any JS-forced positioning for stamina bar in landscape fullscreen
            // Let the CSS container system handle it
            if (window.matchMedia('(orientation: landscape)').matches) {
                const staminaBar = document.getElementById('stamina-bar');
                if (staminaBar) {
                    // Clear JS positioning - let CSS containers handle it
                    staminaBar.style.left = '';
                    staminaBar.style.transform = '';
                    staminaBar.style.right = '';
                    staminaBar.style.bottom = '';
                }
            }
        } else {
            // Remove fullscreen class
            body.classList.remove('mobile-fullscreen');
            
            // Reset any positioning when exiting fullscreen if needed
            // But mostly let CSS handle it
        }
    }
}
```

## client/js/OptimizedSheep.js

```javascript
import * as THREE from 'three';
import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
import { Vector2D } from './Vector2D.js';
import { Boid } from './Boid.js';

/**
 * OptimizedSheep - High-performance sheep system using modern GPU techniques
 * 
 * Features:
 * - Single InstancedMesh for all sheep (1 draw call!)
 * - Merged geometry with vertex colors
 * - GPU-based animation via vertex shader
 * - Efficient per-instance data management
 */

export class OptimizedSheepSystem {
    constructor(scene, sheepCount = 200) {
        this.scene = scene;
        this.sheepCount = sheepCount;
        this.sheep = [];
        this.audioManager = null;
        
        // Create geometry and materials
        this.createMergedGeometry();
        this.createOptimizedMaterial();
        
        // Create instanced mesh
        this.createInstancedMesh();
        
        // Initialize sheep data
        this.initializeSheepData();
    }
    
    /**
     * Create merged sheep geometry with vertex colors
     */
    createMergedGeometry() {
        const geometries = [];
        const colors = [];
        
        // Body - simplified ellipsoid
        const bodyGeometry = new THREE.SphereGeometry(0.8, 12, 8);
        bodyGeometry.scale(1, 0.9, 1.1);
        bodyGeometry.translate(0, 0.7, 0);
        
        // Add white color for body vertices
        const bodyColors = new Float32Array(bodyGeometry.attributes.position.count * 3);
        for (let i = 0; i < bodyColors.length; i += 3) {
            bodyColors[i] = 1;     // R
            bodyColors[i + 1] = 1; // G
            bodyColors[i + 2] = 1; // B
        }
        bodyGeometry.setAttribute('color', new THREE.BufferAttribute(bodyColors, 3));
        
        // Add vertex IDs for body
        const bodyVertexIds = new Float32Array(bodyGeometry.attributes.position.count);
        for (let i = 0; i < bodyVertexIds.length; i++) {
            bodyVertexIds[i] = Math.min(i, 49); // Body vertices: 0-49
        }
        bodyGeometry.setAttribute('vertexId', new THREE.BufferAttribute(bodyVertexIds, 1));
        geometries.push(bodyGeometry);
        
        // Head - smaller sphere merged with body
        const headGeometry = new THREE.SphereGeometry(0.35, 10, 6);
        headGeometry.scale(0.8, 0.9, 1.2);
        headGeometry.translate(0, 0.65, 0.65);
        
        // Add black color for head vertices
        const headColors = new Float32Array(headGeometry.attributes.position.count * 3);
        for (let i = 0; i < headColors.length; i += 3) {
            headColors[i] = 0.16;     // R
            headColors[i + 1] = 0.16; // G
            headColors[i + 2] = 0.16; // B
        }
        headGeometry.setAttribute('color', new THREE.BufferAttribute(headColors, 3));
        
        // Add vertex IDs for head
        const headVertexIds = new Float32Array(headGeometry.attributes.position.count);
        for (let i = 0; i < headVertexIds.length; i++) {
            headVertexIds[i] = 50 + Math.min(i, 49); // Head vertices: 50-99
        }
        headGeometry.setAttribute('vertexId', new THREE.BufferAttribute(headVertexIds, 1));
        geometries.push(headGeometry);
        
        // Create 4 legs as simple cylinders
        const legGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.5, 6);
        const legPositions = [
            { x: -0.25, z: 0.3 },  // front left
            { x: 0.25, z: 0.3 },   // front right
            { x: -0.25, z: -0.3 }, // back left
            { x: 0.25, z: -0.3 }   // back right
        ];
        
        legPositions.forEach((pos, index) => {
            const leg = legGeometry.clone();
            leg.translate(pos.x, 0.25, pos.z);
            
            // Add vertex IDs for animation in shader
            const vertexIds = new Float32Array(leg.attributes.position.count);
            for (let i = 0; i < vertexIds.length; i++) {
                vertexIds[i] = 100 + index * 10; // Leg ID encoding
            }
            leg.setAttribute('vertexId', new THREE.BufferAttribute(vertexIds, 1));
            
            // Black color for legs
            const legColors = new Float32Array(leg.attributes.position.count * 3);
            for (let i = 0; i < legColors.length; i += 3) {
                legColors[i] = 0.16;     // R
                legColors[i + 1] = 0.16; // G
                legColors[i + 2] = 0.16; // B
            }
            leg.setAttribute('color', new THREE.BufferAttribute(legColors, 3));
            
            geometries.push(leg);
        });
        
        // Merge all geometries
        this.mergedGeometry = BufferGeometryUtils.mergeGeometries(geometries);
        
        // Compute bounds for frustum culling
        this.mergedGeometry.computeBoundingBox();
        this.mergedGeometry.computeBoundingSphere();
    }
    
    /**
     * Create optimized material with custom shaders
     */
    createOptimizedMaterial() {
        // Vertex shader with GPU animation
        const vertexShader = `
            // Use built-in color attribute from Three.js
            attribute float vertexId;
            
            // Per-instance attributes
            attribute vec4 instanceData; // x: animPhase, y: speed, z: state, w: uniqueId
            attribute vec4 instanceAnimation; // x: walkCycle, y: bounce, z: direction, w: blinkTimer
            
            uniform float time;
            uniform float globalAnimSpeed;
            
            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            
            // Animation functions
            vec3 animateVertex(vec3 position, float vId) {
                vec3 animated = position;
                
                float animPhase = instanceData.x;
                float speed = instanceData.y;
                float walkCycle = instanceAnimation.x;
                float bounce = instanceAnimation.y;
                
                // Leg animation (vertexId 100-139)
                if (vId >= 100.0 && vId < 140.0) {
                    float legIndex = floor((vId - 100.0) / 10.0); // 0-3
                    float legPhase = legIndex < 2.0 ? 0.0 : 3.14159; // Front/back offset
                    float sidePhase = mod(legIndex, 2.0) * 1.57; // Left/right offset
                    
                    float legTime = time * globalAnimSpeed + animPhase + walkCycle;
                    float legLift = max(0.0, sin(legTime * 3.0 + legPhase + sidePhase)) * bounce * 2.0;
                    
                    animated.y += legLift * speed;
                    
                    // Slight forward/back motion
                    animated.z += sin(legTime * 3.0 + legPhase + sidePhase) * bounce * 0.3 * speed;
                }
                
                // Body bounce (vertexId 0-49)
                if (vId < 50.0) {
                    float bodyTime = time * globalAnimSpeed + animPhase;
                    animated.y += sin(bodyTime * 2.0) * bounce * 0.5 * speed;
                    
                    // Slight wobble
                    animated.x += sin(bodyTime * 2.5) * bounce * 0.1 * speed;
                }
                
                // Head bob (vertexId 50-99)
                if (vId >= 50.0 && vId < 100.0) {
                    float headTime = time * globalAnimSpeed + animPhase + 0.5;
                    animated.y += sin(headTime * 2.0) * bounce * 0.3 * speed;
                    
                    // Look direction
                    float lookAngle = instanceAnimation.z;
                    animated.x += sin(lookAngle) * 0.1;
                    animated.z += cos(lookAngle) * 0.1;
                }
                
                return animated;
            }
            
            void main() {
                // Access vertex color using built-in Three.js attribute
                #ifdef USE_COLOR
                    vColor = color;
                #else
                    vColor = vec3(1.0); // Default to white if no vertex colors
                #endif
                
                vNormal = normalMatrix * normal;
                
                // Animate vertex position
                vec3 animatedPosition = animateVertex(position, vertexId);
                
                // Apply instance transformation with proper matrix multiplication
                vec4 instancePosition = instanceMatrix * vec4(animatedPosition, 1.0);
                
                vec4 mvPosition = modelViewMatrix * instancePosition;
                vViewPosition = -mvPosition.xyz;
                
                gl_Position = projectionMatrix * mvPosition;
            }
        `;
        
        // Fragment shader with simple toon shading
        const fragmentShader = `
            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            
            uniform vec3 fogColor;
            uniform float fogNear;
            uniform float fogFar;
            
            void main() {
                // Simple toon shading
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(vViewPosition);
                
                // Basic lighting
                vec3 lightDir = normalize(vec3(0.3, 1.0, 0.5));
                float NdotL = dot(normal, lightDir);
                
                // Toon shading steps
                float toon = smoothstep(0.0, 0.01, NdotL) * 0.5 + 0.5;
                toon = floor(toon * 3.0) / 3.0;
                
                // Apply vertex color with toon shading
                vec3 finalColor = vColor * toon;
                
                // Apply fog
                float depth = length(vViewPosition);
                float fogFactor = smoothstep(fogNear, fogFar, depth);
                finalColor = mix(finalColor, fogColor, fogFactor);
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;
        
        this.material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms: {
                time: { value: 0 },
                globalAnimSpeed: { value: 1.0 },
                fogColor: { value: new THREE.Color(0x87CEEB) },
                fogNear: { value: 200 },
                fogFar: { value: 600 }
            },
            vertexColors: true,
            fog: false // We handle fog manually in shader
        });
    }
    
    /**
     * Create the instanced mesh with all sheep
     */
    createInstancedMesh() {
        this.instancedMesh = new THREE.InstancedMesh(
            this.mergedGeometry,
            this.material,
            this.sheepCount
        );
        
        // Enable shadows
        this.instancedMesh.castShadow = true;
        this.instancedMesh.receiveShadow = true;
        
        // Create instance attributes for animation data
        const instanceData = new THREE.InstancedBufferAttribute(
            new Float32Array(this.sheepCount * 4), 4
        );
        const instanceAnimation = new THREE.InstancedBufferAttribute(
            new Float32Array(this.sheepCount * 4), 4
        );
        
        this.mergedGeometry.setAttribute('instanceData', instanceData);
        this.mergedGeometry.setAttribute('instanceAnimation', instanceAnimation);
        
        // Add to scene
        this.scene.add(this.instancedMesh);
        
        // Disable frustum culling so sheep never disappear due to bounding sphere issues
        this.instancedMesh.frustumCulled = false;
    }
    
    /**
     * Initialize individual sheep instances
     */
    initializeSheepData() {
        const dummy = new THREE.Object3D();
        const spreadRadius = 30;
        
        for (let i = 0; i < this.sheepCount; i++) {
            // Random position in a cluster
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * spreadRadius;
            const x = -30 + Math.cos(angle) * distance;
            const z = -30 + Math.sin(angle) * distance;
            
            // Create sheep instance data
            const sheep = new OptimizedSheepInstance(i, x, z);
            this.sheep.push(sheep);
            
            // Set initial transform
            dummy.position.set(x, 0, z);
            dummy.rotation.y = Math.random() * Math.PI * 2;
            dummy.updateMatrix();
            this.instancedMesh.setMatrixAt(i, dummy.matrix);
            
            // Set initial animation data
            this.updateInstanceAttributes(i, sheep);
        }
        
        this.instancedMesh.instanceMatrix.needsUpdate = true;
    }
    
    /**
     * Update instance attributes for a specific sheep
     */
    updateInstanceAttributes(index, sheep) {
        const instanceData = this.mergedGeometry.attributes.instanceData;
        const instanceAnimation = this.mergedGeometry.attributes.instanceAnimation;
        
        if (!instanceData || !instanceAnimation) return;
        
        // Instance data: animPhase, speed, state, uniqueId
        instanceData.setXYZW(
            index,
            sheep.animationPhase,
            sheep.currentSpeed,
            sheep.state, // 0: active, 1: retiring, 2: retired
            index
        );
        
        // Animation data: walkCycle, bounce, direction, blinkTimer
        instanceAnimation.setXYZW(
            index,
            sheep.walkCycle,
            sheep.bounceAmount,
            sheep.facingDirection,
            sheep.blinkTimer
        );
        
        instanceData.needsUpdate = true;
        instanceAnimation.needsUpdate = true;
    }
    
    /**
     * Update all sheep behaviors and animations
     */
    update(deltaTime, sheepdog, gate, pasture, bounds, params) {
        const dummy = new THREE.Object3D();
        
        // Update time uniform
        this.material.uniforms.time.value += deltaTime;
        
        // Ensure instance matrix is available
        if (!this.instancedMesh.instanceMatrix) {
            console.warn('Instance matrix not available');
            return;
        }
        
        // Track sheep being chased for group audio
        let sheepBeingChased = 0;
        let shouldPlayGroupBleat = false;
        
        // Update each sheep
        for (let i = 0; i < this.sheepCount; i++) {
            const sheep = this.sheep[i];
            
            // Check if this sheep is being chased (before updating behavior)
            if (sheepdog && sheep.position) {
                const distanceToSheepdog = sheep.position.distanceTo(sheepdog.position);
                const isBeingChased = distanceToSheepdog < sheep.fleeRadius;
                
                if (isBeingChased && !sheep.wasBeingChased) {
                    sheepBeingChased++;
                    shouldPlayGroupBleat = true;
                }
            }
            
            // Update behavior (flocking, movement, etc.)
            sheep.updateBehavior(this.sheep, sheepdog, gate, pasture, bounds, params, false); // Pass false to disable individual bleating
            sheep.updatePosition(deltaTime);
            
            // Update transform matrix using interpolated render position for smooth movement
            dummy.position.set(sheep.renderPosition.x, 0, sheep.renderPosition.z);
            dummy.rotation.y = -sheep.renderFacingDirection + Math.PI / 2;
            
            // Keep all sheep visible - no hiding for grazing sheep
            dummy.scale.set(1, 1, 1);
            
            dummy.updateMatrix();

            // Defensive check for NaN/Infinity in the dummy matrix before setting instanceMatrix
            let matrixIsValid = true;
            for (let j = 0; j < 16; j++) {
                if (isNaN(dummy.matrix.elements[j]) || !isFinite(dummy.matrix.elements[j])) {
                    matrixIsValid = false;
                    break;
                }
            }

            if (matrixIsValid) {
                this.instancedMesh.setMatrixAt(i, dummy.matrix);
            } else {
                console.warn(`Sheep ${sheep.id} produced invalid matrix. Skipping update for this instance.`);
                // Optionally, set to an identity matrix or last known good matrix for this instance
                // For now, we just skip, which means it won't update its visual position/rotation
                // which might make it appear stuck, but it's better than a crash or full invisibility.
            }
            
            // Update animation attributes
            this.updateInstanceAttributes(i, sheep);
        }
        
        // Play group bleat if multiple sheep started being chased this frame
        if (shouldPlayGroupBleat && sheepBeingChased > 0 && this.audioManager) {
            if (sheepBeingChased === 1) {
                this.audioManager.playSheepBleat(); // Single bleat for one sheep
            } else {
                this.audioManager.playGroupSheepBleats(sheepBeingChased); // Layered bleats for multiple sheep
            }
        }
        
        this.instancedMesh.instanceMatrix.needsUpdate = true;
    }
    
    /**
     * Get all sheep instances
     */
    getSheep() {
        return this.sheep;
    }
    
    /**
     * Set audio manager for sound effects
     */
    setAudioManager(audioManager) {
        this.audioManager = audioManager;
        // Pass audio manager to all sheep instances
        this.sheep.forEach(sheep => {
            sheep.setAudioManager(audioManager);
        });
    }
    
    /**
     * Reset all sheep to their starting positions and states
     */
    resetAllSheep() {
        const dummy = new THREE.Object3D();
        const spreadRadius = 30;
        
        for (let i = 0; i < this.sheepCount; i++) {
            const sheep = this.sheep[i];
            
            // Reset position to starting area
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * spreadRadius;
            const x = -30 + Math.cos(angle) * distance;
            const z = -30 + Math.sin(angle) * distance;
            
            // Reset sheep state - now using the set method
            sheep.position.set(x, z);
            sheep.velocity.set(0, 0);
            sheep.acceleration.set(0, 0);
            sheep.hasPassedGate = false;
            sheep.isRetiring = false;
            sheep.retirementTarget = null;
            sheep.state = 0; // Active state
            sheep.maxSpeed = 0.1;
            sheep.maxForce = 0.02;
            
            // Reset animation properties
            sheep.animationPhase = Math.random() * Math.PI * 2;
            sheep.walkCycle = 0;
            sheep.bounceAmount = 0;
            sheep.currentSpeed = 0;
            sheep.facingDirection = Math.random() * Math.PI * 2;
            sheep.blinkTimer = Math.random() * 5;
            
            // Reset interpolated render position to match physics position
            sheep.renderPosition.set(x, z);
            sheep.renderFacingDirection = sheep.facingDirection;
            
            // Update transform matrix
            dummy.position.set(x, 0, z);
            dummy.rotation.y = sheep.facingDirection;
            dummy.scale.set(1, 1, 1);
            dummy.updateMatrix();
            this.instancedMesh.setMatrixAt(i, dummy.matrix);
            
            // Update animation attributes
            this.updateInstanceAttributes(i, sheep);
        }
        
        this.instancedMesh.instanceMatrix.needsUpdate = true;
    }
}

/**
 * Individual sheep instance data
 */
export class OptimizedSheepInstance extends Boid {
    constructor(id, x, z) {
        super(x, z, {
            maxSpeed: 0.1,
            maxForce: 0.02,
            perceptionRadius: 5
        });
        
        this.id = id;
        this.state = 0; // 0: active, 1: retiring, 2: retired
        
        // Animation properties
        this.animationPhase = Math.random() * Math.PI * 2;
        this.walkCycle = 0;
        this.bounceAmount = 0;
        this.currentSpeed = 0;
        this.facingDirection = 0;
        this.blinkTimer = Math.random() * 5;
        
        // Interpolation properties for smooth visual movement
        this.renderPosition = new Vector2D(x, z); // Smoothed position for rendering
        this.renderFacingDirection = 0; // Smoothed facing direction for rendering
        this.interpolationSpeed = 8.0; // How fast to interpolate (higher = faster catch-up)
        this.rotationInterpolationSpeed = 12.0; // Faster rotation interpolation
        
        // Behavior properties
        this.hasPassedGate = false;
        this.isRetiring = false;
        this.retirementTarget = null;
        this.fleeRadius = 8;
        this.gateAttraction = 0.5;
        this.audioManager = null;
        
        // Audio tracking
        this.wasBeingChased = false;
    }
    
    updateBehavior(allSheep, sheepdog, gate, pasture, bounds, params, enableIndividualBleating = true) {
        // If retiring, seek retirement target or graze
        if (this.isRetiring) {
            if (this.retirementTarget) {
                const distanceToTarget = this.position.distanceTo(this.retirementTarget);
                
                if (distanceToTarget < 2) {
                    // Sheep has reached its retirement spot - enter grazing mode
                    this.retirementTarget = null; // Clear target to enter grazing mode
                    this.maxSpeed = 0.02; // Very slow grazing speed
                    this.maxForce = 0.005; // Gentle forces
                    this.state = 2; // Set to grazing state
                } else {
                    // Still moving to retirement spot
                    const seekForce = this.seek(this.retirementTarget);
                    this.applyForce(seekForce);
                }
            } else {
                // Grazing behavior - gentle wandering
                this.animationPhase += 0.016;
                
                // Occasional gentle movement
                if (Math.random() < 0.002) { // 0.2% chance per frame to start moving
                    const wanderDirection = Vector2D.random();
                    wanderDirection.multiply(0.5); // Gentle movement
                    this.applyForce(wanderDirection);
                }
                
                // Stay within pasture bounds with gentle forces
                if (pasture) {
                    const pastureMargin = 2;
                    const steer = new Vector2D(0, 0);
                    
                    if (this.position.x < pasture.minX + pastureMargin) {
                        steer.x = 0.01;
                    } else if (this.position.x > pasture.maxX - pastureMargin) {
                        steer.x = -0.01;
                    }
                    
                    if (this.position.z < pasture.minZ + pastureMargin) {
                        steer.z = 0.01;
                    } else if (this.position.z > pasture.maxZ - pastureMargin) {
                        steer.z = -0.01;
                    }
                    
                    if (steer.magnitude() > 0) {
                        this.applyForce(steer);
                    }
                }
            }
            return;
        }
        
        // Only check gate passage if gate and pasture are available (game is active)
        if (gate && pasture && this.hasPassedGate && !this.isRetiring) {
            this.isRetiring = true;
            this.state = 1; // retiring
            this.retirementTarget = new Vector2D(
                pasture.minX + Math.random() * (pasture.maxX - pasture.minX),
                pasture.centerZ + Math.random() * 20
            );
            this.maxSpeed *= 0.5;
            this.maxForce *= 0.5;
            return;
        }
        
        // Normal flocking behavior (always active)
        this.flock(allSheep, params.separationDistance);
        
        // Add gentle wandering during pre-game state (when no sheepdog)
        if (!sheepdog) {
            // Gentle wandering to make the start screen more lively
            if (Math.random() < 0.01) { // 1% chance per frame for gentle movement
                const wanderDirection = Vector2D.random();
                wanderDirection.multiply(0.3); // Gentle wandering force
                this.applyForce(wanderDirection);
            }
        }
        
        // Flee from sheepdog (only if sheepdog exists - game is active)
        if (sheepdog) {
            const distanceToSheepdog = this.position.distanceTo(sheepdog.position);
            const isBeingChased = distanceToSheepdog < this.fleeRadius;
            
            const fleeForce = this.flee(sheepdog.position, this.fleeRadius);
            if (fleeForce.magnitude() > 0) {
                fleeForce.multiply(1.2);
                this.applyForce(fleeForce);
                
                // Play bleat sound when sheep starts being chased (only if individual bleating is enabled)
                if (isBeingChased && !this.wasBeingChased && this.audioManager && enableIndividualBleating) {
                    this.audioManager.playSheepBleat();
                }
            }
            
            this.wasBeingChased = isBeingChased;
        } else {
            this.wasBeingChased = false;
        }
        
        // Gate attraction logic (only if sheepdog and gate exist - game is active)
        if (sheepdog && gate) {
            const distanceToGate = this.position.distanceTo(gate.position);
            const distanceToDog = this.position.distanceTo(sheepdog.position);
            
            if (distanceToDog < this.fleeRadius * 1.5 && distanceToGate < 30) {
                const toGate = gate.position.clone().subtract(this.position);
                const toDog = sheepdog.position.clone().subtract(this.position);
                
                const dotProduct = toGate.x * toDog.x + toGate.z * toDog.z;
                if (dotProduct < 0) {
                    const gateForce = this.seek(gate.position);
                    gateForce.multiply(this.gateAttraction);
                    this.applyForce(gateForce);
                }
            }
        }
        
        // Boundary avoidance (always active)
        const boundaryForce = this.avoidBoundariesWithGate(bounds, gate);
        this.applyForce(boundaryForce);
        
        this.maxSpeed = params.speed;
        this.cohesionWeight = params.cohesion;
    }
    
    updatePosition(deltaTime) {
        // Standard Boid update
        super.update(deltaTime); // This updates this.position and this.velocity
        
        // HARD BOUNDARY CONSTRAINT - Apply only to sheep that haven't passed the gate
        if (this.bounds && !this.hasPassedGate) {
            const margin = 0.2; // Small margin from edge
            
            // Check if sheep is in the gate area (allow passage through gate)
            const inGateArea = Math.abs(this.position.x) <= 4 && this.position.z >= 98 && this.position.z <= 102;
            
            // Apply hard constraints unless in gate area
            if (!inGateArea) {
                this.position.x = Math.max(this.bounds.minX + margin, Math.min(this.bounds.maxX - margin, this.position.x));
                this.position.z = Math.max(this.bounds.minZ + margin, Math.min(this.bounds.maxZ - margin, this.position.z));
            } else {
                // In gate area - only constrain X to gate width, allow Z movement
                this.position.x = Math.max(-4, Math.min(4, this.position.x));
                // Don't constrain Z in gate area to allow passage
            }
        }
        
        // NaN/Infinity checks for velocity and position
        if (isNaN(this.velocity.x) || isNaN(this.velocity.z) || !isFinite(this.velocity.x) || !isFinite(this.velocity.z)) {
            console.warn(`Sheep ${this.id} velocity became NaN/Infinity:`, this.velocity.x, this.velocity.z);
            this.velocity.set(0, 0); // Reset velocity
        }
        if (isNaN(this.position.x) || isNaN(this.position.z) || !isFinite(this.position.x) || !isFinite(this.position.z)) {
            console.warn(`Sheep ${this.id} position became NaN/Infinity:`, this.position.x, this.position.z);
            // Attempt to reset to a safe position, e.g., center of field, or last known good position
            this.position.set(0, -30); // Reset to initial-like position
            this.velocity.set(0, 0); // Also reset velocity
        }
        
        // Update animation parameters based on movement
        const speed = this.velocity.magnitude();
        
        if (isNaN(speed) || !isFinite(speed)) {
            console.warn(`Sheep ${this.id} speed became NaN/Infinity.`);
            this.currentSpeed = 0;
            this.bounceAmount = 0;
        } else {
            this.currentSpeed = speed / (this.maxSpeed > 0.00001 ? this.maxSpeed : 0.1); // Avoid division by zero for maxSpeed
            this.bounceAmount = Math.min(speed * 15, 0.15);
        }
        
        this.walkCycle += this.currentSpeed * deltaTime * 10; // Use currentSpeed which is now NaN-checked
        
        if (this.currentSpeed > 0.001) {
            this.facingDirection = Math.atan2(this.velocity.z, this.velocity.x);
            if (isNaN(this.facingDirection) || !isFinite(this.facingDirection)) {
                console.warn(`Sheep ${this.id} facingDirection became NaN/Infinity.`);
                this.facingDirection = 0;
            }
        } else {
             // Keep last facing direction if not moving, or default to 0
            // this.facingDirection = this.facingDirection || 0;
        }
        
        // Update blink timer
        this.blinkTimer += deltaTime;
        if (this.blinkTimer > 3 + Math.random() * 4) {
            this.blinkTimer = 0;
        }
        
        // Interpolate render position for smooth visual movement
        this.updateRenderPosition(deltaTime);
    }
    
    /**
     * Update interpolated render position for smooth visual movement
     */
    updateRenderPosition(deltaTime) {
        // Interpolate position smoothly towards actual physics position
        const positionDiff = this.position.clone().subtract(this.renderPosition);
        const interpolationAmount = Math.min(1.0, this.interpolationSpeed * deltaTime);
        
        // Apply position interpolation
        this.renderPosition.add(positionDiff.multiply(interpolationAmount));
        
        // Interpolate facing direction smoothly
        if (this.currentSpeed > 0.001) {
            // Calculate target facing direction from velocity
            const targetFacing = Math.atan2(this.velocity.z, this.velocity.x);
            
            // Handle angle wrapping for smooth rotation
            let angleDiff = targetFacing - this.renderFacingDirection;
            
            // Normalize angle difference to [-π, π]
            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
            
            // Apply rotation interpolation
            const rotationInterpolationAmount = Math.min(1.0, this.rotationInterpolationSpeed * deltaTime);
            this.renderFacingDirection += angleDiff * rotationInterpolationAmount;
            
            // Normalize final angle
            while (this.renderFacingDirection > Math.PI) this.renderFacingDirection -= 2 * Math.PI;
            while (this.renderFacingDirection < -Math.PI) this.renderFacingDirection += 2 * Math.PI;
        }
    }
    
    // Boundary avoidance that excludes gate area
    avoidBoundariesWithGate(bounds, gate) {
        const margin = 3;
        const steer = new Vector2D(0, 0);
        const position = this.position;
        
        const distToMinX = position.x - bounds.minX;
        const distToMaxX = bounds.maxX - position.x;
        const distToMinZ = position.z - bounds.minZ;
        const distToMaxZ = bounds.maxZ - position.z;
        
        if (distToMinX < margin) {
            const force = (margin - distToMinX) / margin;
            steer.x = this.maxSpeed * force * 1.2;
        } else if (distToMaxX < margin) {
            const force = (margin - distToMaxX) / margin;
            steer.x = -this.maxSpeed * force * 1.2;
        }
        
        if (distToMinZ < margin) {
            const force = (margin - distToMinZ) / margin;
            steer.z = this.maxSpeed * force * 1.2;
        } else if (distToMaxZ < margin) {
            // Only check for gate if gate exists (game is active)
            const nearGateX = gate ? Math.abs(position.x - gate.position.x) < gate.width / 2 + 2 : false;
            if (!nearGateX) {
                const force = (margin - distToMaxZ) / margin;
                steer.z = -this.maxSpeed * force * 1.2;
            }
        }
        
        if (steer.magnitude() > 0) {
            steer.normalize();
            steer.multiply(this.maxSpeed * 1.5);
            steer.subtract(this.velocity);
            steer.limit(this.maxForce * 2.5);
        }
        
        return steer;
    }
    
    checkGatePassageAndRetire(gatePassageZone, pastureBounds) {
        if (this.hasPassedGate) return false;
        
        const inGateX = this.position.x >= gatePassageZone.minX && 
                       this.position.x <= gatePassageZone.maxX;
        const inGateZ = this.position.z >= gatePassageZone.minZ && 
                       this.position.z <= gatePassageZone.maxZ;
        
        if (inGateX && inGateZ && this.velocity.z > 0) {
            this.hasPassedGate = true;
            return true;
        }
        
        return false;
    }
    
    setBounds(bounds) {
        this.bounds = bounds;
    }
    
    setAudioManager(audioManager) {
        this.audioManager = audioManager;
    }
}
```

## client/js/PerformanceMonitor.js

```javascript
/**
 * PerformanceMonitor.js
 * 
 * Comprehensive performance monitoring system for the sheep dog simulation.
 * Integrates Stats.js for real-time FPS/memory tracking and provides
 * custom metrics for simulation-specific performance analysis.
 */

/**
 * Performance monitoring and statistics display
 * Provides real-time FPS, memory usage, and simulation-specific metrics
 */
export class PerformanceMonitor {
    constructor() {
        this.stats = null;
        this.customStats = null;
        this.isEnabled = false;
        this.frameCount = 0;
        this.lastFrameTime = performance.now();
        this.frameTimeHistory = [];
        this.maxHistoryLength = 60; // Keep 1 second of frame times at 60fps
        
        // Performance metrics
        this.metrics = {
            sheepCount: 0,
            activeSheepCount: 0,
            grassInstances: 0,
            drawCalls: 0,
            triangles: 0,
            avgFrameTime: 0,
            minFrameTime: Infinity,
            maxFrameTime: 0,
            geometries: 0,
            textures: 0,
            programs: 0
        };
        
        this.init();
    }
    
    /**
     * Initialize Stats.js and custom performance displays
     */
    async init() {
        try {
            // Try to load Stats.js from CDN using a script tag
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js';
            
            await new Promise((resolve, reject) => {
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
            
            // Wait a bit for Stats to be available globally
            await new Promise(resolve => setTimeout(resolve, 100));
            
            if (typeof Stats !== 'undefined') {
                // Create main Stats.js instance for FPS
                this.stats = new Stats();
                this.stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
                this.stats.dom.style.position = 'absolute';
                this.stats.dom.style.left = '20px';
                this.stats.dom.style.top = '120px';
                this.stats.dom.style.zIndex = '100';
                
                // Create custom stats panel for simulation metrics
                this.createCustomStatsPanel();
                
                // Add to DOM but hide by default
                document.body.appendChild(this.stats.dom);
                document.body.appendChild(this.customStats);
                
                // Hide stats by default
                this.stats.dom.style.display = 'none';
                this.customStats.style.display = 'none';
                
                this.isEnabled = true;
                console.log('PerformanceMonitor: Stats.js integration successful');
            } else {
                throw new Error('Stats.js not available');
            }
            
        } catch (error) {
            console.warn('PerformanceMonitor: Failed to load Stats.js, using fallback metrics', error);
            this.createFallbackDisplay();
        }
    }
    
    /**
     * Create custom statistics panel for simulation-specific metrics
     */
    createCustomStatsPanel() {
        this.customStats = document.createElement('div');
        this.customStats.style.cssText = `
            position: absolute;
            left: 20px;
            top: 200px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 8px;
            border-radius: 4px;
            z-index: 100;
            min-width: 180px;
            line-height: 1.4;
        `;
        
        this.updateCustomStats();
    }
    
    /**
     * Create fallback display when Stats.js fails to load
     */
    createFallbackDisplay() {
        this.customStats = document.createElement('div');
        this.customStats.style.cssText = `
            position: absolute;
            left: 20px;
            top: 120px;
            background: rgba(0, 0, 0, 0.8);
            color: #ffff00;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 8px;
            border-radius: 4px;
            z-index: 100;
            min-width: 200px;
            line-height: 1.4;
        `;
        
        document.body.appendChild(this.customStats);
        
        // Hide stats by default
        this.customStats.style.display = 'none';
        
        this.isEnabled = true;
    }
    
    /**
     * Update performance metrics
     * @param {Object} gameState - Current game state
     * @param {Object} renderer - Three.js renderer
     */
    updateMetrics(gameState, renderer) {
        if (!this.isEnabled) return;
        
        const currentTime = performance.now();
        const frameTime = currentTime - this.lastFrameTime;
        this.lastFrameTime = currentTime;
        
        // Update frame time statistics
        this.frameTimeHistory.push(frameTime);
        if (this.frameTimeHistory.length > this.maxHistoryLength) {
            this.frameTimeHistory.shift();
        }
        
        // Calculate frame time metrics
        this.metrics.avgFrameTime = this.frameTimeHistory.reduce((a, b) => a + b, 0) / this.frameTimeHistory.length;
        this.metrics.minFrameTime = Math.min(this.metrics.minFrameTime, frameTime);
        this.metrics.maxFrameTime = Math.max(this.metrics.maxFrameTime, frameTime);
        
        // Update simulation metrics
        if (gameState) {
            const sheep = gameState.getSheep();
            this.metrics.sheepCount = sheep ? sheep.length : 0;
            // Count sheep that haven't passed the gate and aren't retiring (active sheep)
            this.metrics.activeSheepCount = sheep ? sheep.filter(s => !s.hasPassedGate && !s.isRetiring).length : 0;
        }
        
        // Update renderer metrics
        if (renderer && renderer.info) {
            this.metrics.drawCalls = renderer.info.render.calls;
            this.metrics.triangles = renderer.info.render.triangles;
            this.metrics.geometries = renderer.info.memory.geometries;
            this.metrics.textures = renderer.info.memory.textures;
            this.metrics.programs = renderer.info.programs ? renderer.info.programs.length : 0;
        }
        
        this.frameCount++;
        
        // Update displays
        if (this.stats) {
            this.stats.update();
        }
        
        // Update custom stats every 10 frames to reduce overhead
        if (this.frameCount % 10 === 0) {
            this.updateCustomStats();
        }
    }
    
    /**
     * Update custom statistics display
     */
    updateCustomStats() {
        if (!this.customStats) return;
        
        const fps = this.frameTimeHistory.length > 0 ? 
            (1000 / this.metrics.avgFrameTime).toFixed(1) : '0';
        
        const memoryInfo = this.getMemoryInfo();
        
        // Color-code FPS for performance indication
        const fpsColor = parseFloat(fps) >= 58 ? '#00ff00' : parseFloat(fps) >= 45 ? '#ffff00' : '#ff4444';
        
        this.customStats.innerHTML = `
            <div style="color: #00ff00; font-weight: bold; margin-bottom: 4px;">SIMULATION STATS</div>
            <div>Sheep Total: ${this.metrics.sheepCount}</div>
            <div>Sheep Active: ${this.metrics.activeSheepCount}</div>
            <div>Grass Instances: ${this.metrics.grassInstances.toLocaleString()}</div>
            <div style="margin-top: 4px; color: #ffff00;">RENDER STATS</div>
            <div>Draw Calls: ${this.metrics.drawCalls}</div>
            <div>Triangles: ${this.metrics.triangles.toLocaleString()}</div>
            <div>Geometries: ${this.metrics.geometries}</div>
            <div>Textures: ${this.metrics.textures}</div>
            <div>Programs: ${this.metrics.programs}</div>
            <div style="margin-top: 4px; color: #ff8800;">FRAME STATS</div>
            <div style="color: ${fpsColor};">Avg FPS: ${fps}</div>
            <div>Frame Time: ${this.metrics.avgFrameTime.toFixed(2)}ms</div>
            <div>Min/Max: ${this.metrics.minFrameTime.toFixed(1)}/${this.metrics.maxFrameTime.toFixed(1)}ms</div>
            ${memoryInfo}
        `;
    }
    
    /**
     * Get memory information if available
     */
    getMemoryInfo() {
        if (performance.memory) {
            const used = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
            const total = (performance.memory.totalJSHeapSize / 1048576).toFixed(1);
            return `
                <div style="margin-top: 4px; color: #ff4444;">MEMORY</div>
                <div>Used: ${used} MB</div>
                <div>Total: ${total} MB</div>
            `;
        }
        return '';
    }
    
    /**
     * Set grass instance count for display
     * @param {number} count - Number of grass instances
     */
    setGrassInstanceCount(count) {
        this.metrics.grassInstances = count;
    }
    
    /**
     * Toggle performance monitor visibility
     */
    toggle() {
        if (!this.isEnabled) return;
        
        const isVisible = this.stats ? this.stats.dom.style.display !== 'none' : 
                         this.customStats.style.display !== 'none';
        
        if (this.stats) {
            this.stats.dom.style.display = isVisible ? 'none' : 'block';
        }
        if (this.customStats) {
            this.customStats.style.display = isVisible ? 'none' : 'block';
        }
    }
    
    /**
     * Show performance monitor
     */
    show() {
        if (!this.isEnabled) return;
        
        if (this.stats) {
            this.stats.dom.style.display = 'block';
        }
        if (this.customStats) {
            this.customStats.style.display = 'block';
        }
    }
    
    /**
     * Hide performance monitor
     */
    hide() {
        if (!this.isEnabled) return;
        
        if (this.stats) {
            this.stats.dom.style.display = 'none';
        }
        if (this.customStats) {
            this.customStats.style.display = 'none';
        }
    }
    
    /**
     * Reset performance statistics
     */
    reset() {
        this.frameTimeHistory = [];
        this.metrics.minFrameTime = Infinity;
        this.metrics.maxFrameTime = 0;
        this.frameCount = 0;
    }
    
    /**
     * Get current performance metrics
     * @returns {Object} Current metrics object
     */
    getMetrics() {
        return { ...this.metrics };
    }
    
    /**
     * Check if performance monitor is enabled
     * @returns {boolean} True if enabled
     */
    isActive() {
        return this.isEnabled;
    }
    
    /**
     * Get performance recommendations based on current metrics
     * @returns {Array} Array of performance recommendations
     */
    getPerformanceRecommendations() {
        const recommendations = [];
        const avgFps = this.frameTimeHistory.length > 0 ? 
            (1000 / this.metrics.avgFrameTime) : 0;
        
        if (avgFps < 45) {
            recommendations.push("Low FPS detected. Consider reducing grass instances or shadow quality.");
        }
        
        if (this.metrics.drawCalls > 50) {
            recommendations.push("High draw call count. Consider using more instanced rendering.");
        }
        
        if (this.metrics.triangles > 2000000) {
            recommendations.push("High triangle count. Consider using LOD (Level of Detail) systems.");
        }
        
        if (this.metrics.grassInstances > 500000 && avgFps < 60) {
            recommendations.push("Grass instance count may be too high for current hardware.");
        }
        
        return recommendations;
    }
    
    /**
     * Log performance summary to console
     */
    logPerformanceSummary() {
        if (!this.isEnabled) return;
        
        const avgFps = this.frameTimeHistory.length > 0 ? 
            (1000 / this.metrics.avgFrameTime).toFixed(1) : '0';
        
        console.group('🔍 Performance Summary');
        console.log(`📊 Average FPS: ${avgFps}`);
        console.log(`🐑 Active Sheep: ${this.metrics.activeSheepCount}/${this.metrics.sheepCount}`);
        console.log(`🌱 Grass Instances: ${this.metrics.grassInstances.toLocaleString()}`);
        console.log(`🎨 Draw Calls: ${this.metrics.drawCalls}`);
        console.log(`📐 Triangles: ${this.metrics.triangles.toLocaleString()}`);
        console.log(`⏱️ Frame Time: ${this.metrics.avgFrameTime.toFixed(2)}ms`);
        
        const recommendations = this.getPerformanceRecommendations();
        if (recommendations.length > 0) {
            console.group('💡 Recommendations');
            recommendations.forEach(rec => console.log(`• ${rec}`));
            console.groupEnd();
        }
        
        console.groupEnd();
    }
}
```

## client/js/SceneManager.js

```javascript
import * as THREE from 'three';

/**
 * SceneManager - Handles Three.js scene setup, lighting, and camera management
 * Enhanced with mobile zoom control support
 */
export class SceneManager {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(
            75, 
            window.innerWidth / window.innerHeight, 
            0.1, 
            1000
        );
        
        this.renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance", // Use discrete GPU if available
            stencil: false // Disable stencil buffer if not needed
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        // Performance optimizations
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        
        // Enable frustum culling and other optimizations
        this.renderer.sortObjects = true;
        this.renderer.autoClear = true;
        
        document.getElementById('canvas-container').appendChild(this.renderer.domElement);
        
        // Camera control
        this.cameraDistance = 80;
        this.minCameraDistance = 20;
        this.maxCameraDistance = 150;
        this.mobileControls = null;
        
        this.init();
    }
    
    init() {
        // Set scene background
        this.scene.background = new THREE.Color(0x87CEEB); // Sky blue
        this.scene.fog = new THREE.Fog(0x87CEEB, 200, 600); // Extended fog for larger world
        
        // Setup camera - adjusted for larger field
        this.camera.position.set(0, 60, -60);
        this.camera.lookAt(0, 0, 0);
        
        // Add lighting
        this.setupLighting();
        
        // Handle window resize
        window.addEventListener('resize', () => this.onWindowResize());
    }
    
    setupLighting() {
        // Ambient light - adjusted for new lighting model (multiply by PI for similar appearance)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7 * Math.PI);
        this.scene.add(ambientLight);
        
        // Directional light (sun) - adjusted for new lighting model
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8 * Math.PI);
        directionalLight.position.set(30, 70, 30);
        directionalLight.castShadow = true;
        
        // Shadow configuration - adjusted for larger field
        directionalLight.shadow.camera.left = -120;
        directionalLight.shadow.camera.right = 120;
        directionalLight.shadow.camera.top = 120;
        directionalLight.shadow.camera.bottom = -120;
        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 150;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        
        this.scene.add(directionalLight);
        
        // Add a subtle secondary light for better depth - adjusted for new lighting model
        const secondaryLight = new THREE.DirectionalLight(0xffd4a3, 0.3 * Math.PI);
        secondaryLight.position.set(-50, 40, -50);
        this.scene.add(secondaryLight);
    }
    
    updateCamera(sheepdog) {
        // Update camera to follow sheepdog - adjusted for dynamic zoom
        const cameraOffset = new THREE.Vector3(0, this.cameraDistance, -this.cameraDistance);
        const targetPosition = new THREE.Vector3(
            sheepdog.position.x,
            0,
            sheepdog.position.z
        );
        
        this.camera.position.lerp(targetPosition.clone().add(cameraOffset), 0.05);
        this.camera.lookAt(targetPosition);
    }
    
    // Set mobile controls reference for zoom integration
    setMobileControls(mobileControls) {
        this.mobileControls = mobileControls;
        
        // Set up zoom change callback for mobile controls
        if (mobileControls) {
            mobileControls.setZoomChangeCallback((zoomLevel) => {
                this.cameraDistance = zoomLevel;
            });
        }
    }
    
    setupMouseControls() {
        // Mouse wheel for zoom (desktop only)
        this.renderer.domElement.addEventListener('wheel', (event) => {
            event.preventDefault();
            
            // Only handle mouse wheel if not on mobile device
            if (this.mobileControls && this.mobileControls.getIsTouchDevice()) {
                return;
            }
            
            const zoomSpeed = 5;
            
            if (event.deltaY > 0) {
                // Zoom out
                this.cameraDistance = Math.min(this.maxCameraDistance, this.cameraDistance + zoomSpeed);
            } else {
                // Zoom in
                this.cameraDistance = Math.max(this.minCameraDistance, this.cameraDistance - zoomSpeed);
            }
            
            // Update mobile zoom slider if available
            if (this.mobileControls && this.mobileControls.zoomSlider) {
                this.mobileControls.zoomSlider.value = this.cameraDistance;
                this.mobileControls.zoomLevel = this.cameraDistance;
            }
        });
    }
    
    // Get current camera distance for mobile controls synchronization
    getCameraDistance() {
        return this.cameraDistance;
    }
    
    // Set camera distance (used by mobile controls)
    setCameraDistance(distance) {
        this.cameraDistance = Math.max(this.minCameraDistance, 
                                     Math.min(this.maxCameraDistance, distance));
    }
    
    render() {
        this.renderer.render(this.scene, this.camera);
    }
    
    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    add(object) {
        this.scene.add(object);
    }
    
    getScene() {
        return this.scene;
    }
    
    getCamera() {
        return this.camera;
    }
    
    getRenderer() {
        return this.renderer;
    }
}
```

## client/js/StaminaUI.js

```javascript
/**
 * StaminaUI class - manages the stamina bar display
 */
export class StaminaUI {
    constructor() {
        this.staminaFill = document.getElementById('stamina-fill');
        this.staminaText = document.getElementById('stamina-text');
        this.staminaLabel = document.getElementById('stamina-label');
        
        // Cache DOM elements for performance
        this.elements = {
            fill: this.staminaFill,
            text: this.staminaText,
            label: this.staminaLabel
        };
        
        // Track previous state to avoid unnecessary updates
        this.previousPercentage = 100;
        this.previousState = 'normal';
    }
    
    /**
     * Update the stamina bar based on sheepdog stamina info
     * @param {Object} staminaInfo - Object containing stamina data from sheepdog
     */
    update(staminaInfo) {
        const { percentage, isSprinting, canSprint } = staminaInfo;
        const roundedPercentage = Math.round(percentage);
        
        // Only update if percentage changed to avoid unnecessary DOM manipulation
        if (roundedPercentage !== this.previousPercentage) {
            this.elements.fill.style.width = `${percentage}%`;
            this.elements.text.textContent = `${roundedPercentage}%`;
            this.previousPercentage = roundedPercentage;
        }
        
        // Determine current state for styling
        let currentState = 'normal';
        if (isSprinting) {
            currentState = 'sprinting';
        } else if (percentage <= 10) {
            currentState = 'critical';
        } else if (percentage <= 30) {
            currentState = 'low';
        }
        
        // Update styling only if state changed
        if (currentState !== this.previousState) {
            // Remove all state classes
            this.elements.fill.classList.remove('low', 'critical', 'sprinting');
            
            // Add current state class
            if (currentState !== 'normal') {
                this.elements.fill.classList.add(currentState);
            }
            
            // Update label based on state
            if (isSprinting) {
                this.elements.label.textContent = 'Sprinting!';
                this.elements.label.style.color = '#2196F3';
            } else if (!canSprint) {
                this.elements.label.textContent = 'Stamina (Exhausted)';
                this.elements.label.style.color = '#F44336';
            } else {
                this.elements.label.textContent = 'Stamina';
                this.elements.label.style.color = '#333';
            }
            
            this.previousState = currentState;
        }
    }
    
    /**
     * Show the stamina bar (called when game starts)
     */
    show() {
        const staminaBar = document.getElementById('stamina-bar');
        if (staminaBar) {
            staminaBar.classList.add('visible');
        }
    }
    
    /**
     * Hide the stamina bar (called when game ends or on start screen)
     */
    hide() {
        const staminaBar = document.getElementById('stamina-bar');
        if (staminaBar) {
            staminaBar.classList.remove('visible');
        }
    }
    
    /**
     * Reset stamina bar to full
     */
    reset() {
        this.elements.fill.style.width = '100%';
        this.elements.text.textContent = '100%';
        this.elements.label.textContent = 'Stamina';
        this.elements.label.style.color = '#333';
        this.elements.fill.classList.remove('low', 'critical', 'sprinting');
        this.previousPercentage = 100;
        this.previousState = 'normal';
    }
}
```

## client/js/StartScreen.js

```javascript
import * as THREE from 'three';

/**
 * StartScreen - Manages the start screen overlay and pre-game state
 */
export class StartScreen {
    constructor(sceneManager) {
        this.sceneManager = sceneManager;
        this.isActive = true;
        this.gameStarted = false;
        this.audioManager = null;
        
        // Cinematic camera settings
        this.cinematicCamera = {
            angle: 0,
            radius: 120,
            height: 80,
            speed: 0.05,
            centerX: 0,
            centerZ: 0
        };
        
        // UI elements
        this.startScreenElement = document.getElementById('start-screen');
        this.startButton = document.getElementById('start-button');
        this.gameUIElements = document.querySelectorAll('.game-ui');
        this.musicNote = document.getElementById('music-note');
        
        this.init();
    }
    
    init() {
        // Set up start button event listener
        this.startButton.addEventListener('click', () => {
            this.startGame();
        });
        
        // Set up keyboard listener for Enter key
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Enter' && this.isActive) {
                this.startGame();
            }
        });
        
        // Set up mute button
        this.setupMuteButton();
        
        // Set up music activation
        this.setupMusicActivation();
        
        // Initialize cinematic camera
        this.setupCinematicCamera();
    }
    
    setupCinematicCamera() {
        // Position camera for cinematic view of the field
        const camera = this.sceneManager.getCamera();
        camera.position.set(
            this.cinematicCamera.centerX + this.cinematicCamera.radius,
            this.cinematicCamera.height,
            this.cinematicCamera.centerZ
        );
        camera.lookAt(this.cinematicCamera.centerX, 0, this.cinematicCamera.centerZ);
    }
    
    updateCinematicCamera() {
        if (!this.isActive) return;
        
        // Slowly orbit around the field center
        this.cinematicCamera.angle += this.cinematicCamera.speed * 0.016; // Assuming 60fps
        
        const camera = this.sceneManager.getCamera();
        const x = this.cinematicCamera.centerX + Math.cos(this.cinematicCamera.angle) * this.cinematicCamera.radius;
        const z = this.cinematicCamera.centerZ + Math.sin(this.cinematicCamera.angle) * this.cinematicCamera.radius;
        
        // Smooth camera movement
        const targetPosition = new THREE.Vector3(x, this.cinematicCamera.height, z);
        camera.position.lerp(targetPosition, 0.02);
        
        // Always look at the center of the field
        const lookAtTarget = new THREE.Vector3(this.cinematicCamera.centerX, 0, this.cinematicCamera.centerZ);
        const currentLookAt = new THREE.Vector3();
        camera.getWorldDirection(currentLookAt);
        currentLookAt.multiplyScalar(-1).add(camera.position);
        currentLookAt.lerp(lookAtTarget, 0.02);
        camera.lookAt(currentLookAt);
    }
    
    startGame() {
        if (!this.isActive) return;
        
        // Play UI click sound
        if (this.audioManager) {
            this.audioManager.playUIClick();
            
            // Fade out start music and start gameplay music
            this.audioManager.fadeOutCurrentMusic(800);
            setTimeout(() => {
                this.audioManager.playGameplayMusic();
            }, 900); // Start gameplay music after fade out
        }
        
        this.isActive = false;
        this.gameStarted = true;
        
        // Hide start screen with animation
        this.startScreenElement.style.transition = 'opacity 0.8s ease-out';
        this.startScreenElement.style.opacity = '0';
        
        setTimeout(() => {
            this.startScreenElement.style.display = 'none';
            
            // Show game UI elements
            this.gameUIElements.forEach(element => {
                element.classList.add('visible');
            });
        }, 800);
        
        // Trigger game start callback if set
        if (this.onGameStart) {
            this.onGameStart();
        }
    }
    
    setGameStartCallback(callback) {
        this.onGameStart = callback;
    }
    
    setAudioManager(audioManager) {
        this.audioManager = audioManager;
        
        // Update mute button state
        this.updateMuteButton();
    }
    
    setupMuteButton() {
        this.muteToggle = document.getElementById('mute-toggle');
        if (this.muteToggle) {
            this.muteToggle.addEventListener('click', () => {
                if (this.audioManager) {
                    const isMuted = this.audioManager.toggleMute();
                    this.updateMuteButton();
                }
            });
        }
    }
    
    updateMuteButton() {
        if (!this.muteToggle || !this.audioManager) return;
        
        const isMuted = this.audioManager.isMutedState();
        const icon = isMuted ? '🔇' : '🔊';
        this.muteToggle.innerHTML = `${icon} <strong>Click</strong> - Toggle Sound`;
        this.muteToggle.title = isMuted ? 'Click to unmute sound' : 'Click to mute sound';
        
        if (isMuted) {
            this.muteToggle.classList.add('muted');
        } else {
            this.muteToggle.classList.remove('muted');
        }
    }
    
    setupMusicActivation() {
        // Listen for clicks on the start screen (but not the start button)
        const handleStartScreenClick = (event) => {
            // Don't trigger music if clicking the start button
            if (event.target.id === 'start-button' || event.target.closest('#start-button')) {
                return;
            }
            
            // Trigger music and hide the note
            if (this.audioManager && this.isActive) {
                this.audioManager.triggerStartMusic();
                if (this.musicNote) {
                    this.musicNote.style.display = 'none';
                }
            }
        };
        
        // Add click listener to start screen
        if (this.startScreenElement) {
            this.startScreenElement.addEventListener('click', handleStartScreenClick);
        }
    }
    
    isStartScreenActive() {
        return this.isActive;
    }
    
    hasGameStarted() {
        return this.gameStarted;
    }
    
    reset() {
        this.isActive = true;
        this.gameStarted = false;
        
        // Show start screen
        this.startScreenElement.style.display = 'flex';
        this.startScreenElement.style.opacity = '1';
        this.startScreenElement.style.transition = 'none';
        
        // Hide game UI elements
        this.gameUIElements.forEach(element => {
            element.classList.remove('visible');
        });
        
        // Reset cinematic camera
        this.cinematicCamera.angle = 0;
        this.setupCinematicCamera();
    }
}
```

## client/js/StructureBuilder.js

```javascript
import * as THREE from 'three';

/**
 * StructureBuilder - Handles fences, gates, and pasture structures
 */
export class StructureBuilder {
    constructor(scene) {
        this.scene = scene;
    }
    
    createFieldBoundaryFence(bounds, gate) {
        // Fence post geometry and material
        const postGeometry = new THREE.CylinderGeometry(0.25, 0.25, 3.5, 8);
        const postMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x5a4a3a,
            emissive: 0x1a0a00,
            emissiveIntensity: 0.05
        });
        
        // Rail geometry and material
        const railMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x6a5a4a,
            emissive: 0x1a0a00,
            emissiveIntensity: 0.05
        });
        
        // Fence parameters
        const postSpacing = 10; // Distance between posts
        const postHeight = 3.5;
        const railHeight1 = 1.2; // Lower rail
        const railHeight2 = 2.4; // Upper rail
        
        const fencePosts = [];
        
        // Create fence posts around the perimeter
        // Bottom edge (z = -100)
        for (let x = bounds.minX; x <= bounds.maxX; x += postSpacing) {
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.set(x, postHeight/2, bounds.minZ);
            post.castShadow = true;
            post.receiveShadow = true;
            this.scene.add(post);
            fencePosts.push({x: x, z: bounds.minZ, type: 'bottom'});
        }
        
        // Top edge (z = 100) - connect properly to gate posts
        for (let x = bounds.minX; x <= bounds.maxX; x += postSpacing) {
            // Skip posts that would be too close to gate posts
            const gateLeftPost = gate.position.x - gate.width/2;
            const gateRightPost = gate.position.x + gate.width/2;
            
            if (x < gateLeftPost - 1 || x > gateRightPost + 1) {
                const post = new THREE.Mesh(postGeometry, postMaterial);
                post.position.set(x, postHeight/2, bounds.maxZ);
                post.castShadow = true;
                post.receiveShadow = true;
                this.scene.add(post);
                fencePosts.push({x: x, z: bounds.maxZ, type: 'top'});
            }
        }
        
        // Left edge (x = -100)
        for (let z = bounds.minZ; z <= bounds.maxZ; z += postSpacing) {
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.set(bounds.minX, postHeight/2, z);
            post.castShadow = true;
            post.receiveShadow = true;
            this.scene.add(post);
            fencePosts.push({x: bounds.minX, z: z, type: 'left'});
        }
        
        // Right edge (x = 100)
        for (let z = bounds.minZ; z <= bounds.maxZ; z += postSpacing) {
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.set(bounds.maxX, postHeight/2, z);
            post.castShadow = true;
            post.receiveShadow = true;
            this.scene.add(post);
            fencePosts.push({x: bounds.maxX, z: z, type: 'right'});
        }
        
        // Add horizontal rails between posts
        // Bottom edge rails
        for (let x = bounds.minX; x < bounds.maxX; x += postSpacing) {
            this.createFenceRail(x, bounds.minZ, x + postSpacing, bounds.minZ, railHeight1, railMaterial);
            this.createFenceRail(x, bounds.minZ, x + postSpacing, bounds.minZ, railHeight2, railMaterial);
        }
        
        // Top edge rails - connect to gate posts properly
        const gateLeftPost = gate.position.x - gate.width/2;
        const gateRightPost = gate.position.x + gate.width/2;
        
        for (let x = bounds.minX; x < bounds.maxX; x += postSpacing) {
            const nextX = x + postSpacing;
            
            // Left side of gate - connect to left gate post
            if (nextX <= gateLeftPost + 1) {
                const endX = (nextX > gateLeftPost - 1) ? gateLeftPost : nextX;
                this.createFenceRail(x, bounds.maxZ, endX, bounds.maxZ, railHeight1, railMaterial);
                this.createFenceRail(x, bounds.maxZ, endX, bounds.maxZ, railHeight2, railMaterial);
            }
            
            // Right side of gate - connect from right gate post
            if (x >= gateRightPost - 1) {
                const startX = (x < gateRightPost + 1) ? gateRightPost : x;
                this.createFenceRail(startX, bounds.maxZ, nextX, bounds.maxZ, railHeight1, railMaterial);
                this.createFenceRail(startX, bounds.maxZ, nextX, bounds.maxZ, railHeight2, railMaterial);
            }
        }
        
        // Left edge rails
        for (let z = bounds.minZ; z < bounds.maxZ; z += postSpacing) {
            this.createFenceRail(bounds.minX, z, bounds.minX, z + postSpacing, railHeight1, railMaterial);
            this.createFenceRail(bounds.minX, z, bounds.minX, z + postSpacing, railHeight2, railMaterial);
        }
        
        // Right edge rails
        for (let z = bounds.minZ; z < bounds.maxZ; z += postSpacing) {
            this.createFenceRail(bounds.maxX, z, bounds.maxX, z + postSpacing, railHeight1, railMaterial);
            this.createFenceRail(bounds.maxX, z, bounds.maxX, z + postSpacing, railHeight2, railMaterial);
        }
        
        return fencePosts;
    }
    
    createFenceRail(x1, z1, x2, z2, height, material) {
        const distance = Math.sqrt((x2-x1)*(x2-x1) + (z2-z1)*(z2-z1));
        if (distance < 0.1) return; // Skip very short rails
        
        const railGeometry = new THREE.CylinderGeometry(0.08, 0.08, distance, 6);
        const rail = new THREE.Mesh(railGeometry, material);
        
        // Position rail at midpoint
        rail.position.set((x1 + x2) / 2, height, (z1 + z2) / 2);
        
        // Rotate rail to connect posts
        // First rotate to horizontal (from vertical default)
        rail.rotation.z = Math.PI / 2;
        
        // Then rotate around Y axis to point in the right direction
        const angle = Math.atan2(z2 - z1, x2 - x1);
        rail.rotation.y = angle;
        
        rail.castShadow = true;
        rail.receiveShadow = true;
        this.scene.add(rail);
        
        return rail;
    }

    createGateAndPasture(gate, pasture) {
        const gateElements = [];
        
        // Create gate posts - taller and more prominent
        const postGeometry = new THREE.CylinderGeometry(0.4, 0.4, gate.height + 1, 8);
        const postMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x4a3c28,
            emissive: 0x1a0a00,
            emissiveIntensity: 0.1
        });
        
        // Left post
        const leftPost = new THREE.Mesh(postGeometry, postMaterial);
        leftPost.position.set(gate.position.x - gate.width/2, (gate.height + 1)/2, gate.position.z);
        leftPost.castShadow = true;
        leftPost.receiveShadow = true;
        this.scene.add(leftPost);
        gateElements.push(leftPost);
        
        // Right post
        const rightPost = new THREE.Mesh(postGeometry, postMaterial);
        rightPost.position.set(gate.position.x + gate.width/2, (gate.height + 1)/2, gate.position.z);
        rightPost.castShadow = true;
        rightPost.receiveShadow = true;
        this.scene.add(rightPost);
        gateElements.push(rightPost);
        
        // Decorative gate arch
        const archGeometry = new THREE.CylinderGeometry(0.2, 0.2, gate.width + 1, 8);
        const archMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x6a5a4a,
            emissive: 0x2a1a00,
            emissiveIntensity: 0.1
        });
        
        const arch = new THREE.Mesh(archGeometry, archMaterial);
        arch.position.set(gate.position.x, gate.height + 0.5, gate.position.z);
        arch.rotation.z = Math.PI / 2;
        arch.castShadow = true;
        this.scene.add(arch);
        gateElements.push(arch);
        
        // Gate threshold marker (on ground) - more prominent
        const thresholdGeometry = new THREE.BoxGeometry(gate.width + 2, 0.15, 3);
        const thresholdMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xFFD700, // Gold
            emissive: 0x806000,
            emissiveIntensity: 0.3
        });
        
        const threshold = new THREE.Mesh(thresholdGeometry, thresholdMaterial);
        threshold.position.set(gate.position.x, 0.075, gate.position.z);
        this.scene.add(threshold);
        gateElements.push(threshold);
        
        // Add welcome sign above gate
        this.createWelcomeSign(gate.position.x, gate.height + 1.5, gate.position.z - 1);
        
        // Create enhanced pasture area
        const pastureElements = this.createEnhancedPasture(pasture, gate);
        
        return {
            gate: gateElements,
            pasture: pastureElements
        };
    }
    
    createWelcomeSign(x, y, z) {
        // Sign post
        const postGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 6);
        const postMaterial = new THREE.MeshPhongMaterial({ color: 0x4a3c28 });
        const signPost = new THREE.Mesh(postGeometry, postMaterial);
        signPost.position.set(x, y - 0.5, z);
        signPost.castShadow = true;
        this.scene.add(signPost);
        
        // Sign board
        const signGeometry = new THREE.BoxGeometry(3, 0.8, 0.2);
        const signMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x8B4513,
            emissive: 0x2a1a00,
            emissiveIntensity: 0.05
        });
        const signBoard = new THREE.Mesh(signGeometry, signMaterial);
        signBoard.position.set(x, y, z);
        signBoard.castShadow = true;
        this.scene.add(signBoard);
    }
    
    createEnhancedPasture(pasture, gate) {
        const pastureElements = [];
        
        // Create a more enclosed pen with proper fencing
        this.createPenFencing(pasture, pastureElements);
        
        // Enhanced pasture ground with better texture
        const pastureGeometry = new THREE.PlaneGeometry(
            pasture.maxX - pasture.minX + 4, 
            pasture.maxZ - pasture.minZ + 4
        );
        
        // Create enhanced pasture texture
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 1024;
        const context = canvas.getContext('2d');
        
        // Rich, comfortable grass for sleeping pasture
        const gradient = context.createRadialGradient(512, 512, 0, 512, 512, 512);
        gradient.addColorStop(0, '#6a8a5a');
        gradient.addColorStop(0.5, '#5a7a4a');
        gradient.addColorStop(1, '#4a6a3a');
        context.fillStyle = gradient;
        context.fillRect(0, 0, 1024, 1024);
        
        // Add clover patches
        for (let i = 0; i < 50; i++) {
            const x = Math.random() * 1024;
            const y = Math.random() * 1024;
            const radius = 20 + Math.random() * 30;
            
            const cloverGradient = context.createRadialGradient(x, y, 0, x, y, radius);
            cloverGradient.addColorStop(0, '#7a9a6a');
            cloverGradient.addColorStop(1, 'transparent');
            context.fillStyle = cloverGradient;
            context.beginPath();
            context.arc(x, y, radius, 0, Math.PI * 2);
            context.fill();
        }
        
        // Add texture details
        for (let i = 0; i < 2000; i++) {
            context.fillStyle = `rgba(${60 + Math.random() * 40}, ${120 + Math.random() * 40}, ${60 + Math.random() * 40}, 0.15)`;
            context.fillRect(Math.random() * 1024, Math.random() * 1024, 2, 2);
        }
        
        const pastureTexture = new THREE.CanvasTexture(canvas);
        pastureTexture.wrapS = THREE.RepeatWrapping;
        pastureTexture.wrapT = THREE.RepeatWrapping;
        pastureTexture.repeat.set(3, 3);
        pastureTexture.colorSpace = THREE.SRGBColorSpace;
        
        const pastureMaterial = new THREE.MeshPhongMaterial({ 
            map: pastureTexture,
            emissive: 0x1a2a1a,
            emissiveIntensity: 0.08
        });
        
        const pastureMesh = new THREE.Mesh(pastureGeometry, pastureMaterial);
        pastureMesh.rotation.x = -Math.PI / 2;
        pastureMesh.position.set(
            (pasture.minX + pasture.maxX) / 2, 
            0.02, 
            (pasture.minZ + pasture.maxZ) / 2
        );
        pastureMesh.receiveShadow = true;
        this.scene.add(pastureMesh);
        pastureElements.push(pastureMesh);
        
        // Add comfort features
        this.addPastureComfortFeatures(pasture, pastureElements);
        
        return pastureElements;
    }
    
    createPenFencing(pasture, pastureElements) {
        const fencePostGeometry = new THREE.CylinderGeometry(0.25, 0.25, 3.5, 8);
        const fencePostMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x5a4a3a,
            emissive: 0x1a0a00,
            emissiveIntensity: 0.05
        });
        
        const railMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x6a5a4a,
            emissive: 0x1a0a00,
            emissiveIntensity: 0.05
        });
        
        const postSpacing = 8;
        const railHeight1 = 1.2;
        const railHeight2 = 2.4;
        
        // Back fence (complete enclosure)
        for (let x = pasture.minX - 2; x <= pasture.maxX + 2; x += postSpacing) {
            const post = new THREE.Mesh(fencePostGeometry, fencePostMaterial);
            post.position.set(x, 1.75, pasture.maxZ + 2);
            post.castShadow = true;
            this.scene.add(post);
            pastureElements.push(post);
            
            // Add rails
            if (x < pasture.maxX + 2) {
                this.createFenceRail(x, pasture.maxZ + 2, x + postSpacing, pasture.maxZ + 2, railHeight1, railMaterial);
                this.createFenceRail(x, pasture.maxZ + 2, x + postSpacing, pasture.maxZ + 2, railHeight2, railMaterial);
            }
        }
        
        // Side fences (left and right) - stop at the boundary fence line
        for (let z = pasture.maxZ + 2; z > pasture.minZ + 2; z -= postSpacing) {
            // Left side
            const leftPost = new THREE.Mesh(fencePostGeometry, fencePostMaterial);
            leftPost.position.set(pasture.minX - 2, 1.75, z);
            leftPost.castShadow = true;
            this.scene.add(leftPost);
            pastureElements.push(leftPost);
            
            // Right side
            const rightPost = new THREE.Mesh(fencePostGeometry, fencePostMaterial);
            rightPost.position.set(pasture.maxX + 2, 1.75, z);
            rightPost.castShadow = true;
            this.scene.add(rightPost);
            pastureElements.push(rightPost);
            
            // Add rails
            if (z > pasture.minZ + 2) {
                this.createFenceRail(pasture.minX - 2, z, pasture.minX - 2, z - postSpacing, railHeight1, railMaterial);
                this.createFenceRail(pasture.minX - 2, z, pasture.minX - 2, z - postSpacing, railHeight2, railMaterial);
                this.createFenceRail(pasture.maxX + 2, z, pasture.maxX + 2, z - postSpacing, railHeight1, railMaterial);
                this.createFenceRail(pasture.maxX + 2, z, pasture.maxX + 2, z - postSpacing, railHeight2, railMaterial);
            }
        }
        
        // Add corner posts to connect with boundary fence
        // Left corner post
        const leftCornerPost = new THREE.Mesh(fencePostGeometry, fencePostMaterial);
        leftCornerPost.position.set(pasture.minX - 2, 1.75, pasture.minZ + 2);
        leftCornerPost.castShadow = true;
        this.scene.add(leftCornerPost);
        pastureElements.push(leftCornerPost);
        
        // Right corner post  
        const rightCornerPost = new THREE.Mesh(fencePostGeometry, fencePostMaterial);
        rightCornerPost.position.set(pasture.maxX + 2, 1.75, pasture.minZ + 2);
        rightCornerPost.castShadow = true;
        this.scene.add(rightCornerPost);
        pastureElements.push(rightCornerPost);
        
        // Connect corner posts to the last side fence posts
        const lastSideZ = pasture.minZ + 2 + postSpacing;
        this.createFenceRail(pasture.minX - 2, lastSideZ, pasture.minX - 2, pasture.minZ + 2, railHeight1, railMaterial);
        this.createFenceRail(pasture.minX - 2, lastSideZ, pasture.minX - 2, pasture.minZ + 2, railHeight2, railMaterial);
        this.createFenceRail(pasture.maxX + 2, lastSideZ, pasture.maxX + 2, pasture.minZ + 2, railHeight1, railMaterial);
        this.createFenceRail(pasture.maxX + 2, lastSideZ, pasture.maxX + 2, pasture.minZ + 2, railHeight2, railMaterial);
        
        // Connect the nearest boundary fence posts to gate posts to close the gaps
        const gateLeftPost = -4; // Gate left post position (gate width/2 = 4)
        const gateRightPost = 4; // Gate right post position (gate width/2 = 4)
        const gateZ = 100; // Gate is at z = 100
        
        // The nearest boundary fence posts to the gate are at x = -10 and x = +10
        const nearestLeftBoundaryPost = -10;
        const nearestRightBoundaryPost = 10;
        const boundaryZ = 100; // Boundary fence is at z = 100
        
        // Left side connection from nearest boundary post to gate post
        this.createFenceRail(nearestLeftBoundaryPost, boundaryZ, gateLeftPost, gateZ, railHeight1, railMaterial);
        this.createFenceRail(nearestLeftBoundaryPost, boundaryZ, gateLeftPost, gateZ, railHeight2, railMaterial);
        
        // Right side connection from nearest boundary post to gate post
        this.createFenceRail(nearestRightBoundaryPost, boundaryZ, gateRightPost, gateZ, railHeight1, railMaterial);
        this.createFenceRail(nearestRightBoundaryPost, boundaryZ, gateRightPost, gateZ, railHeight2, railMaterial);
    }
    
    addPastureComfortFeatures(pasture, pastureElements) {
        // Add water trough
        const troughGeometry = new THREE.BoxGeometry(4, 0.8, 1.5);
        const troughMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x666666,
            emissive: 0x111111
        });
        const trough = new THREE.Mesh(troughGeometry, troughMaterial);
        trough.position.set(pasture.maxX - 5, 0.4, pasture.maxZ - 5);
        trough.castShadow = true;
        trough.receiveShadow = true;
        this.scene.add(trough);
        pastureElements.push(trough);
        
        // Add water surface
        const waterGeometry = new THREE.PlaneGeometry(3.8, 1.3);
        const waterMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x4488cc,
            transparent: true,
            opacity: 0.8,
            emissive: 0x002244,
            emissiveIntensity: 0.1
        });
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.set(pasture.maxX - 5, 0.81, pasture.maxZ - 5);
        this.scene.add(water);
        pastureElements.push(water);
        
        // Add hay bales for comfort
        const hayGeometry = new THREE.CylinderGeometry(1.5, 1.5, 1.2, 8);
        const hayMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xDAA520,
            emissive: 0x2a1a00,
            emissiveIntensity: 0.05
        });
        
        // Place several hay bales
        const hayPositions = [
            { x: pasture.minX + 5, z: pasture.maxZ - 8 },
            { x: pasture.maxX - 10, z: pasture.minZ + 8 },
            { x: (pasture.minX + pasture.maxX) / 2, z: pasture.maxZ - 12 }
        ];
        
        hayPositions.forEach(pos => {
            const hayBale = new THREE.Mesh(hayGeometry, hayMaterial);
            hayBale.position.set(pos.x, 0.6, pos.z);
            hayBale.rotation.z = Math.PI / 2; // Lay on side
            hayBale.castShadow = true;
            hayBale.receiveShadow = true;
            this.scene.add(hayBale);
            pastureElements.push(hayBale);
        });
        
        // Tree removed from pen area for better gameplay
    }
}
```

## client/js/TerrainBuilder.js

```javascript
import * as THREE from 'three';

/**
 * TerrainBuilder - Handles terrain, grass, mountains, and environmental elements
 */
export class TerrainBuilder {
    constructor(scene) {
        this.scene = scene;
        this.grassMaterial = null;
        this.grassInstanceCount = 0;
    }
    
    createTerrain() {
        // Create flat terrain - extended to match grass coverage
        const terrainGeometry = new THREE.PlaneGeometry(1000, 1000);
        const terrainMaterial = new THREE.MeshPhongMaterial({
            color: 0x4a7c4a,
            emissive: 0x1a3a1a,
            emissiveIntensity: 0.1,
            shininess: 0
        });
        
        const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
        terrain.rotation.x = -Math.PI / 2;
        terrain.position.y = 0;
        terrain.receiveShadow = true;
        this.scene.add(terrain);
        
        return terrain;
    }
    
    createGrass() {
        // Create instanced grass using shaders
        const grassVertexShader = `
            varying vec2 vUv;
            varying vec3 vWorldPos;
            uniform float time;
            
            void main() {
                vUv = uv;
                
                // Get instance position
                vec3 pos = position;
                vec4 mvPosition = vec4(pos, 1.0);
                
                #ifdef USE_INSTANCING
                    mvPosition = instanceMatrix * mvPosition;
                #endif
                
                vWorldPos = (modelMatrix * mvPosition).xyz;
                
                // Wind displacement - stronger at blade tips
                float dispPower = 1.0 - cos(uv.y * 3.14159 / 2.0);
                
                // Complex wind pattern
                float windX = sin(vWorldPos.z * 0.1 + time * 2.0) * cos(vWorldPos.x * 0.1 + time * 1.5);
                float windZ = cos(vWorldPos.x * 0.15 + time * 2.5) * sin(vWorldPos.z * 0.15 + time * 2.0);
                
                float displacement = windX * (0.15 * dispPower);
                mvPosition.x += displacement;
                mvPosition.z += windZ * (0.1 * dispPower);
                
                vec4 modelViewPosition = modelViewMatrix * mvPosition;
                gl_Position = projectionMatrix * modelViewPosition;
            }
        `;
        
        const grassFragmentShader = `
            varying vec2 vUv;
            varying vec3 vWorldPos;
            uniform vec3 fogColor;
            uniform float fogNear;
            uniform float fogFar;
            
            void main() {
                // Gradient from dark at base to light at tips
                vec3 baseColor = vec3(0.2, 0.5, 0.1);
                vec3 tipColor = vec3(0.41, 0.8, 0.3);
                
                // Add some color variation based on world position
                float colorVariation = sin(vWorldPos.x * 0.5) * cos(vWorldPos.z * 0.5) * 0.1;
                
                vec3 grassColor = mix(baseColor, tipColor, vUv.y);
                grassColor += vec3(colorVariation, colorVariation * 0.5, 0.0);
                
                // Apply fog
                float depth = gl_FragCoord.z / gl_FragCoord.w;
                float fogFactor = smoothstep(fogNear, fogFar, depth);
                
                vec3 finalColor = mix(grassColor, fogColor, fogFactor);
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;
        
        const grassUniforms = {
            time: { value: 0 },
            fogColor: { value: new THREE.Color(0x87CEEB) },
            fogNear: { value: 200 },
            fogFar: { value: 600 }
        };
        
        this.grassMaterial = new THREE.ShaderMaterial({
            vertexShader: grassVertexShader,
            fragmentShader: grassFragmentShader,
            uniforms: grassUniforms,
            side: THREE.DoubleSide
        });
        
        // Create grass blade geometry - small
        const bladeGeometry = new THREE.PlaneGeometry(0.05, 0.8, 1, 4);
        bladeGeometry.translate(0, 0.4, 0); // Move pivot to base
        
        // Create instanced mesh for grass - optimized for performance
        // Reduce grass count for better performance on high-end systems
        const instanceCount = 400000; // Reduced from 800k for better performance
        this.grassInstanceCount = instanceCount;
        const grassMesh = new THREE.InstancedMesh(bladeGeometry, this.grassMaterial, instanceCount);
        
        const dummy = new THREE.Object3D();
        
        // Distribute grass instances - extend much further out
        let placedCount = 0;
        for (let i = 0; i < instanceCount && placedCount < instanceCount; i++) {
            // Random position within much larger bounds - extend to horizon
            const x = (Math.random() - 0.5) * 800; // Increased from 240 to 800
            const z = (Math.random() - 0.5) * 800; // Increased from 240 to 800
            
            // Skip grass in the pasture area
            if (z > 100 && z < 130 && Math.abs(x) < 30) {
                continue;
            }
            
            dummy.position.set(x, 0, z);
            
            // Random scale and rotation with distance-based scaling
            const distanceFromCenter = Math.sqrt(x * x + z * z);
            const distanceScale = Math.max(0.3, 1.0 - distanceFromCenter / 600); // Grass gets smaller with distance
            const scale = (0.8 + Math.random() * 0.4) * distanceScale;
            dummy.scale.setScalar(scale);
            dummy.rotation.y = Math.random() * Math.PI * 2;
            
            // Slight random tilt
            dummy.rotation.z = (Math.random() - 0.5) * 0.1;
            
            dummy.updateMatrix();
            grassMesh.setMatrixAt(placedCount, dummy.matrix);
            placedCount++;
        }
        
        grassMesh.castShadow = true;
        grassMesh.receiveShadow = true;
        this.scene.add(grassMesh);
        
        return grassMesh;
    }
    
    createTrees() {
        // Tree trunk material
        const trunkMaterial = new THREE.MeshPhongMaterial({
            color: 0x4a3a2a,
            emissive: 0x1a0a00,
            emissiveIntensity: 0.05
        });
        
        // Richer foliage materials for variety & realism
        const foliageMaterials = [
            new THREE.MeshPhongMaterial({
                color: 0x355e29,
                emissive: 0x0e1a0e,
                emissiveIntensity: 0.1,
                flatShading: true
            }),
            new THREE.MeshPhongMaterial({
                color: 0x426b33,
                emissive: 0x112411,
                emissiveIntensity: 0.1,
                flatShading: true
            }),
            new THREE.MeshPhongMaterial({
                color: 0x274b1f,
                emissive: 0x091609,
                emissiveIntensity: 0.1,
                flatShading: true
            })
        ];

        // Helper to add slight noise to a spherical geometry for a fluffier canopy
        const addCanopyNoise = (geometry, amplitude = 0.4) => {
            const positionAttr = geometry.attributes.position;
            const normal = new THREE.Vector3();
            for (let i = 0; i < positionAttr.count; i++) {
                normal.set(
                    positionAttr.getX(i),
                    positionAttr.getY(i),
                    positionAttr.getZ(i)
                ).normalize();
                const offset = (Math.random() - 0.5) * amplitude;
                positionAttr.setXYZ(
                    i,
                    positionAttr.getX(i) + normal.x * offset,
                    positionAttr.getY(i) + normal.y * offset,
                    positionAttr.getZ(i) + normal.z * offset
                );
            }
            geometry.computeVertexNormals();
        };

        const trees = [];

        /***********************
         *  DECIDUOUS TREES   *
         ***********************/
        for (let i = 0; i < 200; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 120 + Math.random() * 300; // Spread trees further out
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;

            // Keep play area clear
            if (Math.abs(x) < 120 && Math.abs(z) < 120) continue;
            if (z > 100 && z < 135 && Math.abs(x) < 35) continue;

            // Trunk
            const trunkHeight = 7 + Math.random() * 5;
            const trunkRadius = 0.6 + Math.random() * 0.5;
            const trunkGeometry = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, 8);
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, trunkHeight / 2, z);
            trunk.castShadow = true;
            this.scene.add(trunk);
            trees.push(trunk);

            // Canopy – multiple irregular lumps for an organic silhouette
            const canopyLumps = 3 + Math.floor(Math.random() * 2); // 3-4 lumps
            const materialIndex = Math.floor(Math.random() * foliageMaterials.length);

            for (let l = 0; l < canopyLumps; l++) {
                const radius = 4 + Math.random() * 2 - l * 0.5;
                const icoDetail = 1; // keeps polycount low
                const canopyGeometry = new THREE.IcosahedronGeometry(radius, icoDetail);
                addCanopyNoise(canopyGeometry, 0.5);

                const canopy = new THREE.Mesh(canopyGeometry, foliageMaterials[materialIndex]);
                canopy.position.set(
                    x + (Math.random() - 0.5) * 1.5,
                    trunkHeight + radius / 2 + l * 0.8 + Math.random() * 0.5,
                    z + (Math.random() - 0.5) * 1.5
                );
                canopy.rotation.y = Math.random() * Math.PI;
                canopy.castShadow = true;
                canopy.receiveShadow = true;
                this.scene.add(canopy);
                trees.push(canopy);
            }
        }

        /***********************
         *      PINE TREES    *
         ***********************/
        for (let i = 0; i < 80; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 140 + Math.random() * 250;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;

            if (Math.abs(x) < 120 && Math.abs(z) < 120) continue;
            if (z > 100 && z < 135 && Math.abs(x) < 35) continue;

            // Trunk
            const trunkHeight = 5 + Math.random() * 3;
            const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, trunkHeight, 6);
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, trunkHeight / 2, z);
            trunk.castShadow = true;
            this.scene.add(trunk);
            trees.push(trunk);

            // Layered foliage – stacked cones for a stylised pine
            const layers = 3 + Math.floor(Math.random() * 2); // 3-4 layers
            const baseHeight = trunkHeight;
            const pineMaterial = new THREE.MeshPhongMaterial({
                color: 0x1e4b1e,
                emissive: 0x061406,
                emissiveIntensity: 0.1,
                flatShading: true
            });

            for (let l = 0; l < layers; l++) {
                const layerRadius = 3 - l * 0.6 + Math.random() * 0.4;
                const layerHeight = 4 + Math.random() * 1.5;
                const layerGeometry = new THREE.ConeGeometry(layerRadius, layerHeight, 8, 1, true);

                addCanopyNoise(layerGeometry, 0.3);

                const layerMesh = new THREE.Mesh(layerGeometry, pineMaterial);
                layerMesh.position.set(
                    x,
                    baseHeight + l * 2 + layerHeight / 2,
                    z
                );
                layerMesh.rotation.y = Math.random() * Math.PI;
                layerMesh.castShadow = true;
                layerMesh.receiveShadow = true;
                this.scene.add(layerMesh);
                trees.push(layerMesh);
            }
        }

        return trees;
    }
    
    addEnvironmentDetails() {
        // Add rocks - placed outside the play area
        const rockGeometry = new THREE.DodecahedronGeometry(1, 0);
        const rockMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x666666,
            emissive: 0x111111,
            emissiveIntensity: 0.05,
            flatShading: true
        });
        
        const rocks = [];
        
        // Play area boundaries to avoid: X: -100 to 100, Z: -100 to 130 (including pasture)
        const playAreaBounds = {
            minX: -100,
            maxX: 100,
            minZ: -100,
            maxZ: 130
        };
        
        // Increase rock count since we have more area to fill
        for (let i = 0; i < 40; i++) {
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            let x, z;
            let attempts = 0;
            
            // Find a position outside the play area
            do {
                // Generate position in larger area (400x400)
                x = (Math.random() - 0.5) * 400;
                z = (Math.random() - 0.5) * 400;
                attempts++;
                
                // Prevent infinite loop
                if (attempts > 100) {
                    // Force placement in known safe areas
                    if (Math.random() < 0.5) {
                        // Place far left or right
                        x = Math.random() < 0.5 ? -150 - Math.random() * 100 : 150 + Math.random() * 100;
                        z = (Math.random() - 0.5) * 300;
                    } else {
                        // Place far north or south
                        x = (Math.random() - 0.5) * 300;
                        z = Math.random() < 0.5 ? -150 - Math.random() * 100 : 180 + Math.random() * 100;
                    }
                    break;
                }
            } while (
                x >= playAreaBounds.minX && x <= playAreaBounds.maxX &&
                z >= playAreaBounds.minZ && z <= playAreaBounds.maxZ
            );
            
            rock.position.set(x, 0.5, z);
            rock.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            
            const scale = 0.5 + Math.random() * 1.5;
            rock.scale.set(scale, scale * 0.7, scale);
            
            rock.castShadow = true;
            rock.receiveShadow = true;
            this.scene.add(rock);
            rocks.push(rock);
        }
        
        return rocks;
    }
    
    updateGrassAnimation() {
        if (this.grassMaterial) {
            this.grassMaterial.uniforms.time.value = performance.now() * 0.001;
        }
    }
    
    getGrassMaterial() {
        return this.grassMaterial;
    }
    
    getGrassInstanceCount() {
        return this.grassInstanceCount;
    }
}
```

## client/js/Vector2D.js

```javascript
/**
 * Simple 2D Vector class for XZ plane calculations
 */
export class Vector2D {
    constructor(x = 0, z = 0) {
        this.x = x;
        this.z = z;
    }

    // Set the x and z components
    set(x, z) {
        this.x = x;
        this.z = z;
        return this;
    }

    // Add another vector to this one
    add(vector) {
        this.x += vector.x;
        this.z += vector.z;
        return this;
    }

    // Subtract another vector from this one
    subtract(vector) {
        this.x -= vector.x;
        this.z -= vector.z;
        return this;
    }

    // Multiply by a scalar
    multiply(scalar) {
        this.x *= scalar;
        this.z *= scalar;
        return this;
    }

    // Divide by a scalar
    divide(scalar) {
        if (scalar !== 0) {
            this.x /= scalar;
            this.z /= scalar;
        }
        return this;
    }

    // Get the magnitude (length) of the vector
    magnitude() {
        return Math.sqrt(this.x * this.x + this.z * this.z);
    }

    // Normalize the vector (make it unit length)
    normalize() {
        const len = this.magnitude();
        if (len > 0.00001) { // Use a small epsilon to prevent division by zero/tiny number
            this.x /= len;
            this.z /= len;
        } else {
            this.x = 0;
            this.z = 0;
        }
        return this;
    }

    // Limit the magnitude of the vector
    limit(max) {
        const len = this.magnitude();
        if (len > max && len > 0.00001) { // Only normalize if magnitude is significant and over max
            this.normalize();
            this.multiply(max);
        }
        return this;
    }

    // Get distance to another vector
    distanceTo(vector) {
        const dx = this.x - vector.x;
        const dz = this.z - vector.z;
        return Math.sqrt(dx * dx + dz * dz);
    }

    // Get the angle of the vector in radians
    angle() {
        return Math.atan2(this.z, this.x);
    }

    // Set the magnitude of the vector
    setMagnitude(magnitude) {
        this.normalize();
        this.multiply(magnitude);
        return this;
    }

    // Create a copy of this vector
    clone() {
        return new Vector2D(this.x, this.z);
    }

    // Static method to create a vector from an angle
    static fromAngle(angle) {
        return new Vector2D(Math.cos(angle), Math.sin(angle));
    }

    // Static method to get a random unit vector
    static random() {
        const angle = Math.random() * Math.PI * 2;
        return Vector2D.fromAngle(angle);
    }
}
```

## debug-client.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geckos Debug Client</title>
</head>
<body>
    <h1>Geckos Debug Client</h1>
    
    <div id="status">Not connected</div>
    <button id="connectBtn">Connect to Server</button>
    <button id="testBtn" disabled>Send Test Message</button>
    <button id="pingBtn" disabled>Send Ping</button>
    
    <div id="log"></div>
    
    <script type="importmap">
    {
        "imports": {
            "@geckos.io/client": "https://cdn.jsdelivr.net/npm/@geckos.io/client@3.0.2/+esm"
        }
    }
    </script>
    
    <script type="module">
        import geckos from '@geckos.io/client';
        
        let channel = null;
        let connected = false;
        
        const statusDiv = document.getElementById('status');
        const logDiv = document.getElementById('log');
        const connectBtn = document.getElementById('connectBtn');
        const testBtn = document.getElementById('testBtn');
        const pingBtn = document.getElementById('pingBtn');
        
        function log(message) {
            console.log(message);
            const div = document.createElement('div');
            div.textContent = new Date().toLocaleTimeString() + ': ' + message;
            logDiv.appendChild(div);
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function updateStatus(status) {
            statusDiv.textContent = status;
            testBtn.disabled = !connected;
            pingBtn.disabled = !connected;
        }
        
        connectBtn.addEventListener('click', async () => {
            log('🔗 Starting connection test...');
            log('🔗 Hostname: ' + window.location.hostname);
            
            const serverUrl = (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') ? 
                'http://127.0.0.1' : 
                'https://your-production-server.fly.dev';
            const port = 3000; // Test port for debugging
            
            log('🔗 Server URL: ' + serverUrl + ':' + port);
            
            try {
                channel = geckos({
                    url: serverUrl,
                    port: port
                });
                
                log('🔗 Geckos client created');
                
                channel.onConnect(error => {
                    if (error) {
                        log('❌ Connection failed: ' + error);
                        updateStatus('Connection failed');
                    } else {
                        log('✅ Connected successfully!');
                        connected = true;
                        updateStatus('Connected');
                    }
                });
                
                channel.onDisconnect(() => {
                    log('❌ Disconnected from server');
                    connected = false;
                    updateStatus('Disconnected');
                });
                
                channel.on('welcome', (data) => {
                    log('📨 Received welcome: ' + data.message);
                });
                
                channel.on('testResponse', (data) => {
                    log('📨 Received test response: ' + data.message);
                });
                
                channel.on('pong', (data) => {
                    log('📨 Received pong: ' + data.timestamp);
                });
                
            } catch (error) {
                log('❌ Error creating client: ' + error);
                updateStatus('Error');
            }
        });
        
        testBtn.addEventListener('click', () => {
            if (channel && connected) {
                log('📤 Sending test message...');
                channel.emit('test', { message: 'Hello from client!' });
            }
        });
        
        pingBtn.addEventListener('click', () => {
            if (channel && connected) {
                log('📤 Sending ping...');
                channel.emit('ping');
            }
        });
    </script>
    
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        #status {
            font-size: 18px;
            font-weight: bold;
            margin: 20px 0;
            padding: 10px;
            border: 2px solid #ccc;
            border-radius: 5px;
        }
        
        button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
        }
        
        #log {
            margin-top: 20px;
            height: 400px;
            overflow-y: scroll;
            border: 1px solid #ccc;
            padding: 10px;
            background: #f5f5f5;
            font-family: monospace;
        }
        
        #log div {
            margin: 2px 0;
        }
    </style>
</body>
</html>
```

## DEPLOYMENT.md

````markdown
# 🚀 Deployment Guide

## Overview
This project uses GitHub Pages for static hosting:
- **Client**: GitHub Pages (static hosting) at `https://matthew-kissinger.github.io/sds/`  
- **Multiplayer**: Currently disabled (Fly.io server removed)

## ⚠️ Current Status: Multiplayer Disabled

Multiplayer functionality has been **temporarily disabled** due to Fly.io compatibility issues:
- **Single-player mode**: ✅ Fully functional on GitHub Pages
- **Multiplayer mode**: ❌ Disabled (shows error message to users)
- **Local development**: ✅ Multiplayer still works with local server

**For local multiplayer testing:**
- Run `npm run start-multiplayer-servers` in the `/server` directory  
- Use `http://127.0.0.1:PORT/` (not GitHub Pages) to access local multiplayer

## Pre-Deployment Checklist ✅

### 1. Local Testing (Phase 2)
```bash
# Test local multiplayer
npm run start-multiplayer-servers

# Open multiple browser tabs to test multiplayer
# Verify single-player mode still works
```

### 2. Code Changes Made ✅
- ✅ Server configured for Fly.io (bind to `0.0.0.0`)
- ✅ Created `fly.toml` configuration 
- ✅ Added production logging
- ✅ Updated NetworkManager for production URLs
- ✅ Client detects GitHub Pages and connects to Fly.io

## Deployment Steps

### Step 1: Deploy Server to Fly.io 🛫

```bash
# Install Fly CLI (if not already installed)
curl -L https://fly.io/install.sh | sh

# Authenticate
fly auth login

# Navigate to server directory
cd server/

# Launch app (this will create and deploy)
fly launch

# Note: When prompted:
# - App name: Use "sheepdog-multiplayer" (or accept generated name)
# - Region: Choose closest to your users
# - Don't add Redis/PostgreSQL
# - Deploy now: Yes
```

**Important**: Note the final URL you get (e.g., `https://your-app.fly.dev`)

### Step 2: Verify Server Deployment ✅

```bash
# Check logs
fly logs

# Check status
fly status

# Test endpoint (note: Geckos.io uses port 9208)
curl https://server-little-cherry-7613.fly.dev:9208/
```

### Step 3: Update Client (If App Name Different) 🔧

If Fly.io gave you a different app name than "server-little-cherry-7613":

1. Update `js/NetworkManager.js`:
```javascript
this.serverHost = window.location.hostname === 'matthew-kissinger.github.io' ? 
    'your-actual-app-name.fly.dev' : // ← Update this line
    '127.0.0.1';
```

### Step 4: Push to GitHub Pages 📄

```bash
# Commit all changes
git add .
git commit -m "Add multiplayer server deployment configuration"

# Push to GitHub (triggers GitHub Pages update)
git push origin main
```

### Step 5: Verify Production Setup 🧪

1. Visit: `https://matthew-kissinger.github.io/sds/`
2. Try "👥 Play Online" → Should connect to Fly.io server
3. Try "🐕 Play Solo" → Should work locally without server
4. Test with multiple browser tabs/devices

## Troubleshooting 🛠️

### Server Issues
```bash
# Check server logs
fly logs --app server-little-cherry-7613

# Check server status
fly status --app server-little-cherry-7613

# Restart server
fly restart --app server-little-cherry-7613
```

### Client Connection Issues
- Check browser console for connection errors
- Verify NetworkManager is using correct production URL
- Ensure Fly.io server is running (`fly status`)

### UDP/WebRTC Issues
- Geckos.io uses WebRTC which may be blocked by some firewalls
- Server logs will show connection attempts
- Try from different networks if issues persist

### Local Development Issues
- **Important**: Use `http://127.0.0.1:PORT/` instead of `http://localhost:PORT/` (per Geckos.io docs)
- If server never establishes connection, may need to expose OPENSSL environment variables

## Production URLs

- **Client**: `https://matthew-kissinger.github.io/sds/`
- **Server**: `https://server-little-cherry-7613.fly.dev:9208` (Geckos.io signaling)
- **Server Logs**: `fly logs --app server-little-cherry-7613`
- **Server Dashboard**: `https://fly.io/apps/server-little-cherry-7613`

## Cost Information 💰

- **GitHub Pages**: Free
- **Fly.io**: Free tier includes:
  - 3 shared-cpu-1x VMs
  - 160GB-hours/month
  - Auto-scaling (sleeps when not used)

## Architecture

```
Users → GitHub Pages (Client) → Fly.io (Server)
     ↘                      ↗
       Single-player works offline
```

**Key Features**:
- ✅ Single-player works without server
- ✅ Multiplayer connects to Fly.io 
- ✅ Graceful fallback if server unavailable
- ✅ Auto-scaling server (sleeps when unused)
````

## index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#00BFFF">
    <title>Sheep Dog Sim</title>
    <link rel="icon" type="image/png" href="assets/images/favicon.png">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            /* Prevent text selection on mobile */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Prevent touch callouts */
            -webkit-touch-callout: none;
            /* Prevent tap highlight */
            -webkit-tap-highlight-color: transparent;
        }
        
        #canvas-container {
            position: relative;
            width: 100%;
            height: 100vh;
            /* Prevent scrolling */
            touch-action: none;
            /* Prevent overscroll bounce on iOS */
            overscroll-behavior: none;
        }
        
        /* Prevent zoom on inputs and buttons */
        input, button, select, textarea {
            font-size: 16px;
            -webkit-appearance: none;
            border-radius: 0;
        }
        
        /* Start Screen Overlay */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
            /* Mobile safe area and scrolling */
            padding-top: max(20px, env(safe-area-inset-top));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
            padding-left: max(20px, env(safe-area-inset-left));
            padding-right: max(20px, env(safe-area-inset-right));
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        #game-title {
            font-size: 4.5rem;
            font-weight: 900;
            margin-bottom: 1rem;
            color: #00BFFF;
            font-family: 'Arial Black', Arial, sans-serif;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 3px 3px 0px #000;
        }
        
        /* Mobile responsive title */
        @media (max-width: 768px) {
            #start-screen {
                padding: 10px;
                justify-content: flex-start;
                padding-top: 5vh;
                padding-bottom: 5vh;
                min-height: 100vh;
                box-sizing: border-box;
                overflow-y: auto;
            }
            
            #game-title {
                font-size: 2.2rem;
                letter-spacing: 1px;
                margin-bottom: 0.5rem;
            }
            
            #game-subtitle {
                font-size: 0.9rem;
                margin-bottom: 1.5rem;
            }
            
            #start-instructions {
                max-width: 95%;
                padding: 1.2rem;
                margin-bottom: 1.5rem;
            }
            
            #start-instructions h3 {
                font-size: 1.1rem;
                margin-bottom: 0.8rem;
            }
            
            #start-instructions p {
                font-size: 0.85rem;
                margin: 0.6rem 0;
            }
            
            #start-button {
                padding: 15px 30px;
                font-size: 1.2rem;
                margin-top: 1rem;
                margin-bottom: 2rem;
            }
        }
        
        /* Mobile portrait adjustments */
        @media (max-width: 480px) and (orientation: portrait) {
            #start-screen {
                padding: 5px;
                justify-content: flex-start;
                padding-top: 2vh;
                padding-bottom: 3vh;
                min-height: 100vh;
                max-height: 100vh;
                overflow-y: auto;
                display: flex;
                flex-direction: column;
            }
            
            #game-title {
                font-size: 1.8rem;
                margin-bottom: 0.3rem;
            }
            
            #game-subtitle {
                font-size: 0.8rem;
                margin-bottom: 1rem;
            }
            
            #start-instructions {
                padding: 1rem;
                margin-bottom: 1rem;
                flex-shrink: 0;
            }
            
            #start-instructions h3 {
                font-size: 1rem;
            }
            
            #start-instructions p {
                font-size: 0.8rem;
                margin: 0.4rem 0;
            }
            
            #start-button {
                padding: 12px 25px;
                font-size: 1rem;
                margin-top: 1rem;
                margin-bottom: 2rem;
                flex-shrink: 0;
            }
        }
        
        /* Extra small screens - ensure everything fits */
        @media (max-width: 360px) and (max-height: 640px) {
            #start-screen {
                padding: 3px;
                padding-top: 1vh;
                padding-bottom: 2vh;
            }
            
            #game-title {
                font-size: 1.5rem;
                margin-bottom: 0.2rem;
            }
            
            #game-subtitle {
                font-size: 0.7rem;
                margin-bottom: 0.8rem;
            }
            
            #start-instructions {
                padding: 0.8rem;
                margin-bottom: 0.8rem;
            }
            
            #start-instructions h3 {
                font-size: 0.9rem;
                margin-bottom: 0.5rem;
            }
            
            #start-instructions p {
                font-size: 0.75rem;
                margin: 0.3rem 0;
            }
            
            #start-button {
                padding: 10px 20px;
                font-size: 0.9rem;
                margin-top: 0.8rem;
                margin-bottom: 1.5rem;
            }
        }
        
        /* Very short screens - ultra compact layout */
        @media (max-height: 600px) {
            #start-screen {
                padding: 2px;
                padding-top: 1vh;
                padding-bottom: 1vh;
                justify-content: space-between;
            }
            
            #game-title {
                font-size: 1.4rem;
                margin-bottom: 0.1rem;
            }
            
            #game-subtitle {
                font-size: 0.65rem;
                margin-bottom: 0.5rem;
            }
            
            #start-instructions {
                padding: 0.6rem;
                margin-bottom: 0.5rem;
            }
            
            #start-instructions h3 {
                font-size: 0.85rem;
                margin-bottom: 0.3rem;
            }
            
            #start-instructions p {
                font-size: 0.7rem;
                margin: 0.2rem 0;
                line-height: 1.2;
            }
            
            #start-button {
                padding: 8px 16px;
                font-size: 0.85rem;
                margin-top: 0.5rem;
                margin-bottom: 1rem;
            }
        }
        
        /* Landscape mobile - horizontal layout adjustments */
        @media (max-height: 500px) and (orientation: landscape) {
            #start-screen {
                flex-direction: row;
                align-items: center;
                justify-content: space-around;
                padding: 5px;
            }
            
            #start-screen > div:first-child {
                flex: 1;
                text-align: left;
            }
            
            #start-instructions {
                flex: 1;
                margin: 0 10px;
            }
            
            #start-button {
                flex-shrink: 0;
                margin: 0;
            }
        }
        
        #game-subtitle {
            font-size: 1.4rem;
            margin-bottom: 2rem;
            color: #FFF;
            font-family: Arial, sans-serif;
            font-weight: normal;
        }
        
        #start-instructions {
            background: rgba(255, 255, 255, 0.95);
            padding: 2rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            color: #333;
            border: 3px solid #00BFFF;
            max-width: 500px;
        }
        
        #start-instructions h3 {
            margin: 0 0 1rem 0;
            font-size: 1.5rem;
            color: #00BFFF;
            font-family: 'Arial Black', Arial, sans-serif;
            font-weight: 900;
        }
        
        #start-instructions p {
            margin: 0.8rem 0;
            font-size: 1rem;
            line-height: 1.4;
            font-family: Arial, sans-serif;
            color: #333;
        }
        
        #start-button {
            background: #00BFFF;
            border: 3px solid #FFF;
            color: #FFF;
            padding: 20px 40px;
            font-size: 1.5rem;
            font-weight: 900;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-family: 'Arial Black', Arial, sans-serif;
            text-shadow: 2px 2px 0px #000;
            /* Mobile touch improvements */
            min-height: 44px;
            min-width: 44px;
            /* Ensure button is always accessible */
            margin-bottom: max(20px, env(safe-area-inset-bottom, 20px));
            flex-shrink: 0;
        }
        
        #start-button:hover {
            background: #FFF;
            color: #00BFFF;
            border: 3px solid #00BFFF;
            text-shadow: none;
        }
        
        #start-button:active {
            transform: translateY(2px);
        }
        
        /* Mode Selection Styles */
        #mode-selection {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        .mode-button {
            background: #00BFFF;
            border: 3px solid #FFF;
            color: #FFF;
            padding: 18px 35px;
            font-size: 1.3rem;
            font-weight: 900;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'Arial Black', Arial, sans-serif;
            text-shadow: 2px 2px 0px #000;
            min-height: 44px;
            min-width: 200px;
            flex-shrink: 0;
        }
        
        .mode-button:hover {
            background: #FFF;
            color: #00BFFF;
            border: 3px solid #00BFFF;
            text-shadow: none;
            transform: translateY(-2px);
        }
        
        .mode-button:active {
            transform: translateY(0px);
        }
        
        .mode-button:disabled {
            background: #666;
            color: #999;
            border: 3px solid #999;
            cursor: not-allowed;
            transform: none;
        }
        
        .mode-button:disabled:hover {
            background: #666;
            color: #999;
            border: 3px solid #999;
            transform: none;
        }
        
        /* Connection Status Styles */
        #connection-status {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 8px;
            border: 3px solid #00BFFF;
            color: #333;
            text-align: center;
            max-width: 400px;
        }
        
        #connection-message {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: #333;
        }
        
        #back-to-menu-button {
            background: #666;
            border: 2px solid #333;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: Arial, sans-serif;
        }
        
        #back-to-menu-button:hover {
            background: #333;
            border: 2px solid #666;
        }
        
        /* Mobile responsive mode buttons */
        @media (max-width: 768px) {
            #mode-selection {
                gap: 12px;
            }
            
            .mode-button {
                padding: 15px 25px;
                font-size: 1.1rem;
                min-width: 180px;
            }
            
            #connection-status {
                padding: 15px;
                max-width: 90%;
            }
            
            #connection-message {
                font-size: 1rem;
                margin-bottom: 12px;
            }
        }
        
        @media (max-width: 480px) {
            .mode-button {
                padding: 12px 20px;
                font-size: 1rem;
                min-width: 160px;
            }
        }
        
        /* Back Button Styles */
        .back-button {
            background: #666;
            border: 2px solid #333;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: Arial, sans-serif;
            margin-top: 10px;
        }
        
        .back-button:hover {
            background: #333;
            border: 2px solid #666;
        }
        
        /* Dog Selection Styles */
        #dog-selection {
            background: rgba(255, 255, 255, 0.95);
            padding: 2rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            color: #333;
            border: 3px solid #00BFFF;
            max-width: 600px;
        }
        
        #dog-cards {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .dog-card {
            background: #f8f9fa;
            border: 3px solid #e9ecef;
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 160px;
            flex: 1;
            max-width: 180px;
        }
        
        .dog-card:hover {
            border-color: #00BFFF;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 191, 255, 0.3);
        }
        
        .dog-card.active {
            border-color: #00BFFF;
            background: rgba(0, 191, 255, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 191, 255, 0.4);
        }
        
        .dog-avatar {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }
        
        .dog-card h4 {
            font-size: 1.3rem;
            margin: 0.5rem 0;
            color: #00BFFF;
            font-family: 'Arial Black', Arial, sans-serif;
        }
        
        .dog-breed {
            font-size: 0.9rem;
            color: #666;
            margin: 0.25rem 0;
            font-style: italic;
        }
        
        .dog-description {
            font-size: 0.85rem;
            color: #333;
            margin: 0.5rem 0;
            line-height: 1.3;
        }
        
        .dog-stats {
            margin-top: 0.75rem;
            font-size: 0.75rem;
            text-align: left;
        }
        
        .stat {
            margin: 0.2rem 0;
            color: #555;
        }
        
        /* Mobile responsive dog selection */
        @media (max-width: 768px) {
            #dog-selection {
                padding: 1.5rem;
                margin-bottom: 1.5rem;
                max-width: 95%;
            }
            
            #dog-cards {
                gap: 10px;
            }
            
            .dog-card {
                min-width: 140px;
                padding: 0.8rem;
            }
            
            .dog-avatar {
                font-size: 2rem;
            }
            
            .dog-card h4 {
                font-size: 1.1rem;
            }
            
            .dog-breed {
                font-size: 0.8rem;
            }
            
            .dog-description {
                font-size: 0.8rem;
            }
            
            .dog-stats {
                font-size: 0.7rem;
            }
        }
        
        @media (max-width: 480px) {
            #dog-cards {
                flex-direction: column;
                align-items: center;
            }
            
            .dog-card {
                max-width: 280px;
                width: 100%;
            }
        }
        
        /* Room Form Styles */
        .room-form {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 8px;
            border: 3px solid #00BFFF;
            color: #333;
            margin-bottom: 20px;
            max-width: 400px;
        }
        
        .room-form label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        }
        
        .room-form input, .room-form select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
            margin-bottom: 15px;
            box-sizing: border-box;
        }
        
        .room-form input:focus, .room-form select:focus {
            border-color: #00BFFF;
            outline: none;
        }
        
        .checkbox-label {
            display: flex !important;
            align-items: center;
            cursor: pointer;
        }
        
        .checkbox-label input[type="checkbox"] {
            width: auto !important;
            margin-right: 8px;
            margin-bottom: 0 !important;
        }
        
        .room-privacy {
            margin-top: 10px;
        }
        
        .error-message {
            color: #F44336;
            font-size: 0.9rem;
            margin-top: -10px;
            margin-bottom: 15px;
        }
        
        /* Lobby Styles */
        #lobby-screen {
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 8px;
            border: 3px solid #00BFFF;
            color: #333;
            max-width: 500px;
            text-align: left;
        }
        
        #lobby-screen h3, #lobby-screen h4 {
            color: #00BFFF;
            margin-top: 0;
            text-align: center;
        }
        
        #room-info {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
        }
        
        #room-code-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        #current-room-code {
            color: #00BFFF;
            font-size: 1.2rem;
            font-weight: bold;
            letter-spacing: 2px;
        }
        
        .copy-button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s ease;
        }
        
        .copy-button:hover {
            background: #45a049;
        }
        
        .copy-button:active {
            background: #3d8b40;
        }
        
        #player-list {
            margin-bottom: 20px;
        }
        
        #players-container {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            min-height: 60px;
        }
        
        .player-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            margin-bottom: 5px;
            background: white;
            border-radius: 4px;
            border: 1px solid #eee;
        }
        
        .player-name {
            font-weight: bold;
            color: #333;
        }
        
        .player-status {
            font-size: 0.9rem;
            color: #666;
        }
        
        .player-host {
            background: #e3f2fd;
            border-color: #00BFFF;
        }
        
        .player-host .player-status::after {
            content: " (Host)";
            color: #00BFFF;
            font-weight: bold;
        }
        
        #lobby-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        
        .host-only {
            display: none;
        }
        
        .is-host .host-only {
            display: block;
        }
        
        #lobby-status {
            text-align: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        
        #lobby-message {
            color: #666;
            font-style: italic;
            margin: 0;
        }
        
        /* Mobile responsive room UI */
        @media (max-width: 768px) {
            .room-form {
                padding: 15px;
                max-width: 90%;
            }
            
            #lobby-screen {
                padding: 20px;
                max-width: 90%;
            }
            
            #room-code-display {
                flex-direction: column;
                gap: 8px;
            }
            
            #current-room-code {
                font-size: 1.1rem;
            }
        }
        
        @media (max-width: 480px) {
            .room-form {
                padding: 12px;
            }
            
            .room-form input, .room-form select {
                padding: 8px;
                font-size: 0.9rem;
            }
            
            #lobby-screen {
                padding: 15px;
            }
            
            .mode-button {
                min-width: 140px;
            }
        }
        
        /* Mute Toggle in Controls */
        #mute-toggle {
            margin: 5px 0;
            font-size: 14px;
            color: #333;
            cursor: pointer;
            user-select: none;
            transition: color 0.2s ease;
        }
        
        #mute-toggle:hover {
            color: #00BFFF;
        }
        
        #mute-toggle.muted {
            color: #FF6B35;
        }
        
        /* Game UI Elements - Clean style */
        .game-ui {
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .game-ui.visible {
            opacity: 1;
        }
        
        /* Stats hidden by default */
        #stats {
            display: none;
        }
        
        #stats.visible {
            display: block;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00BFFF;
            font-family: Arial, sans-serif;
            /* Mobile adjustments */
            max-width: calc(100vw - 160px);
            z-index: 999;
        }
        
        /* Mobile responsive instructions */
        @media (max-width: 768px) {
            #instructions {
                bottom: 10px;
                left: 10px;
                right: 10px;
                max-width: none;
                padding: 10px;
                font-size: 12px;
            }
            
            #instructions h3 {
                font-size: 14px;
                margin-bottom: 8px;
            }
            
            #instructions p {
                margin: 3px 0;
                font-size: 11px;
            }
        }
        
        #instructions h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #00BFFF;
            font-weight: 900;
        }
        
        #instructions p {
            margin: 5px 0;
            font-size: 14px;
            color: #333;
        }
        
        #completion-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            color: #333;
            padding: 30px 50px;
            border-radius: 8px;
            font-size: 24px;
            font-weight: 900;
            display: none;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            text-align: center;
            line-height: 1.4;
            border: 4px solid #00BFFF;
            font-family: 'Arial Black', Arial, sans-serif;
            z-index: 1002;
            max-width: 90vw;
            box-sizing: border-box;
        }
        
        /* Mobile responsive completion message */
        @media (max-width: 768px) {
            #completion-message {
                padding: 20px 30px;
                font-size: 18px;
            }
        }
        
        #restart-button {
            background: #00BFFF;
            border: 2px solid #333;
            color: white;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 900;
            cursor: pointer;
            margin-top: 15px;
            transition: all 0.2s ease;
            font-family: 'Arial Black', Arial, sans-serif;
            text-transform: uppercase;
            /* Mobile touch improvements */
            min-height: 44px;
            min-width: 44px;
        }
        
        #restart-button:hover {
            background: #333;
            border: 2px solid #00BFFF;
        }
        
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            border: 2px solid #00BFFF;
            font-family: Arial, sans-serif;
            font-weight: bold;
            color: #333;
            z-index: 999;
        }
        
        #timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 900;
            text-align: center;
            border: 2px solid #00BFFF;
            font-family: 'Arial Black', Arial, sans-serif;
            z-index: 999;
        }
        
        /* Combined mobile UI for timer and sheep count */
        #mobile-combined-ui {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 900;
            text-align: center;
            border: 2px solid #00BFFF;
            font-family: 'Arial Black', Arial, sans-serif;
            z-index: 999;
            display: none;
            min-width: 200px;
        }
        
        #mobile-timer-display {
            color: #00BFFF;
            font-size: 16px;
            margin-bottom: 2px;
        }
        
        #mobile-sheep-count {
            font-size: 12px;
            color: #333;
            margin-bottom: 2px;
        }
        
        #mobile-best-time {
            font-size: 10px;
            color: #666;
            font-weight: normal;
            font-family: Arial, sans-serif;
        }
        
        /* Mobile responsive timer */
        @media (max-width: 768px) {
            #timer {
                display: none; /* Hide desktop timer on mobile */
            }
            
            #stats {
                display: none !important; /* Hide desktop stats on mobile */
            }
            
            #mobile-combined-ui {
                display: block; /* Show combined UI on mobile */
            }
            
            #timer.desktop-only {
                top: 10px;
                padding: 10px 15px;
                font-size: 14px;
            }
            
            #timer-display {
                font-size: 16px;
            }
            
            #best-time {
                font-size: 10px;
            }
        }
        
        #timer-display {
            color: #00BFFF;
            margin-bottom: 5px;
            font-size: 20px;
        }
        
        #best-time {
            font-size: 12px;
            color: #666;
            font-weight: normal;
            font-family: Arial, sans-serif;
        }
        
        .new-record {
            color: #FF6B35 !important;
            animation: recordFlash 1s ease-in-out infinite alternate;
        }
        
        @keyframes recordFlash {
            from { opacity: 1; }
            to { opacity: 0.7; }
        }
        
        /* Stamina Bar */
        #stamina-bar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00BFFF;
            font-family: Arial, sans-serif;
            min-width: 200px;
            z-index: 999;
        }
        
        /* Mobile responsive stamina bar */
        @media (max-width: 768px) {
            #stamina-bar {
                bottom: 100px;
                left: 50%;
                transform: translateX(-50%);
                right: auto;
                min-width: 180px;
                padding: 8px 12px;
            }
            
            #stamina-label {
                font-size: 12px;
            }
            
            #stamina-container {
                height: 16px;
            }
            
            #stamina-text {
                font-size: 10px;
            }
        }
        
        /* Landscape mobile - ensure centered layout */
        @media (max-width: 768px) and (orientation: landscape) {
            #stamina-bar {
                bottom: 80px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                right: auto !important;
                min-width: 200px !important;
                padding: 8px 12px !important;
            }
            
            #mobile-combined-ui {
                display: block !important;
                top: 10px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                min-width: 280px !important;
                padding: 8px 20px !important;
                font-size: 12px !important;
            }
            
            /* Hide desktop timer and stats in landscape */
            #timer {
                display: none !important;
            }
            
            #stats {
                display: none !important;
            }
        }
        
        #stamina-label {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            text-align: center;
        }
        
        #stamina-container {
            width: 100%;
            height: 20px;
            background: #ddd;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #999;
            margin-bottom: 5px;
        }
        
        #stamina-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            border-radius: 10px;
            transition: width 0.2s ease, background 0.3s ease;
            width: 100%;
        }
        
        #stamina-fill.low {
            background: linear-gradient(90deg, #FF9800, #FFC107);
        }
        
        #stamina-fill.critical {
            background: linear-gradient(90deg, #F44336, #FF5722);
            animation: staminaPulse 0.5s ease-in-out infinite alternate;
        }
        
        #stamina-fill.sprinting {
            background: linear-gradient(90deg, #2196F3, #03A9F4);
            animation: staminaDrain 0.3s ease-in-out infinite alternate;
        }
        
        #stamina-text {
            font-size: 12px;
            color: #666;
            text-align: center;
            font-weight: bold;
        }
        
        @keyframes staminaPulse {
            from { opacity: 1; }
            to { opacity: 0.6; }
        }
        
        @keyframes staminaDrain {
            from { transform: scaleX(1); }
            to { transform: scaleX(0.98); }
        }
        
        /* Mobile Controls Styles */
        #mobile-joystick {
            pointer-events: auto !important;
        }
        
        #mobile-zoom {
            pointer-events: auto !important;
        }
        
        #mobile-sprint {
            pointer-events: auto !important;
        }
        
        /* Mobile Fullscreen Button */
        #mobile-fullscreen {
            position: fixed !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            width: 160px !important;
            height: 80px !important;
            border-radius: 12px !important;
            background: rgba(0, 191, 255, 0.95) !important;
            border: 3px solid white !important;
            color: white !important;
            font-size: 24px !important;
            font-weight: bold !important;
            z-index: 2000 !important;
            display: block !important;
            pointer-events: auto !important;
            box-shadow: 0 6px 12px rgba(0,0,0,0.4) !important;
            transition: all 0.3s ease !important;
            user-select: none !important;
            -webkit-user-select: none !important;
            -webkit-touch-callout: none !important;
            font-family: Arial, sans-serif !important;
            text-align: center !important;
            line-height: 1.2 !important;
            cursor: pointer !important;
            /* Ensure it's above everything */
            position: fixed !important;
        }
        
        #mobile-fullscreen:active {
            transform: translate(-50%, -50%) scale(0.95) !important;
            background: rgba(0, 150, 200, 0.95) !important;
        }
        
        /* Ensure mobile controls are above other UI elements */
        #mobile-joystick,
        #mobile-zoom,
        #mobile-sprint {
            z-index: 1001 !important;
        }
        
        /* Hide desktop-only UI elements on mobile */
        @media (max-width: 768px) and (pointer: coarse) {
            #instructions p:contains("Mouse Wheel"),
            #instructions p:contains("P") {
                display: none;
            }
            
            /* Ensure stats are completely hidden on mobile */
            #stats,
            #stats.visible,
            #stats.game-ui {
                display: none !important;
            }
        }
        
        /* Mobile device detection using is-mobile class */
        /* ALWAYS hide desktop HUD on a touch device */
        body.is-mobile #timer,
        body.is-mobile #stats {
            display: none !important;
        }
        
        body.is-mobile #mobile-combined-ui {
            display: block !important;
            top: calc(env(safe-area-inset-top, 0px) + 5px); /* Closer to top + safe area */
            min-width: auto; /* Allow to shrink */
            padding: 6px 12px; /* Smaller padding */
            border-radius: 6px; /* Smaller border radius */
        }
         
        body.is-mobile #mobile-combined-ui #mobile-timer-display {
            font-size: 14px; /* Smaller timer */
            margin-bottom: 1px;
        }
        
        body.is-mobile #mobile-combined-ui #mobile-sheep-count {
            font-size: 10px; /* Smaller sheep count */
            margin-bottom: 1px;
        }
        
        body.is-mobile #mobile-combined-ui #mobile-best-time {
            font-size: 9px; /* Smaller best time */
        }
        
        /* New Container-Based Mobile Layout */
        
        /* Mobile Left Stack - Portrait Mode (just joystick) */
        @media (max-width: 768px) and (orientation: portrait) {
            #mobile-left-stack {
                position: fixed;
                bottom: calc(env(safe-area-inset-bottom, 0px) + 20px);
                left: calc(env(safe-area-inset-left, 0px) + 20px);
                display: flex;
                flex-direction: column;
                gap: 12px;
                z-index: 1001;
            }
            
            /* Children use relative positioning within stack */
            #mobile-left-stack > * {
                position: relative !important;
                left: auto !important;
                bottom: auto !important;
                right: auto !important;
                top: auto !important;
            }
            
            /* Sprint button positioned independently on bottom-right in portrait */
            #mobile-sprint {
                position: fixed !important;
                bottom: calc(env(safe-area-inset-bottom, 0px) + 20px) !important;
                right: calc(env(safe-area-inset-right, 0px) + 20px) !important;
                left: auto !important;
                top: auto !important;
            }
            
            /* Stamina bar in portrait - bottom center with some clearance */
            body.is-mobile #stamina-bar {
                bottom: calc(env(safe-area-inset-bottom, 0px) + 30px) !important; /* Less space needed now */
                left: 50% !important;
                transform: translateX(-50%) !important;
                right: auto !important;
            }
        }
        
        /* Mobile HUD Right - Landscape Fullscreen */
        @media (max-width: 768px) and (orientation: landscape) {
            body.mobile-fullscreen #mobile-hud-right {
                position: fixed;
                top: calc(env(safe-area-inset-top, 0px) + 10px);
                right: calc(env(safe-area-inset-right, 0px) + 10px);
                display: flex;
                flex-direction: column;
                align-items: flex-end;
                gap: 6px;
                z-index: 1002;
            }
            
            body.mobile-fullscreen #mobile-hud-right #mobile-combined-ui,
            body.mobile-fullscreen #mobile-hud-right #stamina-bar {
                position: relative !important;
                left: auto !important;
                right: auto !important;
                top: auto !important;
                bottom: auto !important;
                transform: none !important;
                min-width: 180px;
            }
        }
        
        /* Default mobile stamina positioning (non-portrait) */
        body.is-mobile #stamina-bar {
            bottom: calc(env(safe-area-inset-bottom, 0px) + 10px);
            left: 50%;
            transform: translateX(-50%);
            right: auto;
            min-width: 150px;
            padding: 5px 10px;
            border-radius: 6px;
        }

        body.is-mobile #stamina-label {
            font-size: 10px;
            margin-bottom: 4px;
        }

        body.is-mobile #stamina-container {
            height: 12px;
            margin-bottom: 3px;
        }

        body.is-mobile #stamina-text {
            font-size: 9px;
        }

        /* Landscape orientation adjustments for mobile */
        @media (orientation: landscape) {
            body.is-mobile #stamina-bar {
                bottom: calc(env(safe-area-inset-bottom, 0px) + 5px) !important;
                min-width: 180px !important;
                padding: 4px 8px !important;
            }

            body.is-mobile #mobile-combined-ui {
                min-width: auto !important;
                padding: 5px 10px !important;
                font-size: 10px !important;
                border-radius: 6px !important;
            }
            body.is-mobile #mobile-combined-ui #mobile-timer-display {
                font-size: 12px !important;
            }
            body.is-mobile #mobile-combined-ui #mobile-sheep-count {
                font-size: 9px !important;
            }
            body.is-mobile #mobile-combined-ui #mobile-best-time {
                font-size: 8px !important;
            }
        }
        
        /* Multiplayer HUD Styles */
        #multiplayer-hud {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #4CAF50;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            min-width: 200px;
            z-index: 998;
        }
        
        #multiplayer-title {
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
            border-bottom: 1px solid #4CAF50;
            padding-bottom: 4px;
        }
        
        #multiplayer-players {
            margin-bottom: 8px;
        }
        
        .multiplayer-player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }
        
        .multiplayer-player:last-child {
            border-bottom: none;
        }
        
        .player-name {
            font-weight: bold;
        }
        
        .player-status {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            background: #4CAF50;
        }
        
        .player-status.host {
            background: #FF9800;
        }
        
        .player-status.you {
            background: #2196F3;
        }
        
        #connection-indicator {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            padding-top: 4px;
            border-top: 1px solid rgba(255,255,255,0.2);
        }
        
        #connection-icon {
            font-size: 12px;
        }
        
        #connection-icon.connected {
            color: #4CAF50;
        }
        
        #connection-icon.disconnected {
            color: #F44336;
        }
        
        #connection-icon.reconnecting {
            color: #FF9800;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Ping quality color coding */
        .ping-good {
            color: #4CAF50 !important;
        }
        
        .ping-ok {
            color: #FF9800 !important;
        }
        
        .ping-poor {
            color: #F44336 !important;
        }
        
        /* Mobile responsive multiplayer HUD */
        @media (max-width: 768px) {
            #multiplayer-hud {
                top: 60px;
                left: 10px;
                font-size: 10px;
                padding: 8px;
                min-width: 150px;
            }
            
            #multiplayer-title {
                font-size: 10px;
                margin-bottom: 6px;
            }
            
            .player-status {
                font-size: 8px;
                padding: 1px 4px;
            }
            
            #connection-indicator {
                font-size: 8px;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <!-- Start Screen Overlay -->
        <div id="start-screen">
            <h1 id="game-title">Sheep Dog Simulator</h1>
            <p id="game-subtitle">Guide 200 sheep to safety in this immersive 3D herding experience</p>
            
            <div id="start-instructions">
                <h3>How to Play</h3>
                <p>🐕 Use <strong>WASD</strong> or <strong>touch controls</strong> to move your sheepdog</p>
                <p>🏃 Hold <strong>Shift</strong> or <strong>sprint button</strong> to run faster</p>
                <p>🐑 Herd all 200 sheep through the golden gate into the pasture</p>
                <p>⏱️ Complete the challenge as quickly as possible</p>
                <p>🎯 Sheep will flee from you and flock together naturally</p>
                <p id="music-note" style="font-style: italic; color: #666; margin-top: 1rem;">🎵 Click anywhere to enable music</p>
            </div>
            
            <!-- Dog Selection -->
            <div id="dog-selection">
                <h3 style="color: #00BFFF; margin-bottom: 1rem; font-family: 'Arial Black', Arial, sans-serif;">Choose Your Dog</h3>
                <div id="dog-cards">
                    <div class="dog-card active" data-dog="jep">
                        <div class="dog-avatar">🐕‍🦺</div>
                        <h4>Jep</h4>
                        <p class="dog-breed">Border Collie</p>
                        <p class="dog-description">Balanced herding specialist</p>
                        <div class="dog-stats">
                            <div class="stat">Speed: ●●●○○</div>
                            <div class="stat">Stamina: ●●●○○</div>
                            <div class="stat">Range: ●●●○○</div>
                        </div>
                    </div>
                    <div class="dog-card" data-dog="rory">
                        <div class="dog-avatar">🐕</div>
                        <h4>Rory</h4>
                        <p class="dog-breed">Australian Shepherd</p>
                        <p class="dog-description">Powerful with extended range</p>
                        <div class="dog-stats">
                            <div class="stat">Speed: ●●●○○</div>
                            <div class="stat">Stamina: ●●○○○</div>
                            <div class="stat">Range: ●●●●●</div>
                        </div>
                    </div>
                    <div class="dog-card" data-dog="pip">
                        <div class="dog-avatar">🐶</div>
                        <h4>Pip</h4>
                        <p class="dog-breed">Corgi</p>
                        <p class="dog-description">Fast and agile, short range</p>
                        <div class="dog-stats">
                            <div class="stat">Speed: ●●●●○</div>
                            <div class="stat">Stamina: ●●●●○</div>
                            <div class="stat">Range: ●●○○○</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Main mode selection -->
            <div id="mode-selection">
                <button id="solo-button" class="mode-button">🐕 Play Solo</button>
                <button id="online-button" class="mode-button">👥 Play Online</button>
            </div>
            
            <!-- Online sub-options -->
            <div id="online-options" style="display: none;">
                <button id="create-room-button" class="mode-button">🏠 Create Room</button>
                <button id="join-room-button" class="mode-button">🔗 Join Room</button>
                <button id="quick-match-button" class="mode-button">⚡ Quick Match</button>
                <button id="back-to-main-button" class="back-button">← Back</button>
            </div>
            
            <!-- Room creation screen -->
            <div id="room-creation" style="display: none;">
                <h3>Create Room</h3>
                <div class="room-form">
                    <label for="room-name">Room Name (optional):</label>
                    <input type="text" id="room-name" placeholder="My Sheep Room" maxlength="20">
                    
                    <label for="max-players">Max Players:</label>
                    <select id="max-players">
                        <option value="2">2 Players</option>
                        <option value="3" selected>3 Players</option>
                        <option value="4">4 Players</option>
                    </select>
                    
                    <div class="room-privacy">
                        <label class="checkbox-label">
                            <input type="checkbox" id="private-room">
                            Private Room (friends only)
                        </label>
                    </div>
                </div>
                <button id="create-room-confirm" class="mode-button">Create Room</button>
                <button id="back-to-online-button" class="back-button">← Back</button>
            </div>
            
            <!-- Room joining screen -->
            <div id="room-joining" style="display: none;">
                <h3>Join Room</h3>
                <div class="room-form">
                    <label for="room-code">Enter Room Code:</label>
                    <input type="text" id="room-code" placeholder="ABC123" maxlength="6" style="text-transform: uppercase;">
                    <div id="code-error" class="error-message" style="display: none;">Invalid room code</div>
                </div>
                <button id="join-room-confirm" class="mode-button">Join Room</button>
                <button id="back-to-online-button2" class="back-button">← Back</button>
            </div>
            
            <!-- Lobby screen -->
            <div id="lobby-screen" style="display: none;">
                <div id="room-info">
                    <h3 id="lobby-room-name">Room: Sheep Herding</h3>
                    <div id="room-code-display">
                        <span>Room Code: <strong id="current-room-code">ABC123</strong></span>
                        <button id="copy-room-code" class="copy-button">📋 Copy</button>
                    </div>
                </div>
                
                <div id="player-list">
                    <h4>Players (<span id="player-count">1</span>/<span id="max-player-count">3</span>):</h4>
                    <div id="players-container">
                        <!-- Players will be dynamically added here -->
                    </div>
                </div>
                
                <div id="lobby-controls">
                    <button id="start-game-button" class="mode-button host-only" style="display: none;">🎮 Start Game</button>
                    <button id="leave-room-button" class="back-button">🚪 Leave Room</button>
                </div>
                
                <div id="lobby-status">
                    <p id="lobby-message">Waiting for players...</p>
                </div>
            </div>
            
            <!-- Connection status for multiplayer -->
            <div id="connection-status" style="display: none;">
                <p id="connection-message">Connecting to server...</p>
                <button id="back-to-menu-button" class="back-button">← Back to Menu</button>
            </div>
        </div>
        
        <!-- Mobile UI Containers -->
        <div id="mobile-left-stack">
            <!-- Sprint and joystick will be moved here by JS -->
        </div>
        
        <div id="mobile-hud-right">
            <!-- Combined UI and stamina bar will be grouped here by JS -->
        </div>
        
        <!-- Game UI Elements -->
        <div id="instructions" class="game-ui">
            <h3>Controls</h3>
            <p><strong>W</strong> - Move Forward</p>
            <p><strong>A</strong> - Move Left</p>
            <p><strong>S</strong> - Move Backward</p>
            <p><strong>D</strong> - Move Right</p>
            <p><strong>Shift</strong> - Sprint (uses stamina)</p>
            <p><strong>Mouse Wheel</strong> - Zoom In/Out</p>
            <p><strong>P</strong> - Toggle Performance Stats</p>
            <p id="mute-toggle">🔊 <strong>Click</strong> - Toggle Sound</p>
        </div>
        
        <div id="timer" class="game-ui">
            <div id="timer-display">00:00</div>
            <div id="best-time">Best: --:--</div>
        </div>
        
        <!-- Combined Mobile UI for timer and sheep count -->
        <div id="mobile-combined-ui" class="game-ui">
            <div id="mobile-timer-display">00:00</div>
            <div id="mobile-sheep-count">Sheep: 0 / 200</div>
            <div id="mobile-best-time">Best: --:--</div>
        </div>
        
        <div id="stats" class="game-ui">
            <p>Sheep Secured: <span id="sheep-count">0</span> / 200</p>
        </div>
        
        <div id="stamina-bar" class="game-ui">
            <div id="stamina-label">Stamina</div>
            <div id="stamina-container">
                <div id="stamina-fill"></div>
            </div>
            <div id="stamina-text">100%</div>
        </div>
        
        <!-- Multiplayer HUD for in-game player status -->
        <div id="multiplayer-hud" class="game-ui" style="display: none;">
            <div id="multiplayer-title">Players Online</div>
            <div id="multiplayer-players">
                <!-- Connected players will be shown here during gameplay -->
            </div>
            <div id="connection-indicator">
                <span id="connection-icon">🔗</span>
                <span id="ping-display">Ping: --ms</span>
            </div>
        </div>
        
        <div id="completion-message">
            All sheep successfully herded!
        </div>
    </div>
    
    <!-- Import map for Three.js r176 -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/",
            "stats.js": "https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js",
            "@geckos.io/client": "https://cdn.jsdelivr.net/npm/@geckos.io/client@3.0.2/+esm"
        }
    }
    </script>
    
    <!-- Main application entry point -->
    <script type="module" src="js/main.js"></script>
</body>
</html>
```

## js/AudioManager.js

```javascript
import * as THREE from 'three';

/**
 * AudioManager - Handles all game audio with Three.js audio system
 * Provides simple interface for playing sounds with proper 3D audio support
 */
export class AudioManager {
    constructor(camera) {
        // Create audio listener and attach to camera
        this.listener = new THREE.AudioListener();
        camera.add(this.listener);
        
        // Audio loader
        this.loader = new THREE.AudioLoader();
        
        // Audio objects for each sound
        this.sounds = {
            uiClick: null,
            rewardingChime: null,
            sheepBleat: null,
            sheepdogBark: null
        };
        
        // Music tracks
        this.music = {
            startMusic: null,
            gameplay1: null,
            gameplay2: null,
            gameplay3: null,
            winMusic: null
        };
        
        // Track loading state
        this.isLoaded = false;
        this.musicLoaded = false;
        this.loadingPromises = [];
        this.musicLoadingPromises = [];
        
        // Volume settings
        this.masterVolume = 0.7;
        this.sfxVolume = 0.8;
        this.musicVolume = 0.5;
        
        // Specific volume multipliers for different sound types
        this.soundVolumeMultipliers = {
            uiClick: 1.0,
            rewardingChime: 1.0,
            sheepBleat: 0.5,        // 50% lower than normal
            sheepdogBark: 0.5       // 50% lower than normal
        };
        
        // Mute state
        this.isMuted = false;
        this.currentMusic = null; // Track currently playing music
        
        // Cooldown tracking to prevent sound spam
        this.lastPlayTimes = {
            sheepBleat: 0,
            sheepdogBark: 0
        };
        this.cooldowns = {
            sheepBleat: 500, // 500ms cooldown
            sheepdogBark: 300 // 300ms cooldown
        };
        
        // Load mute preference from localStorage
        this.loadMutePreference();
        
        this.loadSounds();
        this.loadMusic();
    }
    
    /**
     * Load all sound files
     */
    loadSounds() {
        const soundFiles = {
            uiClick: 'assets/sounds/11L-clean_UI_click,_wood-1748393658157.mp3',
            rewardingChime: 'assets/sounds/11L-short_rewarding_chim-1748393597911.mp3',
            sheepBleat: 'assets/sounds/11L-agitated_sheep_bleat-1748393501154.mp3',
            sheepdogBark: 'assets/sounds/11L-short_sharp_sheep_do-1748393459422.mp3'
        };
        
        // Load each sound
        Object.keys(soundFiles).forEach(soundKey => {
            const promise = new Promise((resolve, reject) => {
                this.loader.load(
                    soundFiles[soundKey],
                    (buffer) => {
                        // Create Audio object
                        this.sounds[soundKey] = new THREE.Audio(this.listener);
                        this.sounds[soundKey].setBuffer(buffer);
                        
                        // Apply specific volume multiplier for this sound type
                        const volumeMultiplier = this.soundVolumeMultipliers[soundKey] || 1.0;
                        this.sounds[soundKey].setVolume(this.masterVolume * this.sfxVolume * volumeMultiplier);
                        
                        console.log(`Loaded sound: ${soundKey}`);
                        resolve();
                    },
                    (progress) => {
                        // Loading progress
                    },
                    (error) => {
                        console.warn(`Failed to load sound ${soundKey}:`, error);
                        // Create a dummy audio object to prevent errors
                        this.sounds[soundKey] = { 
                            play: () => {}, 
                            stop: () => {}, 
                            isPlaying: false 
                        };
                        resolve(); // Resolve anyway to not block other sounds
                    }
                );
            });
            
            this.loadingPromises.push(promise);
        });
        
        // Wait for all sounds to load
        Promise.all(this.loadingPromises).then(() => {
            this.isLoaded = true;
            console.log('All sounds loaded successfully');
        }).catch((error) => {
            console.warn('Some sounds failed to load:', error);
            this.isLoaded = true; // Still mark as loaded to allow game to continue
        });
    }
    
    /**
     * Load all music files
     */
    loadMusic() {
        const musicFiles = {
            startMusic: 'assets/sounds/SDS Start Music.wav',
            gameplay1: 'assets/sounds/SDS1.wav',
            gameplay2: 'assets/sounds/SDS2.wav',
            gameplay3: 'assets/sounds/SDS3.wav',
            winMusic: 'assets/sounds/win.wav'
        };
        
        // Load each music track
        Object.keys(musicFiles).forEach(musicKey => {
            const promise = new Promise((resolve, reject) => {
                this.loader.load(
                    musicFiles[musicKey],
                    (buffer) => {
                        // Create Audio object
                        this.music[musicKey] = new THREE.Audio(this.listener);
                        this.music[musicKey].setBuffer(buffer);
                        this.music[musicKey].setVolume(this.masterVolume * this.musicVolume);
                        this.music[musicKey].setLoop(true); // Most music should loop
                        
                        console.log(`Loaded music: ${musicKey}`);
                        resolve();
                    },
                    (progress) => {
                        // Loading progress
                        console.log(`Loading music ${musicKey}: ${Math.round(progress.loaded / progress.total * 100)}%`);
                    },
                    (error) => {
                        console.warn(`Failed to load music ${musicKey}:`, error);
                        // Create a dummy audio object to prevent errors
                        this.music[musicKey] = { 
                            play: () => {}, 
                            stop: () => {}, 
                            pause: () => {},
                            setLoop: () => {},
                            setVolume: () => {},
                            isPlaying: false 
                        };
                        resolve(); // Resolve anyway to not block other music
                    }
                );
            });
            
            this.musicLoadingPromises.push(promise);
        });
        
        // Wait for all music to load
        Promise.all(this.musicLoadingPromises).then(() => {
            this.musicLoaded = true;
            console.log('All music loaded successfully');
            
            // Apply mute state to music
            this.updateAllVolumes();
            
            // Set up user interaction listener to start audio context
            this.setupAudioContextActivation();
        }).catch((error) => {
            console.warn('Some music failed to load:', error);
            this.musicLoaded = true; // Still mark as loaded to allow game to continue
        });
    }
    
    /**
     * Play UI click sound
     */
    playUIClick() {
        if (this.sounds.uiClick && !this.sounds.uiClick.isPlaying) {
            this.sounds.uiClick.play();
        }
    }
    
    /**
     * Play rewarding chime sound (for sheep passing gate or game completion)
     */
    playRewardingChime() {
        if (this.sounds.rewardingChime && !this.sounds.rewardingChime.isPlaying) {
            this.sounds.rewardingChime.play();
        }
    }
    
    /**
     * Play sheep bleat sound with cooldown to prevent spam
     */
    playSheepBleat() {
        const now = Date.now();
        if (now - this.lastPlayTimes.sheepBleat < this.cooldowns.sheepBleat) {
            return; // Still in cooldown
        }
        
        if (this.sounds.sheepBleat && !this.sounds.sheepBleat.isPlaying) {
            this.sounds.sheepBleat.play();
            this.lastPlayTimes.sheepBleat = now;
        }
    }
    
    /**
     * Play multiple layered sheep bleats for group herding
     * @param {number} sheepCount - Number of sheep being chased (1-5 max for audio clarity)
     */
    playGroupSheepBleats(sheepCount) {
        const now = Date.now();
        if (now - this.lastPlayTimes.sheepBleat < this.cooldowns.sheepBleat) {
            return; // Still in cooldown
        }
        
        // Limit to 5 simultaneous bleats for audio clarity
        const maxBleats = Math.min(sheepCount, 5);
        
        // Play first bleat immediately
        if (this.sounds.sheepBleat) {
            this.sounds.sheepBleat.play();
        }
        
        // Schedule additional bleats with staggered timing
        for (let i = 1; i < maxBleats; i++) {
            setTimeout(() => {
                if (this.sounds.sheepBleat) {
                    // Create a new audio instance for overlapping sounds
                    const additionalBleat = new THREE.Audio(this.listener);
                    additionalBleat.setBuffer(this.sounds.sheepBleat.buffer);
                    
                    // Apply the same volume multiplier as the main sheep bleat sound
                    const baseVolume = this.isMuted ? 0 : this.masterVolume * this.sfxVolume;
                    const volumeMultiplier = this.soundVolumeMultipliers.sheepBleat || 1.0;
                    const finalVolume = baseVolume * volumeMultiplier * (0.7 + Math.random() * 0.3); // Slight volume variation
                    
                    additionalBleat.setVolume(finalVolume);
                    additionalBleat.play();
                }
            }, i * (100 + Math.random() * 150)); // 100-250ms staggered delays
        }
        
        this.lastPlayTimes.sheepBleat = now;
    }
    
    /**
     * Play sheepdog bark sound with cooldown
     */
    playSheepdogBark() {
        const now = Date.now();
        if (now - this.lastPlayTimes.sheepdogBark < this.cooldowns.sheepdogBark) {
            return; // Still in cooldown
        }
        
        if (this.sounds.sheepdogBark && !this.sounds.sheepdogBark.isPlaying) {
            this.sounds.sheepdogBark.play();
            this.lastPlayTimes.sheepdogBark = now;
        }
    }
    
    /**
     * Play start screen music
     */
    playStartMusic() {
        if (this.music.startMusic && !this.music.startMusic.isPlaying) {
            this.stopAllMusic();
            this.currentMusic = this.music.startMusic;
            this.music.startMusic.play();
        }
    }
    
    /**
     * Play random gameplay background music
     */
    playGameplayMusic() {
        const gameplayTracks = [this.music.gameplay1, this.music.gameplay2, this.music.gameplay3];
        const randomTrack = gameplayTracks[Math.floor(Math.random() * gameplayTracks.length)];
        
        if (randomTrack && !randomTrack.isPlaying) {
            this.stopAllMusic();
            this.currentMusic = randomTrack;
            randomTrack.play();
        }
    }
    
    /**
     * Play win music (doesn't loop)
     */
    playWinMusic() {
        if (this.music.winMusic) {
            this.stopAllMusic();
            this.currentMusic = this.music.winMusic;
            this.music.winMusic.setLoop(false); // Win music plays once
            this.music.winMusic.play();
        }
    }
    
    /**
     * Stop all music
     */
    stopAllMusic() {
        Object.values(this.music).forEach(track => {
            if (track && track.isPlaying) {
                track.stop();
            }
        });
        this.currentMusic = null;
    }
    
    /**
     * Fade out current music (smooth transition)
     */
    fadeOutCurrentMusic(duration = 1000) {
        if (!this.currentMusic || !this.currentMusic.isPlaying) return;
        
        const startVolume = this.currentMusic.getVolume();
        const fadeSteps = 20;
        const stepDuration = duration / fadeSteps;
        const volumeStep = startVolume / fadeSteps;
        
        let currentStep = 0;
        const fadeInterval = setInterval(() => {
            currentStep++;
            const newVolume = startVolume - (volumeStep * currentStep);
            
            if (currentStep >= fadeSteps || newVolume <= 0) {
                this.currentMusic.stop();
                this.currentMusic.setVolume(startVolume); // Reset volume for next play
                this.currentMusic = null;
                clearInterval(fadeInterval);
            } else {
                this.currentMusic.setVolume(newVolume);
            }
        }, stepDuration);
    }
    
    /**
     * Set master volume (0.0 to 1.0)
     */
    setMasterVolume(volume) {
        this.masterVolume = Math.max(0, Math.min(1, volume));
        this.updateAllVolumes();
    }
    
    /**
     * Set SFX volume (0.0 to 1.0)
     */
    setSFXVolume(volume) {
        this.sfxVolume = Math.max(0, Math.min(1, volume));
        this.updateAllVolumes();
    }
    
    /**
     * Set music volume (0.0 to 1.0)
     */
    setMusicVolume(volume) {
        this.musicVolume = Math.max(0, Math.min(1, volume));
        this.updateAllVolumes();
    }
    
    /**
     * Toggle mute state
     */
    toggleMute() {
        this.isMuted = !this.isMuted;
        
        // Stop all currently playing sounds when muting
        if (this.isMuted) {
            this.stopAllSounds();
            this.stopAllMusic();
        }
        
        this.updateAllVolumes();
        this.saveMutePreference();
        return this.isMuted;
    }
    
    /**
     * Set mute state
     */
    setMuted(muted) {
        this.isMuted = muted;
        
        // Stop all currently playing sounds when muting
        if (this.isMuted) {
            this.stopAllSounds();
            this.stopAllMusic();
        }
        
        this.updateAllVolumes();
        this.saveMutePreference();
    }
    
    /**
     * Get current mute state
     */
    isMutedState() {
        return this.isMuted;
    }
    
    /**
     * Load mute preference from localStorage
     */
    loadMutePreference() {
        try {
            const saved = localStorage.getItem('sheepdog-muted');
            if (saved !== null) {
                this.isMuted = JSON.parse(saved);
            }
        } catch (error) {
            console.warn('Failed to load mute preference:', error);
            this.isMuted = false;
        }
    }
    
    /**
     * Save mute preference to localStorage
     */
    saveMutePreference() {
        try {
            localStorage.setItem('sheepdog-muted', JSON.stringify(this.isMuted));
        } catch (error) {
            console.warn('Failed to save mute preference:', error);
        }
    }
    
    /**
     * Update volume for all loaded sounds and music
     */
    updateAllVolumes() {
        const effectiveVolume = this.isMuted ? 0 : this.masterVolume;
        const baseSFXVolume = effectiveVolume * this.sfxVolume;
        const finalMusicVolume = effectiveVolume * this.musicVolume;
        
        // Update sound effects with specific volume multipliers
        Object.keys(this.sounds).forEach(soundKey => {
            const sound = this.sounds[soundKey];
            if (sound && sound.setVolume) {
                const volumeMultiplier = this.soundVolumeMultipliers[soundKey] || 1.0;
                sound.setVolume(baseSFXVolume * volumeMultiplier);
            }
        });
        
        // Update music
        Object.values(this.music).forEach(track => {
            if (track && track.setVolume) {
                track.setVolume(finalMusicVolume);
            }
        });
    }
    
    /**
     * Stop all currently playing sounds
     */
    stopAllSounds() {
        Object.values(this.sounds).forEach(sound => {
            if (sound && sound.isPlaying) {
                sound.stop();
            }
        });
    }
    
    /**
     * Check if audio system is ready
     */
    isReady() {
        return this.isLoaded;
    }
    
    /**
     * Check if music system is ready
     */
    isMusicReady() {
        return this.musicLoaded;
    }
    
    /**
     * Set up audio context activation on user interaction
     */
    setupAudioContextActivation() {
        this.audioContextActivated = false;
        
        const activateAudio = (event) => {
            if (this.listener.context.state === 'suspended') {
                this.listener.context.resume().then(() => {
                    console.log('Audio context activated');
                    this.audioContextActivated = true;
                    
                    // Only start music if this wasn't the start button click
                    const isStartButton = event.target && (
                        event.target.id === 'start-button' || 
                        event.target.closest('#start-button')
                    );
                    
                    if (this.musicLoaded && !this.currentMusic && !isStartButton) {
                        this.playStartMusic();
                    }
                });
            } else {
                this.audioContextActivated = true;
            }
            
            // Remove listeners after first activation
            document.removeEventListener('click', activateAudio);
            document.removeEventListener('keydown', activateAudio);
        };
        
        // Listen for any user interaction
        document.addEventListener('click', activateAudio);
        document.addEventListener('keydown', activateAudio);
    }
    
    /**
     * Manually trigger start music (for delayed start)
     */
    triggerStartMusic() {
        if (this.musicLoaded && !this.currentMusic && this.audioContextActivated) {
            this.playStartMusic();
        }
    }
    
    /**
     * Get audio context state (for debugging)
     */
    getAudioContextState() {
        return this.listener.context.state;
    }
}
```

## js/Boid.js

```javascript
import { Vector2D } from './Vector2D.js';

/**
 * Base Boid class implementing flocking behavior
 */
export class Boid {
    constructor(x, z, config = {}) {
        this.position = new Vector2D(x, z);
        this.velocity = Vector2D.random();
        this.acceleration = new Vector2D(0, 0);
        
        // Configuration
        this.maxSpeed = config.maxSpeed || 1.5;
        this.maxForce = config.maxForce || 0.05;
        this.perceptionRadius = config.perceptionRadius || 5;
        
        // Behavior weights
        this.separationWeight = config.separationWeight || 1.5;
        this.alignmentWeight = config.alignmentWeight || 1.0;
        this.cohesionWeight = config.cohesionWeight || 1.0;
        
        // Anti-jittering properties
        this.previousVelocity = this.velocity.clone();
        this.velocitySmoothing = 0.85; // Higher = more smoothing
        this.minMovementThreshold = 0.001; // Minimum velocity to prevent micro-movements
        this.forceAccumulator = new Vector2D(0, 0);
        this.dampingFactor = 0.98; // Velocity damping to reduce oscillations
        
        // Visual representation
        this.mesh = null;
    }

    // Apply a force to the boid with smoothing
    applyForce(force) {
        // Accumulate forces instead of applying directly
        this.forceAccumulator.add(force);
    }

    // Main flocking behavior
    flock(boids, separationDistance) {
        const neighbors = this.getNeighbors(boids);
        
        if (neighbors.length > 0) {
            // Calculate flocking forces
            const separation = this.separate(neighbors, separationDistance);
            const alignment = this.align(neighbors);
            const cohesion = this.cohere(neighbors);
            
            // Weight and apply forces
            separation.multiply(this.separationWeight);
            alignment.multiply(this.alignmentWeight);
            cohesion.multiply(this.cohesionWeight);
            
            this.applyForce(separation);
            this.applyForce(alignment);
            this.applyForce(cohesion);
        }
    }

    // Separation: steer to avoid crowding local flockmates
    separate(neighbors, desiredSeparation) {
        const steer = new Vector2D(0, 0);
        let count = 0;

        for (let neighbor of neighbors) {
            const distance = this.position.distanceTo(neighbor.position);
            
            if (distance > 0 && distance < desiredSeparation) {
                // Calculate vector pointing away from neighbor
                const diff = this.position.clone().subtract(neighbor.position);
                diff.normalize();
                diff.divide(distance); // Weight by distance (closer = stronger)
                steer.add(diff);
                count++;
            }
        }

        if (count > 0) {
            steer.divide(count);
            steer.normalize();
            steer.multiply(this.maxSpeed);
            steer.subtract(this.velocity);
            steer.limit(this.maxForce);
        }

        return steer;
    }

    // Alignment: steer towards the average heading of local flockmates
    align(neighbors) {
        const sum = new Vector2D(0, 0);
        
        for (let neighbor of neighbors) {
            sum.add(neighbor.velocity);
        }
        
        sum.divide(neighbors.length);
        sum.normalize();
        sum.multiply(this.maxSpeed);
        
        const steer = sum.subtract(this.velocity);
        steer.limit(this.maxForce);
        
        return steer;
    }

    // Cohesion: steer to move toward the average position of local flockmates
    cohere(neighbors) {
        const sum = new Vector2D(0, 0);
        
        for (let neighbor of neighbors) {
            sum.add(neighbor.position);
        }
        
        sum.divide(neighbors.length);
        return this.seek(sum);
    }

    // Seek a target position
    seek(target) {
        const desired = target.clone().subtract(this.position);
        desired.normalize();
        desired.multiply(this.maxSpeed);
        
        const steer = desired.subtract(this.velocity);
        steer.limit(this.maxForce);
        
        return steer;
    }

    // Flee from a target position
    flee(target, fleeRadius = 10) {
        const distance = this.position.distanceTo(target);
        
        if (distance < fleeRadius) {
            const desired = this.position.clone().subtract(target);
            desired.normalize();
            desired.multiply(this.maxSpeed);
            
            const steer = desired.subtract(this.velocity);
            steer.limit(this.maxForce * 2); // Stronger flee force
            
            return steer;
        }
        
        return new Vector2D(0, 0);
    }

    // Boundary avoidance
    avoidBoundaries(bounds) {
        const margin = 10; // Increased margin for earlier activation
        const steer = new Vector2D(0, 0);
        const position = this.position;
        
        // Calculate distances to boundaries
        const distToMinX = position.x - bounds.minX;
        const distToMaxX = bounds.maxX - position.x;
        const distToMinZ = position.z - bounds.minZ;
        const distToMaxZ = bounds.maxZ - position.z;
        
        // Apply repulsion force based on proximity to boundary (reduced multipliers)
        if (distToMinX < margin) {
            const force = (margin - distToMinX) / margin;
            steer.x = this.maxSpeed * force * 1.2; // Reduced from 2
        } else if (distToMaxX < margin) {
            const force = (margin - distToMaxX) / margin;
            steer.x = -this.maxSpeed * force * 1.2;
        }
        
        if (distToMinZ < margin) {
            const force = (margin - distToMinZ) / margin;
            steer.z = this.maxSpeed * force * 1.2;
        } else if (distToMaxZ < margin) {
            const force = (margin - distToMaxZ) / margin;
            steer.z = -this.maxSpeed * force * 1.2;
        }
        
        if (steer.magnitude() > 0) {
            steer.normalize();
            steer.multiply(this.maxSpeed * 1.5); // Reduced from 2
            steer.subtract(this.velocity);
            steer.limit(this.maxForce * 2.5); // Reduced from 5
        }
        
        return steer;
    }

    // Get neighboring boids within perception radius
    getNeighbors(boids) {
        const neighbors = [];
        
        for (let boid of boids) {
            if (boid !== this) {
                const distance = this.position.distanceTo(boid.position);
                if (distance < this.perceptionRadius) {
                    neighbors.push(boid);
                }
            }
        }
        
        return neighbors;
    }

    // Update position based on velocity and acceleration
    update(deltaTime = 0.016) {
        // Apply accumulated forces to acceleration with damping
        this.acceleration.add(this.forceAccumulator);
        this.forceAccumulator.multiply(0); // Reset force accumulator
        
        // Store previous velocity for smoothing
        this.previousVelocity = this.velocity.clone();
        
        // Update velocity
        this.velocity.add(this.acceleration);
        this.velocity.limit(this.maxSpeed);
        
        // Apply velocity damping to reduce oscillations
        this.velocity.multiply(this.dampingFactor);
        
        // Smooth velocity with previous velocity to reduce jittering
        const smoothedVelocity = this.previousVelocity.clone()
            .multiply(this.velocitySmoothing)
            .add(this.velocity.clone().multiply(1 - this.velocitySmoothing));
        
        // Only apply movement if above threshold to prevent micro-movements
        if (smoothedVelocity.magnitude() > this.minMovementThreshold) {
            this.velocity = smoothedVelocity;
            this.position.add(this.velocity);
        } else {
            // Stop micro-movements
            this.velocity.multiply(0);
        }
        
        // Reset acceleration
        this.acceleration.multiply(0);
        
        // Update mesh position if it exists
        if (this.mesh) {
            this.mesh.position.x = this.position.x;
            this.mesh.position.z = this.position.z;
            
            // Rotate mesh to face movement direction (only if moving significantly)
            if (this.velocity.magnitude() > this.minMovementThreshold * 10) {
                this.mesh.rotation.y = -this.velocity.angle() + Math.PI / 2;
            }
        }
    }
}
```

## js/GameState.js

```javascript
import { Vector2D } from './Vector2D.js';
import { OptimizedSheepSystem } from './OptimizedSheep.js';

/**
 * GameState - Handles game configuration, boundaries, and state management
 */
export class GameState {
    constructor() {
        // Field boundaries
        this.bounds = {
            minX: -100,
            maxX: 100,
            minZ: -100,
            maxZ: 100
        };
        
        // Gate and pasture configuration
        this.gate = {
            position: new Vector2D(0, 100), // At the fence border
            width: 8,
            height: 4,
            // Gate passage zone (invisible box for detection)
            passageZone: {
                minX: -4,
                maxX: 4,
                minZ: 98,
                maxZ: 102
            }
        };
        
        // Sleeping pasture area (beyond the gate)
        this.pasture = {
            centerZ: 115, // Beyond the gate
            minX: -30,
            maxX: 30,
            minZ: 102,
            maxZ: 130
        };
        
        // Simulation parameters
        this.params = {
            speed: 0.1,  // Sheep movement speed
            cohesion: 1.0,
            separationDistance: 2.0
        };
        
        // Game state
        this.sheep = [];
        this.sheepdog = null;
        this.sheepRetired = 0;
        this.gameCompleted = false;
        this.totalSheep = 200;
        this.gameActive = false; // New: tracks if game is actively being played
        this.isPaused = false; // New: tracks if game is paused
        this.audioManager = null;
        
        // Always use optimized sheep system
        this.optimizedSheepSystem = null;
    }
    
    createSheepFlock(scene) {
        // Create optimized sheep system
        this.optimizedSheepSystem = new OptimizedSheepSystem(scene, this.totalSheep);
        this.sheep = this.optimizedSheepSystem.getSheep();
        
        // Set bounds for each sheep instance
        this.sheep.forEach(sheep => sheep.setBounds(this.bounds));
        
        // Set audio manager if available
        if (this.audioManager) {
            this.optimizedSheepSystem.setAudioManager(this.audioManager);
        }
        
        return null; // No individual meshes to return
    }
    
    setPaused(paused) {
        this.isPaused = paused;
    }
    
    isPausedState() {
        return this.isPaused;
    }
    
    updateSheepBehaviors(deltaTime = 0.016) {
        // Don't update sheep behaviors if paused
        if (this.isPaused) {
            return this.sheepRetired;
        }
        
        // Always update sheep behaviors for visual effect
        // In multiplayer mode, server handles state transitions, client handles visual behavior
        this.optimizedSheepSystem.update(
            deltaTime,
            this.gameActive ? this.sheepdog : null, // Only pass sheepdog if game is active
            this.gameActive ? this.gate : null,     // Only enable gate mechanics if game is active
            this.gameActive ? this.pasture : null,  // Only enable pasture mechanics if game is active
            this.bounds,  // Always pass bounds so sheep stay in field
            this.params,  // Always pass params so sheep can flock
            true, // enableIndividualBleating
            this.gameMode === 'multiplayer' // isMultiplayer flag
        );
        
        // Only count retired sheep if game is active
        if (this.gameActive) {
            // In multiplayer mode, sheep count is managed by server
            if (this.gameMode !== 'multiplayer') {
                this.sheepRetired = 0;
                
                // Count retired sheep
                for (let sheep of this.sheep) {
                    // Check if sheep has passed gate
                    if (!sheep.hasPassedGate && !sheep.isRetiring) {
                        if (sheep.checkGatePassageAndRetire(this.gate.passageZone, this.pasture)) {
                            // Sheep just passed through the gate
                            this.sheepRetired++;
                            
                            // Play rewarding chime sound
                            if (this.audioManager) {
                                this.audioManager.playRewardingChime();
                            }
                        }
                    }
                    
                    // Count all sheep that have passed or are retiring
                    if (sheep.hasPassedGate || sheep.isRetiring) {
                        this.sheepRetired++;
                    }
                }
            }
        }
        
        return this.sheepRetired;
    }
    
    checkCompletion() {
        // Only check completion if game is active and not paused
        if (!this.gameActive || this.isPaused) return false;
        
        if (this.sheepRetired === this.sheep.length && !this.gameCompleted) {
            this.gameCompleted = true;
            
            // Play completion sound and win music
            if (this.audioManager) {
                this.audioManager.playRewardingChime();
                
                // Stop gameplay music and start win music
                setTimeout(() => {
                    this.audioManager.stopAllMusic();
                    this.audioManager.playWinMusic();
                }, 500); // Small delay for the chime to play
            }
            
            return true;
        }
        return false;
    }
    
    updateUI() {
        // Only update UI if game is active and not paused
        if (!this.gameActive || this.isPaused) return;
        
        // Update desktop sheep count
        const sheepCountElement = document.getElementById('sheep-count');
        if (sheepCountElement) {
            sheepCountElement.textContent = this.sheepRetired;
        }
        
        // Update mobile sheep count
        const mobileSheepCountElement = document.getElementById('mobile-sheep-count');
        if (mobileSheepCountElement) {
            mobileSheepCountElement.textContent = `Sheep: ${this.sheepRetired} / ${this.totalSheep}`;
        }
    }
    
    showCompletionMessage(finalTime, isNewRecord) {
        let message = 'All sheep have been guided to the pasture!';
        
        if (finalTime !== null) {
            const timeStr = this.formatTime(finalTime);
            message += `\nTime: ${timeStr}`;
            
            if (isNewRecord) {
                message += '\n🎉 NEW BEST TIME! 🎉';
            }
        }
        
        const completionElement = document.getElementById('completion-message');
        if (completionElement) {
            completionElement.innerHTML = 
                message.replace(/\n/g, '<br>') + '<br><button id="restart-button">Play Again</button>';
            completionElement.style.display = 'block';
            
            // Add event listener for restart button
            const restartButton = document.getElementById('restart-button');
            if (restartButton) {
                restartButton.addEventListener('click', () => {
                    // Trigger a full restart to start screen
                    location.reload();
                });
            }
        }
    }
    
    formatTime(timeInSeconds) {
        const minutes = Math.floor(timeInSeconds / 60);
        const seconds = Math.floor(timeInSeconds % 60);
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    
    // Getters
    getBounds() {
        return this.bounds;
    }
    
    getGate() {
        return this.gate;
    }
    
    getPasture() {
        return this.pasture;
    }
    
    getParams() {
        return this.params;
    }
    
    getSheep() {
        return this.sheep;
    }
    
    getSheepdog() {
        return this.sheepdog;
    }
    
    setSheepdog(sheepdog) {
        this.sheepdog = sheepdog;
    }
    
    getSheepRetired() {
        return this.sheepRetired;
    }
    
    getTotalSheep() {
        return this.totalSheep;
    }
    
    isGameCompleted() {
        return this.gameCompleted;
    }
    
    startGame(mode = 'solo') {
        this.gameMode = mode; // Store the game mode
        this.gameActive = true;
        this.gameCompleted = false;
        this.sheepRetired = 0;
        this.isPaused = false; // Ensure game starts unpaused
        
        // Reset all sheep to their starting positions and states
        if (this.optimizedSheepSystem) {
            this.optimizedSheepSystem.resetAllSheep();
        }
        
        if (mode === 'multiplayer') {
            console.log('Game started in multiplayer mode with 200 sheep');
        }
    }
    
    isGameActive() {
        return this.gameActive;
    }
    
    setAudioManager(audioManager) {
        this.audioManager = audioManager;
        
        // If sheep system already exists, pass audio manager to it
        if (this.optimizedSheepSystem) {
            this.optimizedSheepSystem.setAudioManager(audioManager);
        }
    }
    
    reset() {
        this.sheep = [];
        this.sheepdog = null;
        this.sheepRetired = 0;
        this.gameCompleted = false;
        this.gameActive = false;
        this.isPaused = false;
        this.optimizedSheepSystem = null;
    }
}
```

## js/GameTimer.js

```javascript
/**
 * GameTimer - Handles timer functionality and best time tracking
 */
export class GameTimer {
    constructor() {
        this.startTime = null;
        this.currentTime = 0;
        this.timerRunning = false;
        this.isPaused = false;
        this.pausedTime = 0; // Total time spent paused
        this.pauseStartTime = null;
        this.bestTime = this.loadBestTime();
        
        this.initializeTimer();
    }
    
    initializeTimer() {
        this.updateTimerDisplay();
        this.updateBestTimeDisplay();
    }
    
    start() {
        if (!this.timerRunning) {
            this.startTime = performance.now();
            this.timerRunning = true;
            this.pausedTime = 0; // Reset paused time when starting
        }
    }
    
    stop() {
        if (this.timerRunning) {
            this.timerRunning = false;
            this.isPaused = false; // Clear pause state when stopping
            this.pauseStartTime = null;
            
            const finalTime = this.currentTime;
            
            // Check if this is a new best time
            if (this.bestTime === null || finalTime < this.bestTime) {
                this.bestTime = finalTime;
                this.saveBestTime(this.bestTime);
                this.updateBestTimeDisplay();
                this.showNewRecordAnimation();
            }
            
            return finalTime;
        }
        return null;
    }
    
    pause() {
        if (this.timerRunning && !this.isPaused) {
            this.isPaused = true;
            this.pauseStartTime = performance.now();
        }
    }
    
    resume() {
        if (this.timerRunning && this.isPaused) {
            this.isPaused = false;
            if (this.pauseStartTime !== null) {
                this.pausedTime += performance.now() - this.pauseStartTime;
                this.pauseStartTime = null;
            }
        }
    }
    
    setPaused(paused) {
        if (paused) {
            this.pause();
        } else {
            this.resume();
        }
    }
    
    update() {
        if (this.timerRunning && this.startTime !== null && !this.isPaused) {
            const currentPausedTime = this.pauseStartTime !== null ? 
                this.pausedTime + (performance.now() - this.pauseStartTime) : 
                this.pausedTime;
            
            this.currentTime = (performance.now() - this.startTime - currentPausedTime) / 1000; // Convert to seconds
            this.updateTimerDisplay();
        }
    }
    
    updateTimerDisplay() {
        const timeToDisplay = this.timerRunning ? this.currentTime : 0;
        const minutes = Math.floor(timeToDisplay / 60);
        const seconds = Math.floor(timeToDisplay % 60);
        const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        // Update desktop timer
        const timerElement = document.getElementById('timer-display');
        if (timerElement) {
            timerElement.textContent = formattedTime;
            
            // Add visual indication when paused
            if (this.isPaused && this.timerRunning) {
                timerElement.style.opacity = '0.6';
                timerElement.style.color = '#ffaa00';
            } else {
                timerElement.style.opacity = '1';
                timerElement.style.color = '';
            }
        }
        
        // Update mobile timer
        const mobileTimerElement = document.getElementById('mobile-timer-display');
        if (mobileTimerElement) {
            mobileTimerElement.textContent = formattedTime;
            
            // Add visual indication when paused
            if (this.isPaused && this.timerRunning) {
                mobileTimerElement.style.opacity = '0.6';
                mobileTimerElement.style.color = '#ffaa00';
            } else {
                mobileTimerElement.style.opacity = '1';
                mobileTimerElement.style.color = '';
            }
        }
    }
    
    updateBestTimeDisplay() {
        const bestTimeText = this.bestTime !== null ? 
            `Best: ${this.formatTime(this.bestTime)}` : 
            'Best: --:--';
        
        // Update desktop best time
        const bestTimeElement = document.getElementById('best-time');
        if (bestTimeElement) {
            bestTimeElement.textContent = bestTimeText;
        }
        
        // Update mobile best time
        const mobileBestTimeElement = document.getElementById('mobile-best-time');
        if (mobileBestTimeElement) {
            mobileBestTimeElement.textContent = bestTimeText;
        }
    }
    
    showNewRecordAnimation() {
        // Animate desktop element
        const bestTimeElement = document.getElementById('best-time');
        if (bestTimeElement) {
            bestTimeElement.classList.add('new-record');
            setTimeout(() => {
                bestTimeElement.classList.remove('new-record');
            }, 3000);
        }
        
        // Animate mobile element
        const mobileBestTimeElement = document.getElementById('mobile-best-time');
        if (mobileBestTimeElement) {
            mobileBestTimeElement.classList.add('new-record');
            setTimeout(() => {
                mobileBestTimeElement.classList.remove('new-record');
            }, 3000);
        }
    }
    
    loadBestTime() {
        try {
            const saved = localStorage.getItem('sheepdog-best-time');
            return saved ? parseFloat(saved) : null;
        } catch (error) {
            console.warn('Could not load best time from localStorage:', error);
            return null;
        }
    }
    
    saveBestTime(time) {
        try {
            localStorage.setItem('sheepdog-best-time', time.toString());
        } catch (error) {
            console.warn('Could not save best time to localStorage:', error);
        }
    }
    
    formatTime(timeInSeconds) {
        const minutes = Math.floor(timeInSeconds / 60);
        const seconds = Math.floor(timeInSeconds % 60);
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    
    getCurrentTime() {
        return this.currentTime;
    }
    
    getBestTime() {
        return this.bestTime;
    }
    
    isRunning() {
        return this.timerRunning;
    }
    
    isPausedState() {
        return this.isPaused;
    }
    
    reset() {
        this.startTime = null;
        this.currentTime = 0;
        this.timerRunning = false;
        this.isPaused = false;
        this.pausedTime = 0;
        this.pauseStartTime = null;
        this.updateTimerDisplay();
    }
}
```

## js/InputHandler.js

```javascript
import { Vector2D } from './Vector2D.js';

/**
 * Enhanced input handler for both keyboard and mobile touch controls
 */
export class InputHandler {
    constructor() {
        this.keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            shift: false
        };
        
        this.performanceMonitor = null;
        this.isPaused = false;
        this.pauseCallbacks = [];
        this.mobileControls = null;
        this.setupEventListeners();
    }

    setupEventListeners() {
        // Keydown event
        window.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            
            // Handle pause toggle with Escape key
            if (event.key === 'Escape') {
                this.togglePause();
                event.preventDefault();
                return;
            }
            
            // Only process other keys if not paused
            if (this.isPaused) {
                event.preventDefault();
                return;
            }
            
            if (key in this.keys) {
                this.keys[key] = true;
                event.preventDefault();
            } else if (event.key === 'Shift') {
                this.keys.shift = true;
                event.preventDefault();
            } else if (key === 'p' && this.performanceMonitor) {
                // Toggle performance monitor with 'P' key
                this.performanceMonitor.toggle();
                event.preventDefault();
            }
        });

        // Keyup event
        window.addEventListener('keyup', (event) => {
            const key = event.key.toLowerCase();
            
            // Don't process movement key releases if paused
            if (this.isPaused && key in this.keys) {
                event.preventDefault();
                return;
            }
            
            if (key in this.keys) {
                this.keys[key] = false;
                event.preventDefault();
            } else if (event.key === 'Shift') {
                this.keys.shift = false;
                event.preventDefault();
            }
        });

        // Reset keys when window loses focus
        window.addEventListener('blur', () => {
            for (let key in this.keys) {
                this.keys[key] = false;
            }
        });
    }

    // Set mobile controls reference
    setMobileControls(mobileControls) {
        this.mobileControls = mobileControls;
    }

    // Toggle pause state
    togglePause() {
        this.isPaused = !this.isPaused;
        
        // Clear all movement keys when pausing
        if (this.isPaused) {
            for (let key in this.keys) {
                this.keys[key] = false;
            }
        }
        
        // Notify all registered callbacks about pause state change
        this.pauseCallbacks.forEach(callback => callback(this.isPaused));
        
        // Show/hide pause indicator
        this.updatePauseUI();
    }

    // Register a callback to be called when pause state changes
    onPauseToggle(callback) {
        this.pauseCallbacks.push(callback);
    }

    // Update pause UI indicator
    updatePauseUI() {
        let pauseIndicator = document.getElementById('pause-indicator');
        
        if (this.isPaused) {
            if (!pauseIndicator) {
                pauseIndicator = document.createElement('div');
                pauseIndicator.id = 'pause-indicator';
                
                // Different pause message for mobile vs desktop
                const isMobile = this.mobileControls && this.mobileControls.getIsTouchDevice();
                const pauseMessage = isMobile ? 
                    '⏸️ PAUSED<br><small>Tap to resume</small>' : 
                    '⏸️ PAUSED<br><small>Press ESC to resume</small>';
                
                pauseIndicator.innerHTML = pauseMessage;
                pauseIndicator.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    font-size: 24px;
                    text-align: center;
                    z-index: 1000;
                    font-family: Arial, sans-serif;
                `;
                
                // Add touch event for mobile resume
                if (isMobile) {
                    pauseIndicator.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.togglePause();
                    });
                }
                
                document.body.appendChild(pauseIndicator);
            }
            pauseIndicator.style.display = 'block';
        } else {
            if (pauseIndicator) {
                pauseIndicator.style.display = 'none';
            }
        }
    }

    // Get movement direction based on current input state (keyboard + mobile)
    getMovementDirection() {
        // Return zero movement if paused
        if (this.isPaused) {
            return new Vector2D(0, 0);
        }
        
        // Start with keyboard input
        const direction = new Vector2D(0, 0);
        
        if (this.keys.w) direction.z += 1;
        if (this.keys.s) direction.z -= 1;
        if (this.keys.a) direction.x += 1;
        if (this.keys.d) direction.x -= 1;
        
        // Add mobile input if available and no keyboard input
        if (this.mobileControls && this.mobileControls.getIsTouchDevice()) {
            const mobileDirection = this.mobileControls.getMovementDirection();
            
            // If no keyboard input, use mobile input
            if (direction.magnitude() === 0) {
                direction.x = mobileDirection.x;
                direction.z = mobileDirection.z;
            }
        }
        
        return direction;
    }

    // Check if any movement input is active
    isMoving() {
        // Return false if paused
        if (this.isPaused) {
            return false;
        }
        
        // Check keyboard input
        const keyboardMoving = this.keys.w || this.keys.a || this.keys.s || this.keys.d;
        
        // Check mobile input
        const mobileMoving = this.mobileControls && 
                            this.mobileControls.getIsTouchDevice() && 
                            this.mobileControls.getIsMoving();
        
        return keyboardMoving || mobileMoving;
    }
    
    // Check if sprint input is active (keyboard shift or mobile sprint button)
    isSprinting() {
        // Return false if paused
        if (this.isPaused) {
            return false;
        }
        
        // Check keyboard sprint
        const keyboardSprinting = this.keys.shift;
        
        // Check mobile sprint
        const mobileSprinting = this.mobileControls && 
                               this.mobileControls.getIsTouchDevice() && 
                               this.mobileControls.getIsSprinting();
        
        return keyboardSprinting || mobileSprinting;
    }
    
    // Check if game is paused
    isPausedState() {
        return this.isPaused;
    }
    
    // Set performance monitor reference for toggle functionality
    setPerformanceMonitor(performanceMonitor) {
        this.performanceMonitor = performanceMonitor;
    }
}
```

## js/main.js

```javascript
import * as THREE from 'three';
import { SceneManager } from './SceneManager.js';
import { GameState } from './GameState.js';
import { GameTimer } from './GameTimer.js';
import { TerrainBuilder } from './TerrainBuilder.js';
import { StructureBuilder } from './StructureBuilder.js';
import { InputHandler } from './InputHandler.js';
import { MobileControls } from './MobileControls.js';
import { Sheepdog } from './Sheepdog.js';
import { PerformanceMonitor } from './PerformanceMonitor.js';
import { StartScreen } from './StartScreen.js';
import { StaminaUI } from './StaminaUI.js';
import { AudioManager } from './AudioManager.js';
import { NetworkManager } from './NetworkManager.js';
import { MultiplayerUI } from './MultiplayerUI.js';
import { Vector2D } from './Vector2D.js';

/**
 * Main simulation controller - Enhanced with mobile controls support
 * Uses separate modules for different responsibilities
 */
class SheepDogSimulation {
    constructor() {
        // Initialize all modules
        this.sceneManager = new SceneManager();
        this.gameState = new GameState();
        this.gameTimer = new GameTimer();
        this.terrainBuilder = new TerrainBuilder(this.sceneManager.getScene());
        this.structureBuilder = new StructureBuilder(this.sceneManager.getScene());
        this.inputHandler = new InputHandler();
        this.performanceMonitor = new PerformanceMonitor();
        this.startScreen = new StartScreen(this.sceneManager);
        this.staminaUI = new StaminaUI();
        this.audioManager = new AudioManager(this.sceneManager.getCamera());
        this.multiplayerUI = new MultiplayerUI();
        
        // Create mobile controls with sceneManager and audioManager
        this.mobileControls = new MobileControls(this.sceneManager, this.audioManager);
        
        // Add mobile class to body if touch device detected
        if (this.mobileControls.getIsTouchDevice()) {
            document.body.classList.add('is-mobile');
            this.organizeMobileUIContainers();
        }
        
        // Connect mobile controls to input handler and scene manager
        this.inputHandler.setMobileControls(this.mobileControls);
        this.sceneManager.setMobileControls(this.mobileControls);
        
        // Connect performance monitor and game state to input handler
        this.inputHandler.setPerformanceMonitor(this.performanceMonitor);
        
        // Set up pause functionality
        this.setupPauseHandling();
        
        // Set up start screen callback
        this.startScreen.setGameStartCallback((mode, roomData) => {
            this.startGame(mode, roomData);
        });
        
        // Pass audio manager to modules that need it
        this.gameState.setAudioManager(this.audioManager);
        this.startScreen.setAudioManager(this.audioManager);
        
        // Animation timing
        this.lastTime = performance.now();
        
        // Multiplayer state
        this.networkManager = null;
        this.isMultiplayer = false;
        this.otherPlayers = new Map(); // playerId -> Sheepdog instance
        this.playerWasMoving = false; // Track movement state from previous frame
        this.serverIsInterpolatingToClient = false; // Track when server is interpolating to our position
        
        // Client-side prediction and interpolation for multiplayer
        this.serverDogPosition = { x: 0, z: 0 };
        this.serverDogRotation = 0;
        this.lastServerUpdate = 0;
        this.interpolationSpeed = 2.5; // Reduced for smoother movement
        
        // Initialize the simulation
        this.init();
        this.animate();
    }
    
    setupPauseHandling() {
        // Register pause callback with input handler
        this.inputHandler.onPauseToggle((isPaused) => {
            // Propagate pause state to timer
            this.gameTimer.setPaused(isPaused);
            
            // Propagate pause state to game state
            this.gameState.setPaused(isPaused);
        });
    }
    
    init() {
        // Create terrain and environment
        this.terrainBuilder.createTerrain();
        this.terrainBuilder.createGrass();
        this.terrainBuilder.createTrees();
        this.terrainBuilder.addEnvironmentDetails();
        
        // Create structures
        this.structureBuilder.createFieldBoundaryFence(
            this.gameState.getBounds(), 
            this.gameState.getGate()
        );
        this.structureBuilder.createGateAndPasture(
            this.gameState.getGate(), 
            this.gameState.getPasture()
        );
        
        // Create sheepdog (but don't add to scene yet in pre-game state)
        // Note: We'll update speeds when entering multiplayer mode
        // Default to 'jep' for now, will be updated when game starts
        const sheepdog = new Sheepdog(0, -30, 'jep');
        this.sheepdog = sheepdog;
        this.sheepdogMesh = sheepdog.createMesh();
        this.gameState.setSheepdog(sheepdog);
        
        // Connect audio manager to sheepdog
        sheepdog.setAudioManager(this.audioManager);
        
        // Create optimized sheep flock (visible during start screen)
        this.gameState.createSheepFlock(this.sceneManager.getScene());
        
        // Setup controls
        this.sceneManager.setupMouseControls();
        
        // Set grass instance count for performance monitoring
        this.performanceMonitor.setGrassInstanceCount(this.terrainBuilder.getGrassInstanceCount());
    }
    
    startGame(mode = 'solo', roomData = null) {
        console.log(`Starting game in ${mode} mode`, {
            roomCode: roomData?.roomCode || 'none',
            playerCount: roomData?.players?.length || 0,
            roomData: roomData
        });
        
        // Store mode for future reference
        this.gameMode = mode;
        this.roomData = roomData;
        this.isMultiplayer = mode === 'multiplayer';
        
        // Get the selected dog type from the start screen
        const selectedDogType = this.startScreen.getSelectedDog();
        console.log(`Selected dog type: ${selectedDogType}`);
        
        // Remove the old sheepdog from scene if it exists
        if (this.sheepdogMesh) {
            this.sceneManager.remove(this.sheepdogMesh);
        }
        
        // Create new sheepdog with selected type
        const sheepdog = new Sheepdog(0, -30, selectedDogType);
        this.sheepdog = sheepdog;
        this.sheepdogMesh = sheepdog.createMesh();
        this.gameState.setSheepdog(sheepdog);
        
        // Connect audio manager to new sheepdog
        sheepdog.setAudioManager(this.audioManager);
        
        // Add new sheepdog to scene when game starts
        this.sceneManager.add(this.sheepdogMesh);
        
        // Enable mobile controls if on touch device
        if (this.mobileControls.getIsTouchDevice()) {
            this.mobileControls.enable();
        }
        
        // Start the game state (pass mode for future multiplayer handling)
        this.gameState.startGame(mode);
        
        // Reset timer and stamina
        this.gameTimer.reset();
        this.staminaUI.reset();
        this.staminaUI.show();
        
        // Initialize multiplayer if needed
        if (mode === 'multiplayer' && roomData) {
            console.log(`Multiplayer room: ${roomData.roomCode || roomData.code || 'unknown'} with ${roomData.players?.length || 0} players`);
            // Enable 2x speeds for multiplayer
            this.sheepdog.setMultiplayerSpeeds(true);
            this.setupMultiplayer();
            
            // Send dog type to server
            if (this.networkManager) {
                console.log(`Sending dog type to server: ${selectedDogType}`);
                this.networkManager.sendDogType(selectedDogType);
            }
        } else if (mode === 'multiplayer') {
            console.log('Multiplayer mode but no room data available');
            // Enable 2x speeds for multiplayer
            this.sheepdog.setMultiplayerSpeeds(true);
            this.setupMultiplayer();
            
            // Send dog type to server
            if (this.networkManager) {
                console.log(`Sending dog type to server: ${selectedDogType}`);
                this.networkManager.sendDogType(selectedDogType);
            }
        } else {
            // Hide multiplayer UI for solo mode
            this.multiplayerUI.hide();
        }
    }
    
    setupMultiplayer() {
        // Get NetworkManager from StartScreen
        this.networkManager = this.startScreen.networkManager;
        
        if (!this.networkManager) {
            console.error('NetworkManager not available');
            return;
        }
        
        // Show multiplayer UI
        this.multiplayerUI.show();
        
        // Set up network event handlers
        this.setupMultiplayerEventHandlers();
        
        // Initialize multiplayer UI with current room data
        if (this.roomData && this.roomData.players) {
            this.multiplayerUI.updatePlayers(this.roomData.players, this.networkManager.getPlayerId());
        }
        
        console.log('Multiplayer mode initialized');
    }
    
    setupMultiplayerEventHandlers() {
        // Game state updates
        this.networkManager.onGameStateUpdate = (gameState) => {
            this.handleMultiplayerGameState(gameState);
        };
        
        // Connection state changes
        this.networkManager.onConnectionStateChange = (state) => {
            this.multiplayerUI.updateConnectionStatus(state);
            
            if (state === 'disconnected') {
                // Handle disconnection - could show reconnection message
                console.log('Lost connection to server');
            }
        };
        
        // Room/player updates
        this.networkManager.onRoomUpdate = (room) => {
            if (room && room.players) {
                this.multiplayerUI.updatePlayers(room.players, this.networkManager.getPlayerId());
            }
        };
        
        this.networkManager.onPlayerUpdate = (update) => {
            if (update.type === 'joined' && update.player) {
                this.multiplayerUI.addPlayer(update.player);
            } else if (update.type === 'left' && update.player) {
                this.multiplayerUI.removePlayer(update.player.id);
                // Remove the player's 3D visualization
                this.removeOtherPlayer(update.player.id);
            } else if (update.type === 'gameComplete' && update.data) {
                // Handle game completion in multiplayer
                console.log('🎉 Game completed! Final state:', update.data);
                console.log('Current gameState.sheepRetired:', this.gameState.sheepRetired);
                console.log('Current gameState.gameCompleted:', this.gameState.gameCompleted);
                
                // Force final sheep count update
                if (update.data.sheepRetired !== undefined) {
                    console.log('Updating sheep count from', this.gameState.sheepRetired, 'to', update.data.sheepRetired);
                    this.gameState.sheepRetired = update.data.sheepRetired;
                }
                
                // Trigger game completion
                if (update.data.gameCompleted) {
                    console.log('Triggering game completion UI...');
                    this.gameState.gameCompleted = true;
                    const finalTime = this.gameTimer.stop();
                    const isNewRecord = this.gameTimer.getBestTime() !== null && 
                                       finalTime <= this.gameTimer.getBestTime();
                    
                    this.gameState.showCompletionMessage(finalTime, isNewRecord);
                    this.mobileControls.disable();
                } else {
                    console.log('Game completion data received but gameCompleted flag is', update.data.gameCompleted);
                }
            }
            
            // Update current room data
            if (this.networkManager.getCurrentRoom()) {
                const room = this.networkManager.getCurrentRoom();
                this.multiplayerUI.updatePlayers(room.players, this.networkManager.getPlayerId());
            }
        };
        
        // Error handling
        this.networkManager.onError = (message) => {
            console.error('Multiplayer error:', message);
            // Could show error notification in UI
        };
        
        // Ping updates
        this.networkManager.onPingUpdate = (pingMs) => {
            this.multiplayerUI.updatePing(pingMs);
        };
    }
    
    handleMultiplayerGameState(serverState) {
        if (!this.isMultiplayer || !serverState) return;
        
        // Store server state for sprint state prediction
        if (this.networkManager) {
            this.networkManager.lastServerState = serverState;
        }
        
        // Update sheep positions from server with frame-based movement
        if (serverState.sheep && this.gameState.getSheep()) {
            const clientSheep = this.gameState.getSheep();
            const bounds = this.gameState.getBounds();
            const gate = this.gameState.getGate();
            
            for (let i = 0; i < Math.min(serverState.sheep.length, clientSheep.length); i++) {
                const serverSheepData = serverState.sheep[i];
                const clientSheepEntity = clientSheep[i];
                
                if (serverSheepData && clientSheepEntity) {
                    // Trust server positions directly to avoid conflicts
                    // Server already applies proper boundary and gate constraints
                    clientSheepEntity.position.x = serverSheepData.x;
                    clientSheepEntity.position.z = serverSheepData.z;
                    
                    // Update velocity for animation purposes
                    if (serverSheepData.vx !== undefined && serverSheepData.vz !== undefined) {
                        clientSheepEntity.velocity.x = serverSheepData.vx;
                        clientSheepEntity.velocity.z = serverSheepData.vz;
                    }
                    
                    // Update sheep state properties from server
                    if (serverSheepData.state !== undefined) {
                        clientSheepEntity.state = serverSheepData.state;
                    }
                    
                    // Update gate and retirement status directly from server
                    if (serverSheepData.hasPassedGate !== undefined) {
                        clientSheepEntity.hasPassedGate = serverSheepData.hasPassedGate;
                    }
                    if (serverSheepData.isRetiring !== undefined) {
                        clientSheepEntity.isRetiring = serverSheepData.isRetiring;
                    }
                    
                    // Update retirement target if provided
                    if (serverSheepData.targetX !== undefined && serverSheepData.targetZ !== undefined) {
                        if (!clientSheepEntity.retirementTarget) {
                            clientSheepEntity.retirementTarget = new Vector2D(0, 0);
                        }
                        clientSheepEntity.retirementTarget.x = serverSheepData.targetX;
                        clientSheepEntity.retirementTarget.z = serverSheepData.targetZ;
                    } else if (clientSheepEntity.isRetiring && serverSheepData.state === 2) {
                        // Grazing sheep should have no retirement target
                        clientSheepEntity.retirementTarget = null;
                    }
                    if (serverSheepData.facing !== undefined) {
                        clientSheepEntity.facingDirection = serverSheepData.facing;
                    }
                }
            }
            
            // Force visual update of sheep positions in multiplayer mode
            if (this.gameState.optimizedSheepSystem && 
                typeof this.gameState.optimizedSheepSystem.forceUpdateSheepPositions === 'function') {
                this.gameState.optimizedSheepSystem.forceUpdateSheepPositions();
            } else {
                console.warn('optimizedSheepSystem not available or method missing');
            }
        }
        
        // Update sheepdog positions from server
        if (serverState.sheepdogs && this.sheepdog) {
            const currentPlayerId = this.networkManager.getPlayerId();
            
            // Find my sheepdog data
            const mySheepdogData = serverState.sheepdogs.find(dog => dog.playerId === currentPlayerId);
            
            if (mySheepdogData) {
                // JUST STORE the server's authoritative state
                // The reconciliation logic will handle position correction
                this.serverDogPosition = { x: mySheepdogData.x, z: mySheepdogData.z };
                this.lastServerUpdate = performance.now();
                
                // Check if server is interpolating to our position
                this.serverIsInterpolatingToClient = mySheepdogData.interpolatingToClient || false;
                
                // Note: Stamina and sprinting state will be handled in reconciliation
            }
            
            // Handle other players' sheepdogs with full animation data
            for (const dogData of serverState.sheepdogs) {
                if (dogData.playerId !== currentPlayerId) {
                    // Pass the entire dogData object for full animation support
                    this.updateOtherPlayer(dogData);
                }
            }
        }
        
        // Update game state
        if (serverState.sheepRetired !== undefined) {
            this.gameState.sheepRetired = serverState.sheepRetired;
        }
    }
    
    update(deltaTime) {
        // Check if game is paused
        const isPaused = this.inputHandler.isPausedState();
        
        // Update start screen camera if active
        if (this.startScreen.isStartScreenActive()) {
            this.startScreen.updateCinematicCamera();
        } else if (!isPaused) {
            // Handle input only when game is active and not paused
            const movementDirection = this.inputHandler.getMovementDirection();
            const wantsSprint = this.inputHandler.isSprinting();
            const sheepdog = this.gameState.getSheepdog();
            
            // Update sheepdog's awareness of nearby sheep for barking
            sheepdog.updateNearSheepStatus(this.gameState.getSheep());
            
            // Handle input based on mode
            if (this.isMultiplayer && this.networkManager) {
                // --- MULTIPLAYER LOGIC WITH CLIENT-SIDE PREDICTION ---
                
                // Use server's authoritative sprint state for prediction when available
                const serverSprintState = this.getServerSprintState();
                const actualSprintState = serverSprintState !== null ? serverSprintState : wantsSprint;
                
                // 1. PREDICT: Run local simulation for our dog for instant feedback
                sheepdog.move(movementDirection, this.gameState.getBounds(), deltaTime, actualSprintState);
                
                const isMovingNow = movementDirection.magnitude() > 0 || wantsSprint;

                // 2. SEND: Send input if moving now, OR if we just stopped moving
                if (isMovingNow || this.playerWasMoving) {
                    this.networkManager.sendPlayerInput({
                        direction: {
                            x: movementDirection.x,
                            z: movementDirection.z
                        },
                        sprint: wantsSprint,
                        timestamp: performance.now(),
                        // Send client position when stopping for server reconciliation
                        clientPosition: !isMovingNow && this.playerWasMoving ? {
                            x: sheepdog.position.x,
                            z: sheepdog.position.z
                        } : null
                    });
                }
                
                // Update the state for the next frame
                this.playerWasMoving = isMovingNow;

                // 3. RECONCILE: Skip reconciliation only when server is interpolating to our position
                if (!this.serverIsInterpolatingToClient) {
                    this.reconcileWithServerState(deltaTime);
                }
                
                // In multiplayer, server controls sheep behavior
                // Client only handles rendering
            } else {
                // --- SINGLE-PLAYER LOGIC (Unchanged) ---
                sheepdog.move(movementDirection, this.gameState.getBounds(), deltaTime, wantsSprint);
            }
            
            // Start timer on first actual movement
            if (movementDirection.magnitude() > 0 && !this.gameTimer.isRunning()) {
                this.gameTimer.start();
            }
            
            // Update camera to follow sheepdog
            this.sceneManager.updateCamera(sheepdog);
        }
        
        // Update other players with interpolation for smooth movement
        if (this.isMultiplayer && !isPaused) {
            for (const remoteDog of this.otherPlayers.values()) {
                const interpolationFactor = Math.min(this.interpolationSpeed * 2 * deltaTime, 1.0);

                // Interpolate position
                remoteDog.position.x += (remoteDog.targetPosition.x - remoteDog.position.x) * interpolationFactor;
                remoteDog.position.z += (remoteDog.targetPosition.z - remoteDog.position.z) * interpolationFactor;
                
                // Interpolate rotation
                let rotationDiff = remoteDog.targetRotation - remoteDog.currentRotation;
                while (rotationDiff > Math.PI) rotationDiff -= 2 * Math.PI;
                while (rotationDiff < -Math.PI) rotationDiff += 2 * Math.PI;
                remoteDog.currentRotation += rotationDiff * remoteDog.turnSpeed * deltaTime;

                // Update the 3D mesh with the interpolated values
                if (remoteDog.mesh) {
                    remoteDog.mesh.position.set(remoteDog.position.x, 0, remoteDog.position.z);
                    remoteDog.mesh.rotation.y = remoteDog.currentRotation;
                }

                // Run the dog's internal animation logic
                remoteDog.animate(deltaTime);
            }
        }
        
        // Update timer (respects pause state internally)
        this.gameTimer.update();
        
        // Update sheep behaviors (only if not paused)
        // In multiplayer mode, this handles visual behavior based on server state
        if (!isPaused) {
            this.gameState.updateSheepBehaviors(deltaTime);
        }
        
        // Update UI (only when game is active and not paused)
        if (!isPaused) {
            this.gameState.updateUI();
            
            // Update stamina UI if game is active
            if (!this.startScreen.isStartScreenActive()) {
                const sheepdog = this.gameState.getSheepdog();
                if (sheepdog) {
                    this.staminaUI.update(sheepdog.getStaminaInfo());
                }
            }
        }
        
        // Check for game completion (only when game is active and not paused)
        // In multiplayer mode, rely on server completion events instead of client-side checking
        if (!isPaused && !this.isMultiplayer && this.gameState.checkCompletion()) {
            const finalTime = this.gameTimer.stop();
            const isNewRecord = this.gameTimer.getBestTime() !== null && 
                               finalTime <= this.gameTimer.getBestTime();
            
            this.gameState.showCompletionMessage(finalTime, isNewRecord);
            
            // Disable mobile controls when game completes
            this.mobileControls.disable();
        }
    }
    
    animate() {
        requestAnimationFrame(() => this.animate());
        
        // Calculate delta time
        const currentTime = performance.now();
        const deltaTime = (currentTime - this.lastTime) / 1000; // Convert to seconds
        this.lastTime = currentTime;
        
        // Check if game is paused
        const isPaused = this.inputHandler.isPausedState();
        
        // Update grass animation (only if not paused)
        if (!isPaused) {
            this.terrainBuilder.updateGrassAnimation();
        }
        
        // Update game logic with deltaTime
        this.update(deltaTime);
        
        // Update performance monitoring (always update for monitoring purposes)
        this.performanceMonitor.updateMetrics(this.gameState, this.sceneManager.getRenderer());
        
        // Render the scene (always render to show pause indicator)
        this.sceneManager.render();
    }
    
    organizeMobileUIContainers() {
        // Wait a moment for mobile controls to be created
        setTimeout(() => {
            // Organize left stack (just joystick) for portrait mode
            // Sprint button stays independent for bottom-right positioning
            const leftStack = document.getElementById('mobile-left-stack');
            const joystick = document.getElementById('mobile-joystick');
            
            if (leftStack && joystick) {
                leftStack.appendChild(joystick);
            }
            
            // Organize right HUD cluster (timer + stamina) for landscape fullscreen
            const hudRight = document.getElementById('mobile-hud-right');
            const combinedUI = document.getElementById('mobile-combined-ui');
            const staminaBar = document.getElementById('stamina-bar');
            
            if (hudRight && combinedUI) {
                hudRight.appendChild(combinedUI);
            }
            if (hudRight && staminaBar) {
                hudRight.appendChild(staminaBar);
            }
        }, 100);
    }
    
    updateOtherPlayer(dogData) {
        const playerId = dogData.playerId;
        let remoteDog = this.otherPlayers.get(playerId);

        // 1. Create the Sheepdog instance if it's a new player
        if (!remoteDog) {
            console.log(`🐕 Creating visualization for new player ${playerId}`);
            // Create a new Sheepdog instance at the initial position
            // Use dog type from server data, or fall back to 'jep'
            const dogType = dogData.dogType || 'jep';
            console.log(`Creating remote dog with type: ${dogType} for player ${playerId}`);
            remoteDog = new Sheepdog(dogData.x, dogData.z, dogType);
            
            // Enable 2x speeds for multiplayer
            remoteDog.setMultiplayerSpeeds(true);
            
            // Create its 3D mesh and add it to the scene
            const dogMesh = remoteDog.createMesh();
            this.sceneManager.add(dogMesh);
            
            // Add properties for interpolation
            remoteDog.targetPosition = new Vector2D(dogData.x, dogData.z);
            remoteDog.targetRotation = dogData.rotation;

            // Store the full Sheepdog object in our map
            this.otherPlayers.set(playerId, remoteDog);
        }
        
        // 2. Update the target state for interpolation from server data
        remoteDog.targetPosition.set(dogData.x, dogData.z);
        remoteDog.targetRotation = dogData.rotation;

        // 3. Update animation-driving properties directly
        // This data will be used by remoteDog.animate() in the main loop
        remoteDog.velocity.set(dogData.vx, dogData.vz);
        remoteDog.isSprinting = dogData.sprinting;
        remoteDog.isMoving = remoteDog.velocity.magnitude() > 0.5;
    }
    
    getServerSprintState() {
        // Get the server's authoritative sprint state for prediction
        if (this.networkManager?.lastServerState?.sheepdogs) {
            const mySheepdogData = this.networkManager.lastServerState.sheepdogs.find(
                dog => dog.playerId === this.networkManager.getPlayerId()
            );
            return mySheepdogData?.sprinting ?? null;
        }
        return null;
    }
    
    reconcileWithServerState(deltaTime) {
        if (!this.sheepdog || !this.serverDogPosition) return;

        // Get the authoritative position from the server state
        const serverPos = this.serverDogPosition;
        const clientPos = this.sheepdog.position;

        if (serverPos.x === undefined) return;

        // Calculate distance between client prediction and server authority
        const distance = Math.sqrt(
            (clientPos.x - serverPos.x) ** 2 + 
            (clientPos.z - serverPos.z) ** 2
        );

        // Sprint-aware reconciliation to handle speed mismatches
        const serverSprintState = this.getServerSprintState();
        const clientSprintState = this.sheepdog.isSprinting;
        const sprintMismatch = serverSprintState !== null && serverSprintState !== clientSprintState;
        
        // Adjust threshold based on sprint state mismatch
        const reconciliationThreshold = sprintMismatch ? 0.2 : 0.05; // Higher threshold when sprint states differ
        
        if (distance > reconciliationThreshold) {
            // If the distance is very large (e.g., after major lag), snap to the server position
            if (distance > 8.0) { // Higher snap threshold to account for sprint speed differences
                clientPos.x = serverPos.x;
                clientPos.z = serverPos.z;
                console.log('🔧 Large correction applied - snapping to server position', { distance, sprintMismatch });
            } else {
                // Use adaptive interpolation speed based on distance and movement state
                const isMoving = this.sheepdog.velocity.magnitude() > 0.1;
                
                // Faster correction when stopped or when sprint states mismatch
                let baseInterpolationSpeed = isMoving ? this.interpolationSpeed : this.interpolationSpeed * 3;
                if (sprintMismatch) {
                    baseInterpolationSpeed *= 2; // Faster correction for sprint mismatches
                }
                
                // Scale interpolation speed by distance (closer = faster correction)
                const distanceScale = Math.min(distance / 2.0, 1.0);
                const adaptiveSpeed = baseInterpolationSpeed * (1 + distanceScale);
                
                const interpolationFactor = Math.min(adaptiveSpeed * deltaTime, 0.5); // Increased max factor
                clientPos.x += (serverPos.x - clientPos.x) * interpolationFactor;
                clientPos.z += (serverPos.z - clientPos.z) * interpolationFactor;
            }
            
            // Update mesh position to match corrected logical position
            this.sheepdog.mesh.position.x = clientPos.x;
            this.sheepdog.mesh.position.z = clientPos.z;
        }

        // Server is also authoritative on stamina
        if (this.networkManager.lastServerState?.sheepdogs) {
            const mySheepdogData = this.networkManager.lastServerState.sheepdogs.find(
                dog => dog.playerId === this.networkManager.getPlayerId()
            );
            if (mySheepdogData?.stamina !== undefined) {
                // Directly set stamina, as prediction for this is less critical than position
                this.sheepdog.stamina = mySheepdogData.stamina;
            }
            if (mySheepdogData?.sprinting !== undefined) {
                this.sheepdog.isSprinting = mySheepdogData.sprinting;
            }
        }
    }
    
    removeOtherPlayer(playerId) {
        const remoteDog = this.otherPlayers.get(playerId);
        if (remoteDog) {
            // Remove the dog's mesh from the scene
            if (remoteDog.mesh) {
                this.sceneManager.remove(remoteDog.mesh);
            }
            // Delete the player from our map
            this.otherPlayers.delete(playerId);
            console.log(`🐕 Removed visualization for player ${playerId}`);
        }
    }
}

// Start simulation when page loads
window.addEventListener('DOMContentLoaded', () => {
    new SheepDogSimulation();
});
```

## js/MobileControls.js

```javascript
import { Vector2D } from './Vector2D.js';

/**
 * MobileControls - Handles touch-based input controls for mobile devices
 * Includes virtual joystick for movement and zoom slider for camera control
 */
export class MobileControls {
    constructor(sceneManager, audioManager) {
        this.sceneManager = sceneManager;
        this.audioManager = audioManager;
        this.isTouchDevice = this.detectTouchDevice();
        this.isEnabled = false;
        this.joystick = null;
        this.zoomSlider = null;
        this.movementVector = new Vector2D(0, 0);
        this.isMoving = false;
        this.isSprinting = false;
        this.zoomLevel = 80; // Default camera distance
        this.onZoomChange = null;
        
        // UI elements
        this.joystickContainer = null;
        this.zoomContainer = null;
        this.sprintButton = null;
        this.fullscreenButton = null;
        
        if (this.isTouchDevice) {
            this.createFullscreenButton();
            this.setupFullscreenListeners();
            
            // Add fullscreen change listeners that trigger resize
            if (this.sceneManager) {
                ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'msfullscreenchange']
                    .forEach(evt => document.addEventListener(evt, () => this.sceneManager.onWindowResize()));
            }
            
            this.loadNippleJS().then(() => {
                this.createMobileUI();
                this.setupTouchPrevention();
            });
        }
    }
    
    /**
     * Detect if device supports touch input
     * @returns {boolean} True if touch device detected
     */
    detectTouchDevice() {
        // Multiple detection methods for better accuracy
        const hasTouch = 'ontouchstart' in window || 
                        navigator.maxTouchPoints > 0 || 
                        navigator.msMaxTouchPoints > 0;
        
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        const hasCoarsePointer = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
        
        const isSmallScreen = window.innerWidth <= 768 || window.innerHeight <= 768;
        
        // Device is considered touch-capable if it has touch AND (is mobile OR has coarse pointer OR small screen)
        return hasTouch && (isMobile || hasCoarsePointer || isSmallScreen);
    }
    
    /**
     * Load nipple.js library dynamically
     */
    async loadNippleJS() {
        return new Promise((resolve, reject) => {
            if (window.nipplejs) {
                resolve();
                return;
            }
            
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.2/nipplejs.js';
            script.onload = () => resolve();
            script.onerror = () => reject(new Error('Failed to load nipple.js'));
            document.head.appendChild(script);
        });
    }
    
    /**
     * Create mobile UI elements
     */
    createMobileUI() {
        this.createJoystick();
        this.createZoomSlider();
        this.createSprintButton();
        this.updateMobileInstructions();
    }
    
    /**
     * Create virtual joystick for movement
     */
    createJoystick() {
        // Get safe area insets
        const safeAreaBottom = getComputedStyle(document.documentElement).getPropertyValue('--sab') || 
                              'env(safe-area-inset-bottom, 0px)';
        const safeAreaLeft = 'env(safe-area-inset-left, 0px)';
        
        // Create joystick container
        this.joystickContainer = document.createElement('div');
        this.joystickContainer.id = 'mobile-joystick';
        this.joystickContainer.style.cssText = `
            position: fixed;
            bottom: calc(20px + ${safeAreaBottom});
            left: calc(20px + ${safeAreaLeft});
            width: 120px;
            height: 120px;
            z-index: 1001;
            display: none;
            pointer-events: auto;
        `;
        document.body.appendChild(this.joystickContainer);
        
        // Initialize nipple.js joystick
        if (window.nipplejs) {
            this.joystick = window.nipplejs.create({
                zone: this.joystickContainer,
                mode: 'static',
                position: { left: '50%', top: '50%' },
                color: '#00BFFF',
                size: 120,
                threshold: 0.1,
                fadeTime: 250,
                restOpacity: 0.7
            });
            
            // Handle joystick events
            this.joystick.on('start', () => {
                this.isMoving = true;
            });
            
            this.joystick.on('move', (evt, data) => {
                if (data.vector) {
                    // Convert joystick vector to movement vector
                    // Nipple.js uses screen coordinates, we need game coordinates
                    this.movementVector.x = -data.vector.x; // Invert X for correct direction
                    this.movementVector.z = data.vector.y;  // Y becomes Z in 3D space
                    this.isMoving = true;
                }
            });
            
            this.joystick.on('end', () => {
                this.movementVector.x = 0;
                this.movementVector.z = 0;
                this.isMoving = false;
            });
        }
    }
    
    /**
     * Create zoom slider for camera control
     */
    createZoomSlider() {
        // Get safe area insets
        const safeAreaBottom = getComputedStyle(document.documentElement).getPropertyValue('--sab') || 
                              'env(safe-area-inset-bottom, 0px)';
        const safeAreaRight = 'env(safe-area-inset-right, 0px)';
        
        this.zoomContainer = document.createElement('div');
        this.zoomContainer.id = 'mobile-zoom';
        this.zoomContainer.style.cssText = `
            position: fixed;
            bottom: calc(20px + ${safeAreaBottom});
            right: calc(20px + ${safeAreaRight});
            width: 40px;
            height: 200px;
            z-index: 1001;
            display: none;
            pointer-events: auto;
        `;
        
        // Create slider
        this.zoomSlider = document.createElement('input');
        this.zoomSlider.type = 'range';
        this.zoomSlider.min = '20';
        this.zoomSlider.max = '150';
        this.zoomSlider.value = '80';
        this.zoomSlider.orient = 'vertical';
        this.zoomSlider.style.cssText = `
            width: 200px;
            height: 40px;
            transform: rotate(-90deg) translateX(-80px);
            transform-origin: 20px 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        `;
        
        // Style the slider track and thumb
        const style = document.createElement('style');
        style.textContent = `
            #mobile-zoom input[type="range"]::-webkit-slider-track {
                height: 8px;
                background: #ddd;
                border-radius: 4px;
                border: 1px solid #00BFFF;
            }
            
            #mobile-zoom input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                height: 20px;
                width: 20px;
                border-radius: 50%;
                background: #00BFFF;
                cursor: pointer;
                border: 2px solid white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
            
            #mobile-zoom input[type="range"]::-moz-range-track {
                height: 8px;
                background: #ddd;
                border-radius: 4px;
                border: 1px solid #00BFFF;
            }
            
            #mobile-zoom input[type="range"]::-moz-range-thumb {
                height: 20px;
                width: 20px;
                border-radius: 50%;
                background: #00BFFF;
                cursor: pointer;
                border: 2px solid white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        `;
        document.head.appendChild(style);
        
        // Add zoom labels - REMOVED
        // const zoomLabel = document.createElement('div');
        // zoomLabel.textContent = 'Zoom';
        // zoomLabel.style.cssText = `
        //     position: absolute;
        //     top: -25px;
        //     left: 50%;
        //     transform: translateX(-50%);
        //     font-size: 12px;
        //     color: white;
        //     background: rgba(0, 0, 0, 0.7);
        //     padding: 2px 6px;
        //     border-radius: 4px;
        //     font-family: Arial, sans-serif;
        //     font-weight: bold;
        // `;
        
        // this.zoomContainer.appendChild(zoomLabel);
        this.zoomContainer.appendChild(this.zoomSlider);
        document.body.appendChild(this.zoomContainer);
        
        // Handle zoom changes
        this.zoomSlider.addEventListener('input', (e) => {
            this.zoomLevel = parseInt(e.target.value);
            if (this.onZoomChange) {
                this.onZoomChange(this.zoomLevel);
            }
        });
    }
    
    /**
     * Create sprint button
     */
    createSprintButton() {
        // Get safe area insets
        const safeAreaBottom = getComputedStyle(document.documentElement).getPropertyValue('--sab') || 
                              'env(safe-area-inset-bottom, 0px)';
        const safeAreaLeft = 'env(safe-area-inset-left, 0px)';
        
        this.sprintButton = document.createElement('button');
        this.sprintButton.id = 'mobile-sprint';
        this.sprintButton.textContent = '🏃';
        this.sprintButton.style.cssText = `
            position: fixed;
            bottom: calc(20px + ${safeAreaBottom});
            left: calc(160px + ${safeAreaLeft});
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 191, 255, 0.8);
            border: 3px solid white;
            color: white;
            font-size: 24px;
            z-index: 1001;
            display: none;
            pointer-events: auto;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        `;
        
        // Handle sprint button events
        this.sprintButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.isSprinting = true;
            this.sprintButton.style.background = 'rgba(255, 107, 53, 0.9)';
            this.sprintButton.style.transform = 'scale(0.95)';
        });
        
        this.sprintButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.isSprinting = false;
            this.sprintButton.style.background = 'rgba(0, 191, 255, 0.8)';
            this.sprintButton.style.transform = 'scale(1)';
        });
        
        // Prevent context menu
        this.sprintButton.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        document.body.appendChild(this.sprintButton);
    }
    
    /**
     * Update instructions for mobile devices
     */
    updateMobileInstructions() {
        const instructions = document.getElementById('instructions');
        if (instructions && this.isTouchDevice) {
            // Hide the instructions completely on mobile
            instructions.style.display = 'none';
        }
    }
    
    /**
     * Setup touch event prevention for game canvas
     */
    setupTouchPrevention() {
        const canvas = document.querySelector('canvas');
        if (canvas) {
            // Prevent default touch behaviors on canvas
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
            }, { passive: false });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });
            
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
            }, { passive: false });
        }
        
        // Prevent zoom on double tap
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // Prevent zoom on pinch
        document.addEventListener('gesturestart', (e) => {
            e.preventDefault();
        });
    }
    
    /**
     * Enable mobile controls
     */
    enable() {
        if (!this.isTouchDevice) return;
        
        this.isEnabled = true;
        if (this.joystickContainer) this.joystickContainer.style.display = 'block';
        if (this.zoomContainer) this.zoomContainer.style.display = 'block';
        if (this.sprintButton) this.sprintButton.style.display = 'block';
    }
    
    /**
     * Disable mobile controls
     */
    disable() {
        this.isEnabled = false;
        if (this.joystickContainer) this.joystickContainer.style.display = 'none';
        if (this.zoomContainer) this.zoomContainer.style.display = 'none';
        if (this.sprintButton) this.sprintButton.style.display = 'none';
        
        // Reset movement state
        this.movementVector.x = 0;
        this.movementVector.z = 0;
        this.isMoving = false;
        this.isSprinting = false;
    }
    
    /**
     * Get current movement direction
     */
    getMovementDirection() {
        if (!this.isEnabled) return new Vector2D(0, 0);
        return this.movementVector.clone();
    }
    
    /**
     * Check if currently moving
     */
    getIsMoving() {
        return this.isEnabled && this.isMoving;
    }
    
    /**
     * Check if currently sprinting
     */
    getIsSprinting() {
        return this.isEnabled && this.isSprinting;
    }
    
    /**
     * Set zoom change callback
     */
    setZoomChangeCallback(callback) {
        this.onZoomChange = callback;
    }
    
    /**
     * Get current zoom level
     */
    getZoomLevel() {
        return this.zoomLevel;
    }
    
    /**
     * Check if this is a touch device
     */
    getIsTouchDevice() {
        return this.isTouchDevice;
    }
    
    /**
     * Cleanup mobile controls
     */
    destroy() {
        if (this.joystick) {
            this.joystick.destroy();
        }
        
        if (this.joystickContainer) {
            this.joystickContainer.remove();
        }
        
        if (this.zoomContainer) {
            this.zoomContainer.remove();
        }
        
        if (this.sprintButton) {
            this.sprintButton.remove();
        }
    }
    
    /**
     * Check if fullscreen API is supported
     */
    isFullscreenSupported() {
        const element = document.documentElement;
        return !!(
            element.requestFullscreen ||
            element.webkitRequestFullscreen ||
            element.webkitRequestFullScreen ||
            element.mozRequestFullScreen ||
            element.msRequestFullscreen
        );
    }
    
    /**
     * Create fullscreen button for mobile devices
     */
    createFullscreenButton() {
        // Only show on mobile devices that support fullscreen
        if (!this.isTouchDevice || !this.isFullscreenSupported()) return;
        
        // Don't create if already exists or if already in fullscreen
        if (this.fullscreenButton || this.isFullscreen()) return;
        
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.id = 'mobile-fullscreen';
        this.fullscreenButton.innerHTML = '📱<br><span style="font-size: 14px;">Play Fullscreen</span>';
        this.fullscreenButton.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 160px;
            height: 80px;
            border-radius: 12px;
            background: rgba(0, 191, 255, 0.95);
            border: 3px solid white;
            color: white;
            font-size: 24px;
            font-weight: bold;
            z-index: 2000;
            display: block;
            pointer-events: auto;
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
            transition: all 0.3s ease;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            font-family: Arial, sans-serif;
            text-align: center;
            line-height: 1.2;
            cursor: pointer;
        `;
        
        // Add hover/active effects
        this.fullscreenButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.fullscreenButton.style.transform = 'translate(-50%, -50%) scale(0.95)';
            this.fullscreenButton.style.background = 'rgba(0, 150, 200, 0.95)';
        });
        
        this.fullscreenButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.fullscreenButton.style.transform = 'translate(-50%, -50%) scale(1)';
            this.fullscreenButton.style.background = 'rgba(0, 191, 255, 0.95)';
            
            // Request fullscreen
            this.requestFullscreen();
        });
        
        // Fallback click event for devices that might not support touch events properly
        this.fullscreenButton.addEventListener('click', (e) => {
            e.preventDefault();
            this.requestFullscreen();
        });
        
        // Prevent context menu
        this.fullscreenButton.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        document.body.appendChild(this.fullscreenButton);
    }
    
    /**
     * Request fullscreen with cross-browser compatibility
     */
    requestFullscreen() {
        const element = document.documentElement;
        
        try {
            let fullscreenPromise = null;
            
            // Check for different fullscreen API methods
            if (element.requestFullscreen) {
                fullscreenPromise = element.requestFullscreen();
            } else if (element.webkitRequestFullscreen) {
                // Safari
                fullscreenPromise = element.webkitRequestFullscreen();
            } else if (element.webkitRequestFullScreen) {
                // Older Safari
                fullscreenPromise = element.webkitRequestFullScreen();
            } else if (element.mozRequestFullScreen) {
                // Firefox
                fullscreenPromise = element.mozRequestFullScreen();
            } else if (element.msRequestFullscreen) {
                // IE/Edge
                fullscreenPromise = element.msRequestFullscreen();
            } else {
                console.warn('Fullscreen API not supported on this device');
                // Hide button anyway since user tried to use it
                this.hideFullscreenButton();
                return;
            }
            
            // Handle the fullscreen promise
            if (fullscreenPromise && fullscreenPromise.then) {
                fullscreenPromise.then(() => {
                    /* 1. Force a layout pass for the new viewport and update controls layout */
                    setTimeout(() => {
                        window.dispatchEvent(new Event('resize'));
                        this.updateFullscreenLayout(); // Ensure layout is updated after resize
                    }, 50);
                    
                    /* 2. If start-screen is still active, scroll it back in view */
                    if (document.getElementById('start-screen')) {
                        document.getElementById('start-screen').scrollIntoView({block:'center'});
                    }
                    
                    /* 3. Guarantee AudioContext is resumed */
                    if (this.audioManager && this.audioManager.listener && this.audioManager.listener.context && 
                        this.audioManager.listener.context.state === 'suspended') {
                        this.audioManager.listener.context.resume().catch(() => {});
                    }
                });
            }
            
            // Hide the fullscreen button after requesting fullscreen
            this.hideFullscreenButton();
            
        } catch (error) {
            console.warn('Failed to request fullscreen:', error);
            // Hide button if fullscreen fails
            this.hideFullscreenButton();
        }
    }
    
    /**
     * Hide the fullscreen button
     */
    hideFullscreenButton() {
        if (this.fullscreenButton) {
            this.fullscreenButton.style.opacity = '0';
            this.fullscreenButton.style.pointerEvents = 'none';
            setTimeout(() => {
                if (this.fullscreenButton) {
                    this.fullscreenButton.remove();
                    this.fullscreenButton = null;
                }
            }, 300);
        }
    }
    
    /**
     * Check if device is in fullscreen mode
     */
    isFullscreen() {
        return !!(
            document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement
        );
    }
    
    /**
     * Setup fullscreen change event listeners
     */
    setupFullscreenListeners() {
        // Handle fullscreen change events across different browsers
        const handleFullscreenChange = () => {
            if (!this.isFullscreen() && this.isTouchDevice) {
                // User exited fullscreen, show button again
                setTimeout(() => {
                    this.createFullscreenButton();
                }, 500); // Small delay to avoid flickering
            }
            
            // Update mobile UI positioning for fullscreen
            this.updateFullscreenLayout();
        };
        
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('msfullscreenchange', handleFullscreenChange);
    }
    
    /**
     * Update mobile UI layout for fullscreen mode
     */
    updateFullscreenLayout() {
        if (!this.isTouchDevice) return;
        
        const isFullscreen = this.isFullscreen();
        const body = document.body;
        
        if (isFullscreen) {
            // Add fullscreen class for CSS targeting
            body.classList.add('mobile-fullscreen');
            
            // In the new container system, individual positioning is handled by CSS
            // We only need to ensure elements are not overridden by JS
            
            // Clear any JS-forced positioning for stamina bar in landscape fullscreen
            // Let the CSS container system handle it
            if (window.matchMedia('(orientation: landscape)').matches) {
                const staminaBar = document.getElementById('stamina-bar');
                if (staminaBar) {
                    // Clear JS positioning - let CSS containers handle it
                    staminaBar.style.left = '';
                    staminaBar.style.transform = '';
                    staminaBar.style.right = '';
                    staminaBar.style.bottom = '';
                }
            }
        } else {
            // Remove fullscreen class
            body.classList.remove('mobile-fullscreen');
            
            // Reset any positioning when exiting fullscreen if needed
            // But mostly let CSS handle it
        }
    }
}
```

## js/MultiplayerUI.js

```javascript
/**
 * MultiplayerUI - Manages multiplayer-specific UI elements
 * - Player list display during gameplay
 * - Connection status indicator
 * - Ping/latency display
 * - Multiplayer-specific notifications
 */
export class MultiplayerUI {
    constructor() {
        // UI Elements
        this.multiplayerHUD = document.getElementById('multiplayer-hud');
        this.multiplayerPlayers = document.getElementById('multiplayer-players');
        this.connectionIcon = document.getElementById('connection-icon');
        this.pingDisplay = document.getElementById('ping-display');
        
        // State
        this.currentPlayers = [];
        this.connectionState = 'disconnected';
        this.currentPing = null;
        this.playerId = null;
        
        // Ping measurement
        this.lastPingTime = 0;
        this.pingHistory = [];
        this.maxPingHistory = 10;
    }
    
    // Main UI Control
    show() {
        if (this.multiplayerHUD) {
            this.multiplayerHUD.style.display = 'block';
        }
    }
    
    hide() {
        if (this.multiplayerHUD) {
            this.multiplayerHUD.style.display = 'none';
        }
    }
    
    // Player Management
    updatePlayers(players, currentPlayerId = null) {
        this.currentPlayers = players || [];
        this.playerId = currentPlayerId;
        this.renderPlayerList();
    }
    
    renderPlayerList() {
        if (!this.multiplayerPlayers) return;
        
        this.multiplayerPlayers.innerHTML = '';
        
        if (this.currentPlayers.length === 0) {
            const noPlayersDiv = document.createElement('div');
            noPlayersDiv.className = 'multiplayer-player';
            noPlayersDiv.innerHTML = '<span class="player-name">No players</span>';
            this.multiplayerPlayers.appendChild(noPlayersDiv);
            return;
        }
        
        this.currentPlayers.forEach(player => {
            const playerDiv = document.createElement('div');
            playerDiv.className = 'multiplayer-player';
            
            const playerName = document.createElement('span');
            playerName.className = 'player-name';
            playerName.textContent = player.name || player.id || 'Unknown';
            
            const playerStatus = document.createElement('span');
            playerStatus.className = 'player-status';
            
            // Determine status
            if (player.id === this.playerId) {
                playerStatus.textContent = 'You';
                playerStatus.classList.add('you');
            } else if (player.isHost) {
                playerStatus.textContent = 'Host';
                playerStatus.classList.add('host');
            } else {
                playerStatus.textContent = 'Player';
            }
            
            playerDiv.appendChild(playerName);
            playerDiv.appendChild(playerStatus);
            this.multiplayerPlayers.appendChild(playerDiv);
        });
    }
    
    // Connection Status
    updateConnectionStatus(state) {
        this.connectionState = state;
        this.updateConnectionIndicator();
    }
    
    updateConnectionIndicator() {
        if (!this.connectionIcon) return;
        
        // Remove all state classes
        this.connectionIcon.classList.remove('connected', 'disconnected', 'reconnecting');
        
        switch (this.connectionState) {
            case 'connected':
                this.connectionIcon.textContent = '🔗';
                this.connectionIcon.classList.add('connected');
                break;
            case 'disconnected':
                this.connectionIcon.textContent = '❌';
                this.connectionIcon.classList.add('disconnected');
                break;
            case 'connecting':
            case 'reconnecting':
                this.connectionIcon.textContent = '⏳';
                this.connectionIcon.classList.add('reconnecting');
                break;
            default:
                this.connectionIcon.textContent = '❓';
                this.connectionIcon.classList.add('disconnected');
        }
    }
    
    // Ping Management
    updatePing(pingMs) {
        if (typeof pingMs === 'number' && !isNaN(pingMs)) {
            this.currentPing = pingMs;
            
            // Add to history for averaging
            this.pingHistory.push(pingMs);
            if (this.pingHistory.length > this.maxPingHistory) {
                this.pingHistory.shift();
            }
            
            this.updatePingDisplay();
        }
    }
    
    updatePingDisplay() {
        if (!this.pingDisplay) return;
        
        if (this.currentPing === null || this.connectionState !== 'connected') {
            this.pingDisplay.textContent = 'Ping: --ms';
            return;
        }
        
        // Calculate average ping from history
        const avgPing = this.pingHistory.reduce((sum, ping) => sum + ping, 0) / this.pingHistory.length;
        const roundedPing = Math.round(avgPing);
        
        // Color code based on ping quality
        let pingClass = '';
        if (roundedPing < 50) {
            pingClass = 'ping-good';
        } else if (roundedPing < 100) {
            pingClass = 'ping-ok';
        } else {
            pingClass = 'ping-poor';
        }
        
        this.pingDisplay.textContent = `Ping: ${roundedPing}ms`;
        this.pingDisplay.className = pingClass;
    }
    
    // Ping measurement helpers
    startPingMeasurement() {
        this.lastPingTime = performance.now();
    }
    
    completePingMeasurement() {
        if (this.lastPingTime > 0) {
            const pingTime = performance.now() - this.lastPingTime;
            this.updatePing(pingTime);
            this.lastPingTime = 0;
        }
    }
    
    // Utility methods
    addPlayer(player) {
        const existingIndex = this.currentPlayers.findIndex(p => p.id === player.id);
        if (existingIndex >= 0) {
            // Update existing player
            this.currentPlayers[existingIndex] = { ...this.currentPlayers[existingIndex], ...player };
        } else {
            // Add new player
            this.currentPlayers.push(player);
        }
        this.renderPlayerList();
    }
    
    removePlayer(playerId) {
        this.currentPlayers = this.currentPlayers.filter(p => p.id !== playerId);
        this.renderPlayerList();
    }
    
    updatePlayer(playerId, updates) {
        const playerIndex = this.currentPlayers.findIndex(p => p.id === playerId);
        if (playerIndex >= 0) {
            this.currentPlayers[playerIndex] = { ...this.currentPlayers[playerIndex], ...updates };
            this.renderPlayerList();
        }
    }
    
    // Game state updates
    updatePlayerGameState(playerId, gameState) {
        // Could be used to show player-specific game info (score, position, etc.)
        // For now, just update basic player info
        this.updatePlayer(playerId, gameState);
    }
    
    // Reset/cleanup
    reset() {
        this.currentPlayers = [];
        this.connectionState = 'disconnected';
        this.currentPing = null;
        this.playerId = null;
        this.pingHistory = [];
        this.lastPingTime = 0;
        
        this.renderPlayerList();
        this.updateConnectionIndicator();
        this.updatePingDisplay();
    }
    
    // Get current state
    getPlayers() {
        return [...this.currentPlayers];
    }
    
    getConnectionState() {
        return this.connectionState;
    }
    
    getCurrentPing() {
        return this.currentPing;
    }
}
```

## js/NetworkManager.js

```javascript
import geckos from '@geckos.io/client';

/**
 * NetworkManager - Handles all multiplayer networking functionality
 * - Room management (create, join, leave)
 * - Input synchronization (send player inputs to server)
 * - State synchronization (receive game state from server)
 * - Connection handling (connect, disconnect, reconnect)
 */
export class NetworkManager {
    constructor() {
        this.channel = null;
        this.connected = false;
        this.connecting = false;
        this.currentRoom = null;
        this.playerId = null;
        this.playerName = null;
        this.isHost = false;
        
        // Server configuration - Environment specific
        const isLocalDevelopment = window.location.hostname === 'localhost' || 
                                  window.location.hostname === '127.0.0.1' ||
                                  window.location.hostname === '';
        
        if (isLocalDevelopment) {
            // Local development configuration
            this.serverHost = '127.0.0.1';
            this.serverPort = 9208; // Local development port
        } else {
            // Production configuration
            this.serverHost = 'server-little-cherry-7613.fly.dev';
            this.serverPort = 9208; // Production port
        }
        
        // Callbacks
        this.onConnectionStateChange = null;
        this.onRoomUpdate = null;
        this.onGameStateUpdate = null;
        this.onPlayerUpdate = null;
        this.onError = null;
        this.onPingUpdate = null;
        
        // Client-side prediction and interpolation
        this.lastServerState = null;
        this.previousServerState = null;
        this.serverUpdateTimestamp = 0;
        this.interpolationDelay = 100; // ms
        
        // Input buffering
        this.inputBuffer = [];
        this.lastInputSequence = 0;
        
        // Connection retry
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 2000; // ms
        
        // Ping measurement
        this.pingInterval = null;
        this.pingRequestId = 0;
        this.pendingPings = new Map();
        this.lastPing = null;
    }
    
    // Connection Management
    async connect() {
        if (this.connected || this.connecting) {
            return Promise.resolve();
        }
        
        // Environment-specific server configuration already set in constructor
        
        this.connecting = true;
        this.notifyConnectionStateChange('connecting');
        
        try {
            // Determine protocol based on hostname
            const protocol = this.serverHost === '127.0.0.1' || this.serverHost === 'localhost' ? 'http' : 'https';
            const serverUrl = `${protocol}://${this.serverHost}`;
            
            console.log(`🔗 DEBUG: Connecting to ${serverUrl}:${this.serverPort}`);
            console.log(`🔗 DEBUG: Environment: ${this.serverHost === '127.0.0.1' ? 'Local Development' : 'Production'}`);
            
            // Configure Geckos connection
            const geckosConfig = { 
                url: serverUrl,
                port: this.serverPort
            };
            console.log(`🔗 DEBUG: Using server port ${this.serverPort}`);
                
            this.channel = geckos(geckosConfig);
            
            console.log(`🔗 DEBUG: Geckos client created`);
            this.setupEventHandlers();
            console.log(`🔗 DEBUG: Event handlers set up`);
            
            return new Promise((resolve, reject) => {
                console.log(`🔗 DEBUG: Setting up connection promise with 30s timeout`);
                
                const timeout = setTimeout(() => {
                    console.log(`🔗 DEBUG: Connection timeout after 5 seconds`);
                    this.connecting = false;
                    reject(new Error('Connection timeout - is local server running?'));
                }, 5000); // 5 second timeout for local development
                
                this.channel.onConnect(error => {
                    console.log(`🔗 DEBUG: onConnect callback triggered, error:`, error);
                    clearTimeout(timeout);
                    this.connecting = false;
                    
                    if (error) {
                        console.error('🔗 DEBUG: Connection failed with error:', error);
                        this.notifyError('Failed to connect to server');
                        reject(error);
                    } else {
                        console.log('🔗 DEBUG: Connection successful!');
                        this.connected = true;
                        this.reconnectAttempts = 0;
                        console.log('Connected to multiplayer server');
                        this.notifyConnectionStateChange('connected');
                        this.startPingMeasurement();
                        resolve();
                    }
                });
            });
        } catch (error) {
            this.connecting = false;
            console.error('Network connection error:', error);
            this.notifyError('Network connection failed');
            throw error;
        }
    }
    
    disconnect() {
        if (this.channel) {
            this.channel.close();
        }
        this.connected = false;
        this.connecting = false;
        this.currentRoom = null;
        this.playerId = null;
        this.isHost = false;
        this.stopPingMeasurement();
        this.notifyConnectionStateChange('disconnected');
    }
    
    setupEventHandlers() {
        if (!this.channel) return;
        
        // Connection events
        this.channel.onDisconnect(() => {
            console.log('Disconnected from server');
            this.connected = false;
            this.notifyConnectionStateChange('disconnected');
            this.attemptReconnect();
        });
        
        // Room management events
        this.channel.on('roomCreated', (data) => {
            console.log('Room created:', data);
            this.currentRoom = data.room;
            this.playerId = data.playerId;
            this.isHost = true;
            this.notifyRoomUpdate(data.room);
        });
        
        this.channel.on('roomJoined', (data) => {
            console.log('Room joined:', data);
            this.currentRoom = data.room;
            this.playerId = data.playerId;
            this.isHost = data.isHost;
            this.notifyRoomUpdate(data.room);
        });
        
        this.channel.on('roomUpdated', (data) => {
            console.log('Room updated:', data);
            this.currentRoom = data.room;
            this.notifyRoomUpdate(data.room);
        });
        
        this.channel.on('playerJoined', (data) => {
            console.log('Player joined:', data);
            // Update current room state
            this.currentRoom = data.room;
            this.notifyRoomUpdate(data.room);
            this.notifyPlayerUpdate({ 
                type: 'joined', 
                player: { id: data.playerId, name: data.playerName }
            });
        });
        
        this.channel.on('playerLeft', (data) => {
            console.log('Player left:', data);
            // Update current room state
            this.currentRoom = data.room;
            this.notifyRoomUpdate(data.room);
            this.notifyPlayerUpdate({ 
                type: 'left', 
                player: { id: data.playerId, name: data.playerName }
            });
        });
        
        this.channel.on('hostChanged', (data) => {
            console.log('Host changed:', data);
            this.isHost = data.isHost;
            this.notifyPlayerUpdate({ type: 'hostChanged', newHost: data.newHost });
        });
        
        // Game state events
        this.channel.on('gameStarted', (data) => {
            console.log('Game started:', data);
            this.notifyPlayerUpdate({ type: 'gameStarted', gameState: data });
        });
        
        this.channel.on('gameStateUpdate', (data) => {
            this.handleGameStateUpdate(data);
        });
        
        this.channel.on('gameComplete', (data) => {
            console.log('🎉 Game completed:', data);
            console.log('NetworkManager received gameComplete event with data:', JSON.stringify(data, null, 2));
            this.notifyPlayerUpdate({ type: 'gameComplete', data: data });
        });
        
        // Error handling
        this.channel.on('error', (error) => {
            console.error('Server error:', error);
            this.notifyError(error.message || 'Server error occurred');
        });
        
        this.channel.on('roomError', (error) => {
            console.error('Room error:', error);
            this.notifyError(error.message || 'Room error occurred');
        });
        
        // Ping measurement
        this.channel.on('ping', (data) => {
            // Respond to server ping
            this.channel.emit('pong', data);
        });
        
        this.channel.on('pong', (data) => {
            // Handle ping response
            this.handlePingResponse(data);
        });
    }
    
    // Room Management
    async createRoom(playerName, roomSettings = {}, dogType = 'jep') {
        if (!this.connected) {
            throw new Error('Not connected to server');
        }
        
        this.playerName = playerName;
        this.dogType = dogType;
        
        const roomData = {
            playerName,
            dogType,
            roomSettings: {
                maxPlayers: roomSettings.maxPlayers || 4,
                isPublic: roomSettings.isPublic !== false,
                roomName: roomSettings.roomName || `${playerName}'s Room`
            }
        };
        
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Room creation timeout'));
            }, 5000);
            
            this.channel.emit('createRoom', roomData);
            
            const handleRoomCreated = (data) => {
                clearTimeout(timeout);
                resolve(data);
            };
            
            const handleRoomError = (error) => {
                clearTimeout(timeout);
                reject(new Error(error.message));
            };
            
            this.channel.on('roomCreated', handleRoomCreated);
            this.channel.on('roomError', handleRoomError);
        });
    }
    
    async joinRoom(roomCode, playerName, dogType = 'jep') {
        if (!this.connected) {
            throw new Error('Not connected to server');
        }
        
        this.playerName = playerName;
        this.dogType = dogType;
        
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Room join timeout'));
            }, 5000);
            
            console.log(`🔍 DEBUG: Sending joinRoom with roomCode: "${roomCode}", playerName: "${playerName}", dogType: "${dogType}"`);
            this.channel.emit('joinRoom', { roomCode, playerName, dogType });
            
            const handleRoomJoined = (data) => {
                clearTimeout(timeout);
                resolve(data);
            };
            
            const handleRoomError = (error) => {
                clearTimeout(timeout);
                reject(new Error(error.message));
            };
            
            this.channel.on('roomJoined', handleRoomJoined);
            this.channel.on('roomError', handleRoomError);
        });
    }
    
    async quickMatch(playerName, dogType = 'jep') {
        if (!this.connected) {
            throw new Error('Not connected to server');
        }
        
        this.playerName = playerName;
        this.dogType = dogType;
        
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Quick match timeout'));
            }, 10000);
            
            this.channel.emit('quickMatch', { playerName, dogType });
            
            const handleRoomJoined = (data) => {
                clearTimeout(timeout);
                resolve(data);
            };
            
            const handleRoomError = (error) => {
                clearTimeout(timeout);
                reject(new Error(error.message));
            };
            
            this.channel.on('roomJoined', handleRoomJoined);
            this.channel.on('roomError', handleRoomError);
        });
    }
    
    leaveRoom() {
        if (this.connected && this.currentRoom) {
            this.channel.emit('leaveRoom');
            this.currentRoom = null;
            this.playerId = null;
            this.isHost = false;
        }
    }
    
    startGame() {
        if (this.connected && this.isHost && this.currentRoom) {
            this.channel.emit('startGame');
        }
    }
    
    // Send dog type information to server
    sendDogType(dogType) {
        if (this.connected && this.currentRoom) {
            this.dogType = dogType;
            this.channel.emit('setDogType', { dogType });
        }
    }
    
    // Input Handling
    sendPlayerInput(input) {
        if (!this.connected || !this.currentRoom) return;
        
        // Add sequence number for client-side prediction
        const inputWithSequence = {
            ...input,
            sequence: ++this.lastInputSequence,
            timestamp: performance.now()
        };
        
        // Store in buffer for prediction
        this.inputBuffer.push(inputWithSequence);
        
        // Keep buffer size manageable
        if (this.inputBuffer.length > 60) { // ~1 second at 60fps
            this.inputBuffer.shift();
        }
        
        // Send to server
        this.channel.emit('playerInput', inputWithSequence);
    }
    
    // Game State Handling
    handleGameStateUpdate(data) {
        // Store previous state for interpolation
        this.previousServerState = this.lastServerState;
        this.lastServerState = data;
        this.serverUpdateTimestamp = performance.now();
        
        // Notify game of new state
        this.notifyGameStateUpdate(data);
    }
    
    // Get interpolated game state for smooth rendering
    getInterpolatedGameState() {
        if (!this.lastServerState || !this.previousServerState) {
            return this.lastServerState;
        }
        
        const now = performance.now();
        const timeSinceUpdate = now - this.serverUpdateTimestamp;
        const serverTickRate = 1000 / 60; // 60 FPS server
        
        // Calculate interpolation factor
        let alpha = timeSinceUpdate / serverTickRate;
        alpha = Math.max(0, Math.min(1, alpha)); // Clamp between 0 and 1
        
        // Interpolate between previous and current state
        return this.interpolateGameState(this.previousServerState, this.lastServerState, alpha);
    }
    
    interpolateGameState(prevState, currState, alpha) {
        if (!prevState || !currState) return currState;
        
        const interpolated = JSON.parse(JSON.stringify(currState));
        
        // Interpolate sheep positions
        if (prevState.sheep && currState.sheep) {
            for (let i = 0; i < Math.min(prevState.sheep.length, currState.sheep.length); i++) {
                const prevSheep = prevState.sheep[i];
                const currSheep = currState.sheep[i];
                
                if (prevSheep && currSheep) {
                    interpolated.sheep[i].position.x = this.lerp(prevSheep.position.x, currSheep.position.x, alpha);
                    interpolated.sheep[i].position.z = this.lerp(prevSheep.position.z, currSheep.position.z, alpha);
                }
            }
        }
        
        // Interpolate dog positions
        if (prevState.dogs && currState.dogs) {
            for (const dogId in currState.dogs) {
                if (prevState.dogs[dogId] && currState.dogs[dogId]) {
                    interpolated.dogs[dogId].position.x = this.lerp(
                        prevState.dogs[dogId].position.x, 
                        currState.dogs[dogId].position.x, 
                        alpha
                    );
                    interpolated.dogs[dogId].position.z = this.lerp(
                        prevState.dogs[dogId].position.z, 
                        currState.dogs[dogId].position.z, 
                        alpha
                    );
                }
            }
        }
        
        return interpolated;
    }
    
    lerp(a, b, t) {
        return a + (b - a) * t;
    }
    
    // Connection Recovery
    async attemptReconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.log('Max reconnect attempts reached');
            this.notifyError('Connection lost. Please refresh the page.');
            return;
        }
        
        this.reconnectAttempts++;
        console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);
        
        setTimeout(async () => {
            try {
                await this.connect();
                
                // If we were in a room, try to rejoin
                if (this.currentRoom && this.playerName) {
                    await this.joinRoom(this.currentRoom.code, this.playerName, this.dogType);
                }
            } catch (error) {
                console.error('Reconnection failed:', error);
                this.attemptReconnect();
            }
        }, this.reconnectDelay * this.reconnectAttempts); // Exponential backoff
    }
    
    // Ping Measurement
    startPingMeasurement() {
        this.stopPingMeasurement(); // Clear any existing interval
        
        // Send ping every 5 seconds
        this.pingInterval = setInterval(() => {
            this.sendPing();
        }, 5000);
        
        // Send initial ping
        this.sendPing();
    }
    
    stopPingMeasurement() {
        if (this.pingInterval) {
            clearInterval(this.pingInterval);
            this.pingInterval = null;
        }
        this.pendingPings.clear();
    }
    
    sendPing() {
        if (!this.connected || !this.channel) return;
        
        const pingId = ++this.pingRequestId;
        const timestamp = performance.now();
        
        this.pendingPings.set(pingId, timestamp);
        this.channel.emit('ping', { id: pingId, timestamp });
        
        // Clean up old pending pings (older than 10 seconds)
        const cutoff = timestamp - 10000;
        for (const [id, time] of this.pendingPings.entries()) {
            if (time < cutoff) {
                this.pendingPings.delete(id);
            }
        }
    }
    
    handlePingResponse(data) {
        if (!data || !data.id) return;
        
        const sendTime = this.pendingPings.get(data.id);
        if (sendTime) {
            const roundTripTime = performance.now() - sendTime;
            this.lastPing = roundTripTime;
            this.pendingPings.delete(data.id);
            
            // Notify about ping update (for UI)
            this.notifyPingUpdate(roundTripTime);
        }
    }
    
    // Event Notification Helpers
    notifyConnectionStateChange(state) {
        if (this.onConnectionStateChange) {
            this.onConnectionStateChange(state);
        }
    }
    
    notifyRoomUpdate(room) {
        if (this.onRoomUpdate) {
            this.onRoomUpdate(room);
        }
    }
    
    notifyGameStateUpdate(gameState) {
        if (this.onGameStateUpdate) {
            this.onGameStateUpdate(gameState);
        }
    }
    
    notifyPlayerUpdate(update) {
        if (this.onPlayerUpdate) {
            this.onPlayerUpdate(update);
        }
    }
    
    notifyError(message) {
        if (this.onError) {
            this.onError(message);
        }
    }
    
    notifyPingUpdate(pingMs) {
        if (this.onPingUpdate) {
            this.onPingUpdate(pingMs);
        }
    }
    
    // Getters
    isConnected() {
        return this.connected;
    }
    
    isInRoom() {
        return this.currentRoom !== null;
    }
    
    getCurrentRoom() {
        return this.currentRoom;
    }
    
    getPlayerId() {
        return this.playerId;
    }
    
    getPlayerName() {
        return this.playerName;
    }
    
    getDogType() {
        return this.dogType;
    }
    
    isCurrentHost() {
        return this.isHost;
    }
}
```

## js/OptimizedSheep.js

```javascript
import * as THREE from 'three';
import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
import { Vector2D } from './Vector2D.js';
import { Boid } from './Boid.js';

/**
 * OptimizedSheep - High-performance sheep system using modern GPU techniques
 * 
 * Features:
 * - Single InstancedMesh for all sheep (1 draw call!)
 * - Merged geometry with vertex colors
 * - GPU-based animation via vertex shader
 * - Efficient per-instance data management
 */

export class OptimizedSheepSystem {
    constructor(scene, sheepCount = 200) {
        this.scene = scene;
        this.sheepCount = sheepCount;
        this.sheep = [];
        this.audioManager = null;
        
        // Create geometry and materials
        this.createMergedGeometry();
        this.createOptimizedMaterial();
        
        // Create instanced mesh
        this.createInstancedMesh();
        
        // Initialize sheep data
        this.initializeSheepData();
    }
    
    /**
     * Create merged sheep geometry with vertex colors
     */
    createMergedGeometry() {
        const geometries = [];
        const colors = [];
        
        // Body - simplified ellipsoid
        const bodyGeometry = new THREE.SphereGeometry(0.8, 12, 8);
        bodyGeometry.scale(1, 0.9, 1.1);
        bodyGeometry.translate(0, 0.7, 0);
        
        // Add white color for body vertices
        const bodyColors = new Float32Array(bodyGeometry.attributes.position.count * 3);
        for (let i = 0; i < bodyColors.length; i += 3) {
            bodyColors[i] = 1;     // R
            bodyColors[i + 1] = 1; // G
            bodyColors[i + 2] = 1; // B
        }
        bodyGeometry.setAttribute('color', new THREE.BufferAttribute(bodyColors, 3));
        
        // Add vertex IDs for body
        const bodyVertexIds = new Float32Array(bodyGeometry.attributes.position.count);
        for (let i = 0; i < bodyVertexIds.length; i++) {
            bodyVertexIds[i] = Math.min(i, 49); // Body vertices: 0-49
        }
        bodyGeometry.setAttribute('vertexId', new THREE.BufferAttribute(bodyVertexIds, 1));
        geometries.push(bodyGeometry);
        
        // Head - smaller sphere merged with body
        const headGeometry = new THREE.SphereGeometry(0.35, 10, 6);
        headGeometry.scale(0.8, 0.9, 1.2);
        headGeometry.translate(0, 0.65, 0.65);
        
        // Add black color for head vertices
        const headColors = new Float32Array(headGeometry.attributes.position.count * 3);
        for (let i = 0; i < headColors.length; i += 3) {
            headColors[i] = 0.16;     // R
            headColors[i + 1] = 0.16; // G
            headColors[i + 2] = 0.16; // B
        }
        headGeometry.setAttribute('color', new THREE.BufferAttribute(headColors, 3));
        
        // Add vertex IDs for head
        const headVertexIds = new Float32Array(headGeometry.attributes.position.count);
        for (let i = 0; i < headVertexIds.length; i++) {
            headVertexIds[i] = 50 + Math.min(i, 49); // Head vertices: 50-99
        }
        headGeometry.setAttribute('vertexId', new THREE.BufferAttribute(headVertexIds, 1));
        geometries.push(headGeometry);
        
        // Create 4 legs as simple cylinders
        const legGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.5, 6);
        const legPositions = [
            { x: -0.25, z: 0.3 },  // front left
            { x: 0.25, z: 0.3 },   // front right
            { x: -0.25, z: -0.3 }, // back left
            { x: 0.25, z: -0.3 }   // back right
        ];
        
        legPositions.forEach((pos, index) => {
            const leg = legGeometry.clone();
            leg.translate(pos.x, 0.25, pos.z);
            
            // Add vertex IDs for animation in shader
            const vertexIds = new Float32Array(leg.attributes.position.count);
            for (let i = 0; i < vertexIds.length; i++) {
                vertexIds[i] = 100 + index * 10; // Leg ID encoding
            }
            leg.setAttribute('vertexId', new THREE.BufferAttribute(vertexIds, 1));
            
            // Black color for legs
            const legColors = new Float32Array(leg.attributes.position.count * 3);
            for (let i = 0; i < legColors.length; i += 3) {
                legColors[i] = 0.16;     // R
                legColors[i + 1] = 0.16; // G
                legColors[i + 2] = 0.16; // B
            }
            leg.setAttribute('color', new THREE.BufferAttribute(legColors, 3));
            
            geometries.push(leg);
        });
        
        // Merge all geometries
        this.mergedGeometry = BufferGeometryUtils.mergeGeometries(geometries);
        
        // Compute bounds for frustum culling
        this.mergedGeometry.computeBoundingBox();
        this.mergedGeometry.computeBoundingSphere();
    }
    
    /**
     * Create optimized material with custom shaders
     */
    createOptimizedMaterial() {
        // Vertex shader with GPU animation
        const vertexShader = `
            // Use built-in color attribute from Three.js
            attribute float vertexId;
            
            // Per-instance attributes
            attribute vec4 instanceData; // x: animPhase, y: speed, z: state, w: uniqueId
            attribute vec4 instanceAnimation; // x: walkCycle, y: bounce, z: direction, w: blinkTimer
            
            uniform float time;
            uniform float globalAnimSpeed;
            
            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            
            // Animation functions
            vec3 animateVertex(vec3 position, float vId) {
                vec3 animated = position;
                
                float animPhase = instanceData.x;
                float speed = instanceData.y;
                float walkCycle = instanceAnimation.x;
                float bounce = instanceAnimation.y;
                
                // Leg animation (vertexId 100-139)
                if (vId >= 100.0 && vId < 140.0) {
                    float legIndex = floor((vId - 100.0) / 10.0); // 0-3
                    float legPhase = legIndex < 2.0 ? 0.0 : 3.14159; // Front/back offset
                    float sidePhase = mod(legIndex, 2.0) * 1.57; // Left/right offset
                    
                    float legTime = time * globalAnimSpeed + animPhase + walkCycle;
                    float legLift = max(0.0, sin(legTime * 3.0 + legPhase + sidePhase)) * bounce * 2.0;
                    
                    animated.y += legLift * speed;
                    
                    // Slight forward/back motion
                    animated.z += sin(legTime * 3.0 + legPhase + sidePhase) * bounce * 0.3 * speed;
                }
                
                // Body bounce (vertexId 0-49)
                if (vId < 50.0) {
                    float bodyTime = time * globalAnimSpeed + animPhase;
                    animated.y += sin(bodyTime * 2.0) * bounce * 0.5 * speed;
                    
                    // Slight wobble
                    animated.x += sin(bodyTime * 2.5) * bounce * 0.1 * speed;
                }
                
                // Head bob (vertexId 50-99)
                if (vId >= 50.0 && vId < 100.0) {
                    float headTime = time * globalAnimSpeed + animPhase + 0.5;
                    animated.y += sin(headTime * 2.0) * bounce * 0.3 * speed;
                    
                    // Look direction
                    float lookAngle = instanceAnimation.z;
                    animated.x += sin(lookAngle) * 0.1;
                    animated.z += cos(lookAngle) * 0.1;
                }
                
                return animated;
            }
            
            void main() {
                // Access vertex color using built-in Three.js attribute
                #ifdef USE_COLOR
                    vColor = color;
                #else
                    vColor = vec3(1.0); // Default to white if no vertex colors
                #endif
                
                vNormal = normalMatrix * normal;
                
                // Animate vertex position
                vec3 animatedPosition = animateVertex(position, vertexId);
                
                // Apply instance transformation with proper matrix multiplication
                vec4 instancePosition = instanceMatrix * vec4(animatedPosition, 1.0);
                
                vec4 mvPosition = modelViewMatrix * instancePosition;
                vViewPosition = -mvPosition.xyz;
                
                gl_Position = projectionMatrix * mvPosition;
            }
        `;
        
        // Fragment shader with simple toon shading
        const fragmentShader = `
            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            
            uniform vec3 fogColor;
            uniform float fogNear;
            uniform float fogFar;
            
            void main() {
                // Simple toon shading
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(vViewPosition);
                
                // Basic lighting
                vec3 lightDir = normalize(vec3(0.3, 1.0, 0.5));
                float NdotL = dot(normal, lightDir);
                
                // Toon shading steps
                float toon = smoothstep(0.0, 0.01, NdotL) * 0.5 + 0.5;
                toon = floor(toon * 3.0) / 3.0;
                
                // Apply vertex color with toon shading
                vec3 finalColor = vColor * toon;
                
                // Apply fog
                float depth = length(vViewPosition);
                float fogFactor = smoothstep(fogNear, fogFar, depth);
                finalColor = mix(finalColor, fogColor, fogFactor);
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;
        
        this.material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms: {
                time: { value: 0 },
                globalAnimSpeed: { value: 1.0 },
                fogColor: { value: new THREE.Color(0x87CEEB) },
                fogNear: { value: 200 },
                fogFar: { value: 600 }
            },
            vertexColors: true,
            fog: false // We handle fog manually in shader
        });
    }
    
    /**
     * Create the instanced mesh with all sheep
     */
    createInstancedMesh() {
        this.instancedMesh = new THREE.InstancedMesh(
            this.mergedGeometry,
            this.material,
            this.sheepCount
        );
        
        // Enable shadows
        this.instancedMesh.castShadow = true;
        this.instancedMesh.receiveShadow = true;
        
        // Create instance attributes for animation data
        const instanceData = new THREE.InstancedBufferAttribute(
            new Float32Array(this.sheepCount * 4), 4
        );
        const instanceAnimation = new THREE.InstancedBufferAttribute(
            new Float32Array(this.sheepCount * 4), 4
        );
        
        this.mergedGeometry.setAttribute('instanceData', instanceData);
        this.mergedGeometry.setAttribute('instanceAnimation', instanceAnimation);
        
        // Add to scene
        this.scene.add(this.instancedMesh);
        
        // Disable frustum culling so sheep never disappear due to bounding sphere issues
        this.instancedMesh.frustumCulled = false;
    }
    
    /**
     * Initialize individual sheep instances
     */
    initializeSheepData() {
        const dummy = new THREE.Object3D();
        const spreadRadius = 30;
        
        for (let i = 0; i < this.sheepCount; i++) {
            // Random position in a cluster
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * spreadRadius;
            const x = -30 + Math.cos(angle) * distance;
            const z = -30 + Math.sin(angle) * distance;
            
            // Create sheep instance data
            const sheep = new OptimizedSheepInstance(i, x, z);
            this.sheep.push(sheep);
            
            // Set initial transform
            dummy.position.set(x, 0, z);
            dummy.rotation.y = Math.random() * Math.PI * 2;
            dummy.updateMatrix();
            this.instancedMesh.setMatrixAt(i, dummy.matrix);
            
            // Set initial animation data
            this.updateInstanceAttributes(i, sheep);
        }
        
        this.instancedMesh.instanceMatrix.needsUpdate = true;
    }
    
    /**
     * Update instance attributes for a specific sheep
     */
    updateInstanceAttributes(index, sheep) {
        const instanceData = this.mergedGeometry.attributes.instanceData;
        const instanceAnimation = this.mergedGeometry.attributes.instanceAnimation;
        
        if (!instanceData || !instanceAnimation) return;
        
        // Instance data: animPhase, speed, state, uniqueId
        instanceData.setXYZW(
            index,
            sheep.animationPhase,
            sheep.currentSpeed,
            sheep.state, // 0: active, 1: retiring, 2: retired
            index
        );
        
        // Animation data: walkCycle, bounce, direction, blinkTimer
        instanceAnimation.setXYZW(
            index,
            sheep.walkCycle,
            sheep.bounceAmount,
            sheep.facingDirection,
            sheep.blinkTimer
        );
        
        instanceData.needsUpdate = true;
        instanceAnimation.needsUpdate = true;
    }
    
    /**
     * Update all sheep behaviors and animations
     */
    update(deltaTime, sheepdog, gate, pasture, bounds, params, enableIndividualBleating = true, isMultiplayer = false) {
        const dummy = new THREE.Object3D();
        
        // Update time uniform
        this.material.uniforms.time.value += deltaTime;
        
        // Ensure instance matrix is available
        if (!this.instancedMesh.instanceMatrix) {
            console.warn('Instance matrix not available');
            return;
        }
        
        // Track sheep being chased for group audio
        let sheepBeingChased = 0;
        let shouldPlayGroupBleat = false;
        
        // Update each sheep
        for (let i = 0; i < this.sheepCount; i++) {
            const sheep = this.sheep[i];
            
            // Check if this sheep is being chased (before updating behavior)
            if (sheepdog && sheep.position) {
                const distanceToSheepdog = sheep.position.distanceTo(sheepdog.position);
                // Use sheepdog's fleeRadius for dog-specific interaction distances
                const fleeRadius = sheepdog.fleeRadius || sheep.fleeRadius || 8;
                const isBeingChased = distanceToSheepdog < fleeRadius;
                
                if (isBeingChased && !sheep.wasBeingChased) {
                    sheepBeingChased++;
                    shouldPlayGroupBleat = true;
                }
            }
            
            // Update behavior (flocking, movement, etc.)
            sheep.updateBehavior(this.sheep, sheepdog, gate, pasture, bounds, params, enableIndividualBleating, isMultiplayer);
            sheep.updatePosition(deltaTime);
            
            // Update transform matrix using interpolated render position for smooth movement
            dummy.position.set(sheep.renderPosition.x, 0, sheep.renderPosition.z);
            dummy.rotation.y = -sheep.renderFacingDirection + Math.PI / 2;
            
            // Keep all sheep visible - no hiding for grazing sheep
            dummy.scale.set(1, 1, 1);
            
            dummy.updateMatrix();

            // Defensive check for NaN/Infinity in the dummy matrix before setting instanceMatrix
            let matrixIsValid = true;
            for (let j = 0; j < 16; j++) {
                if (isNaN(dummy.matrix.elements[j]) || !isFinite(dummy.matrix.elements[j])) {
                    matrixIsValid = false;
                    break;
                }
            }

            if (matrixIsValid) {
                this.instancedMesh.setMatrixAt(i, dummy.matrix);
            } else {
                console.warn(`Sheep ${sheep.id} produced invalid matrix. Skipping update for this instance.`);
                // Optionally, set to an identity matrix or last known good matrix for this instance
                // For now, we just skip, which means it won't update its visual position/rotation
                // which might make it appear stuck, but it's better than a crash or full invisibility.
            }
            
            // Update animation attributes
            this.updateInstanceAttributes(i, sheep);
        }
        
        // Play group bleat if multiple sheep started being chased this frame
        if (shouldPlayGroupBleat && sheepBeingChased > 0 && this.audioManager) {
            if (sheepBeingChased === 1) {
                this.audioManager.playSheepBleat(); // Single bleat for one sheep
            } else {
                this.audioManager.playGroupSheepBleats(sheepBeingChased); // Layered bleats for multiple sheep
            }
        }
        
        this.instancedMesh.instanceMatrix.needsUpdate = true;
    }
    
    /**
     * Force update sheep positions for multiplayer mode (no interpolation)
     */
    forceUpdateSheepPositions() {
        const dummy = new THREE.Object3D();
        
        for (let i = 0; i < this.sheepCount; i++) {
            const sheep = this.sheep[i];
            
            // Force render position to match physics position immediately
            sheep.renderPosition.x = sheep.position.x;
            sheep.renderPosition.z = sheep.position.z;
            sheep.renderFacingDirection = sheep.facingDirection;
            
            // Update transform matrix
            dummy.position.set(sheep.renderPosition.x, 0, sheep.renderPosition.z);
            dummy.rotation.y = -sheep.renderFacingDirection + Math.PI / 2;
            dummy.scale.set(1, 1, 1);
            dummy.updateMatrix();
            
            this.instancedMesh.setMatrixAt(i, dummy.matrix);
            
            // Update animation attributes
            this.updateInstanceAttributes(i, sheep);
        }
        
        this.instancedMesh.instanceMatrix.needsUpdate = true;
    }
    
    /**
     * Get all sheep instances
     */
    getSheep() {
        return this.sheep;
    }
    
    /**
     * Set audio manager for sound effects
     */
    setAudioManager(audioManager) {
        this.audioManager = audioManager;
        // Pass audio manager to all sheep instances
        this.sheep.forEach(sheep => {
            sheep.setAudioManager(audioManager);
        });
    }
    
    /**
     * Reset all sheep to their starting positions and states
     */
    resetAllSheep() {
        const dummy = new THREE.Object3D();
        const spreadRadius = 30;
        
        for (let i = 0; i < this.sheepCount; i++) {
            const sheep = this.sheep[i];
            
            // Reset position to starting area
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * spreadRadius;
            const x = -30 + Math.cos(angle) * distance;
            const z = -30 + Math.sin(angle) * distance;
            
            // Reset sheep state - now using the set method
            sheep.position.set(x, z);
            sheep.velocity.set(0, 0);
            sheep.acceleration.set(0, 0);
            sheep.hasPassedGate = false;
            sheep.isRetiring = false;
            sheep.retirementTarget = null;
            sheep.state = 0; // Active state
            sheep.maxSpeed = 0.1;
            sheep.maxForce = 0.02;
            
            // Reset animation properties
            sheep.animationPhase = Math.random() * Math.PI * 2;
            sheep.walkCycle = 0;
            sheep.bounceAmount = 0;
            sheep.currentSpeed = 0;
            sheep.facingDirection = Math.random() * Math.PI * 2;
            sheep.blinkTimer = Math.random() * 5;
            
            // Reset interpolated render position to match physics position
            sheep.renderPosition.set(x, z);
            sheep.renderFacingDirection = sheep.facingDirection;
            
            // Update transform matrix
            dummy.position.set(x, 0, z);
            dummy.rotation.y = sheep.facingDirection;
            dummy.scale.set(1, 1, 1);
            dummy.updateMatrix();
            this.instancedMesh.setMatrixAt(i, dummy.matrix);
            
            // Update animation attributes
            this.updateInstanceAttributes(i, sheep);
        }
        
        this.instancedMesh.instanceMatrix.needsUpdate = true;
    }
}

/**
 * Individual sheep instance data
 */
export class OptimizedSheepInstance extends Boid {
    constructor(id, x, z) {
        super(x, z, {
            maxSpeed: 0.1,
            maxForce: 0.02,
            perceptionRadius: 5
        });
        
        this.id = id;
        this.state = 0; // 0: active, 1: retiring, 2: retired
        
        // Animation properties
        this.animationPhase = Math.random() * Math.PI * 2;
        this.walkCycle = 0;
        this.bounceAmount = 0;
        this.currentSpeed = 0;
        this.facingDirection = 0;
        this.blinkTimer = Math.random() * 5;
        
        // Interpolation properties for smooth visual movement
        this.renderPosition = new Vector2D(x, z); // Smoothed position for rendering
        this.renderFacingDirection = 0; // Smoothed facing direction for rendering
        this.interpolationSpeed = 8.0; // How fast to interpolate (higher = faster catch-up)
        this.rotationInterpolationSpeed = 12.0; // Faster rotation interpolation
        
        // Behavior properties
        this.hasPassedGate = false;
        this.isRetiring = false;
        this.retirementTarget = null;
        this.fleeRadius = 8;
        this.gateAttraction = 0.5;
        this.audioManager = null;
        
        // Audio tracking
        this.wasBeingChased = false;
    }
    
    updateBehavior(allSheep, sheepdog, gate, pasture, bounds, params, enableIndividualBleating = true, isMultiplayer = false) {
        // If retiring, seek retirement target or graze
        if (this.isRetiring) {
            if (this.retirementTarget) {
                const distanceToTarget = this.position.distanceTo(this.retirementTarget);
                
                if (distanceToTarget < 2) {
                    // Sheep has reached its retirement spot - enter grazing mode
                    this.retirementTarget = null; // Clear target to enter grazing mode
                    this.maxSpeed = 0.02; // Very slow grazing speed
                    this.maxForce = 0.005; // Gentle forces
                    this.state = 2; // Set to grazing state
                } else {
                    // Still moving to retirement spot
                    const seekForce = this.seek(this.retirementTarget);
                    this.applyForce(seekForce);
                }
            } else {
                // Grazing behavior - gentle wandering
                this.animationPhase += 0.016;
                
                // Occasional gentle movement
                if (Math.random() < 0.002) { // 0.2% chance per frame to start moving
                    const wanderDirection = Vector2D.random();
                    wanderDirection.multiply(0.5); // Gentle movement
                    this.applyForce(wanderDirection);
                }
                
                // Stay within pasture bounds with gentle forces
                if (pasture) {
                    const pastureMargin = 2;
                    const steer = new Vector2D(0, 0);
                    
                    if (this.position.x < pasture.minX + pastureMargin) {
                        steer.x = 0.01;
                    } else if (this.position.x > pasture.maxX - pastureMargin) {
                        steer.x = -0.01;
                    }
                    
                    if (this.position.z < pasture.minZ + pastureMargin) {
                        steer.z = 0.01;
                    } else if (this.position.z > pasture.maxZ - pastureMargin) {
                        steer.z = -0.01;
                    }
                    
                    if (steer.magnitude() > 0) {
                        this.applyForce(steer);
                    }
                }
            }
            return;
        }
        
        // Only check gate passage if gate and pasture are available (game is active)
        if (gate && pasture && this.hasPassedGate && !this.isRetiring) {
            this.isRetiring = true;
            this.state = 1; // retiring
            this.retirementTarget = new Vector2D(
                pasture.minX + Math.random() * (pasture.maxX - pasture.minX),
                pasture.centerZ + Math.random() * 20
            );
            this.maxSpeed *= 0.5;
            this.maxForce *= 0.5;
            return;
        }
        
        // Normal flocking behavior (always active)
        this.flock(allSheep, params.separationDistance);
        
        // Add gentle wandering during pre-game state (when no sheepdog)
        if (!sheepdog) {
            // Gentle wandering to make the start screen more lively
            if (Math.random() < 0.01) { // 1% chance per frame for gentle movement
                const wanderDirection = Vector2D.random();
                wanderDirection.multiply(0.3); // Gentle wandering force
                this.applyForce(wanderDirection);
            }
        }
        
        // Flee from sheepdog (only if sheepdog exists - game is active)
        if (sheepdog) {
            const distanceToSheepdog = this.position.distanceTo(sheepdog.position);
            // Use sheepdog's fleeRadius for dog-specific interaction distances
            const fleeRadius = sheepdog.fleeRadius || this.fleeRadius || 8;
            const isBeingChased = distanceToSheepdog < fleeRadius;
            
            const fleeForce = this.flee(sheepdog.position, fleeRadius);
            if (fleeForce.magnitude() > 0) {
                fleeForce.multiply(1.2);
                this.applyForce(fleeForce);
                
                // Play bleat sound when sheep starts being chased (only if individual bleating is enabled)
                if (isBeingChased && !this.wasBeingChased && this.audioManager && enableIndividualBleating) {
                    this.audioManager.playSheepBleat();
                }
            }
            
            this.wasBeingChased = isBeingChased;
        } else {
            this.wasBeingChased = false;
        }
        
        // Gate attraction logic (only if sheepdog and gate exist - game is active)
        if (sheepdog && gate) {
            const distanceToGate = this.position.distanceTo(gate.position);
            const distanceToDog = this.position.distanceTo(sheepdog.position);
            // Use sheepdog's fleeRadius for dog-specific interaction distances
            const fleeRadius = sheepdog.fleeRadius || this.fleeRadius || 8;
            
            if (distanceToDog < fleeRadius * 1.5 && distanceToGate < 30) {
                const toGate = gate.position.clone().subtract(this.position);
                const toDog = sheepdog.position.clone().subtract(this.position);
                
                const dotProduct = toGate.x * toDog.x + toGate.z * toDog.z;
                if (dotProduct < 0) {
                    const gateForce = this.seek(gate.position);
                    gateForce.multiply(this.gateAttraction);
                    this.applyForce(gateForce);
                }
            }
        }
        
        // Boundary avoidance (always active)
        const boundaryForce = this.avoidBoundariesWithGate(bounds, gate);
        this.applyForce(boundaryForce);
        
        this.maxSpeed = params.speed;
        this.cohesionWeight = params.cohesion;
    }
    
    updatePosition(deltaTime) {
        // Standard Boid update
        super.update(deltaTime); // This updates this.position and this.velocity
        
        // HARD BOUNDARY CONSTRAINT - Apply only to sheep that haven't passed the gate
        if (this.bounds && !this.hasPassedGate) {
            const margin = 0.2; // Small margin from edge
            
            // Check if sheep is in the gate area (allow passage through gate)
            const inGateArea = Math.abs(this.position.x) <= 4 && this.position.z >= 98 && this.position.z <= 102;
            
            // Apply hard constraints unless in gate area
            if (!inGateArea) {
                this.position.x = Math.max(this.bounds.minX + margin, Math.min(this.bounds.maxX - margin, this.position.x));
                this.position.z = Math.max(this.bounds.minZ + margin, Math.min(this.bounds.maxZ - margin, this.position.z));
            } else {
                // In gate area - only constrain X to gate width, allow Z movement
                this.position.x = Math.max(-4, Math.min(4, this.position.x));
                // Don't constrain Z in gate area to allow passage
            }
        }
        
        // NaN/Infinity checks for velocity and position
        if (isNaN(this.velocity.x) || isNaN(this.velocity.z) || !isFinite(this.velocity.x) || !isFinite(this.velocity.z)) {
            console.warn(`Sheep ${this.id} velocity became NaN/Infinity:`, this.velocity.x, this.velocity.z);
            this.velocity.set(0, 0); // Reset velocity
        }
        if (isNaN(this.position.x) || isNaN(this.position.z) || !isFinite(this.position.x) || !isFinite(this.position.z)) {
            console.warn(`Sheep ${this.id} position became NaN/Infinity:`, this.position.x, this.position.z);
            // Attempt to reset to a safe position, e.g., center of field, or last known good position
            this.position.set(0, -30); // Reset to initial-like position
            this.velocity.set(0, 0); // Also reset velocity
        }
        
        // Update animation parameters based on movement
        const speed = this.velocity.magnitude();
        
        if (isNaN(speed) || !isFinite(speed)) {
            console.warn(`Sheep ${this.id} speed became NaN/Infinity.`);
            this.currentSpeed = 0;
            this.bounceAmount = 0;
        } else {
            this.currentSpeed = speed / (this.maxSpeed > 0.00001 ? this.maxSpeed : 0.1); // Avoid division by zero for maxSpeed
            this.bounceAmount = Math.min(speed * 15, 0.15);
        }
        
        this.walkCycle += this.currentSpeed * deltaTime * 10; // Use currentSpeed which is now NaN-checked
        
        if (this.currentSpeed > 0.001) {
            this.facingDirection = Math.atan2(this.velocity.z, this.velocity.x);
            if (isNaN(this.facingDirection) || !isFinite(this.facingDirection)) {
                console.warn(`Sheep ${this.id} facingDirection became NaN/Infinity.`);
                this.facingDirection = 0;
            }
        } else {
             // Keep last facing direction if not moving, or default to 0
            // this.facingDirection = this.facingDirection || 0;
        }
        
        // Update blink timer
        this.blinkTimer += deltaTime;
        if (this.blinkTimer > 3 + Math.random() * 4) {
            this.blinkTimer = 0;
        }
        
        // Interpolate render position for smooth visual movement
        this.updateRenderPosition(deltaTime);
    }
    
    /**
     * Update interpolated render position for smooth visual movement
     */
    updateRenderPosition(deltaTime) {
        // Interpolate position smoothly towards actual physics position
        const positionDiff = this.position.clone().subtract(this.renderPosition);
        const interpolationAmount = Math.min(1.0, this.interpolationSpeed * deltaTime);
        
        // Apply position interpolation
        this.renderPosition.add(positionDiff.multiply(interpolationAmount));
        
        // Interpolate facing direction smoothly
        if (this.currentSpeed > 0.001) {
            // Calculate target facing direction from velocity
            const targetFacing = Math.atan2(this.velocity.z, this.velocity.x);
            
            // Handle angle wrapping for smooth rotation
            let angleDiff = targetFacing - this.renderFacingDirection;
            
            // Normalize angle difference to [-π, π]
            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
            
            // Apply rotation interpolation
            const rotationInterpolationAmount = Math.min(1.0, this.rotationInterpolationSpeed * deltaTime);
            this.renderFacingDirection += angleDiff * rotationInterpolationAmount;
            
            // Normalize final angle
            while (this.renderFacingDirection > Math.PI) this.renderFacingDirection -= 2 * Math.PI;
            while (this.renderFacingDirection < -Math.PI) this.renderFacingDirection += 2 * Math.PI;
        }
    }
    
    // Boundary avoidance that excludes gate area
    avoidBoundariesWithGate(bounds, gate) {
        const margin = 3;
        const steer = new Vector2D(0, 0);
        const position = this.position;
        
        const distToMinX = position.x - bounds.minX;
        const distToMaxX = bounds.maxX - position.x;
        const distToMinZ = position.z - bounds.minZ;
        const distToMaxZ = bounds.maxZ - position.z;
        
        if (distToMinX < margin) {
            const force = (margin - distToMinX) / margin;
            steer.x = this.maxSpeed * force * 1.2;
        } else if (distToMaxX < margin) {
            const force = (margin - distToMaxX) / margin;
            steer.x = -this.maxSpeed * force * 1.2;
        }
        
        if (distToMinZ < margin) {
            const force = (margin - distToMinZ) / margin;
            steer.z = this.maxSpeed * force * 1.2;
        } else if (distToMaxZ < margin) {
            // Only check for gate if gate exists (game is active)
            const nearGateX = gate ? Math.abs(position.x - gate.position.x) < gate.width / 2 + 2 : false;
            if (!nearGateX) {
                const force = (margin - distToMaxZ) / margin;
                steer.z = -this.maxSpeed * force * 1.2;
            }
        }
        
        if (steer.magnitude() > 0) {
            steer.normalize();
            steer.multiply(this.maxSpeed * 1.5);
            steer.subtract(this.velocity);
            steer.limit(this.maxForce * 2.5);
        }
        
        return steer;
    }
    
    checkGatePassageAndRetire(gatePassageZone, pastureBounds) {
        if (this.hasPassedGate) return false;
        
        const inGateX = this.position.x >= gatePassageZone.minX && 
                       this.position.x <= gatePassageZone.maxX;
        const inGateZ = this.position.z >= gatePassageZone.minZ && 
                       this.position.z <= gatePassageZone.maxZ;
        
        if (inGateX && inGateZ && this.velocity.z > 0) {
            this.hasPassedGate = true;
            return true;
        }
        
        return false;
    }
    
    setBounds(bounds) {
        this.bounds = bounds;
    }
    
    setAudioManager(audioManager) {
        this.audioManager = audioManager;
    }
}
```

## js/PerformanceMonitor.js

```javascript
/**
 * PerformanceMonitor.js
 * 
 * Comprehensive performance monitoring system for the sheep dog simulation.
 * Integrates Stats.js for real-time FPS/memory tracking and provides
 * custom metrics for simulation-specific performance analysis.
 */

/**
 * Performance monitoring and statistics display
 * Provides real-time FPS, memory usage, and simulation-specific metrics
 */
export class PerformanceMonitor {
    constructor() {
        this.stats = null;
        this.customStats = null;
        this.isEnabled = false;
        this.frameCount = 0;
        this.lastFrameTime = performance.now();
        this.frameTimeHistory = [];
        this.maxHistoryLength = 60; // Keep 1 second of frame times at 60fps
        
        // Performance metrics
        this.metrics = {
            sheepCount: 0,
            activeSheepCount: 0,
            grassInstances: 0,
            drawCalls: 0,
            triangles: 0,
            avgFrameTime: 0,
            minFrameTime: Infinity,
            maxFrameTime: 0,
            geometries: 0,
            textures: 0,
            programs: 0
        };
        
        this.init();
    }
    
    /**
     * Initialize Stats.js and custom performance displays
     */
    async init() {
        try {
            // Try to load Stats.js from CDN using a script tag
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js';
            
            await new Promise((resolve, reject) => {
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
            
            // Wait a bit for Stats to be available globally
            await new Promise(resolve => setTimeout(resolve, 100));
            
            if (typeof Stats !== 'undefined') {
                // Create main Stats.js instance for FPS
                this.stats = new Stats();
                this.stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
                this.stats.dom.style.position = 'absolute';
                this.stats.dom.style.left = '20px';
                this.stats.dom.style.top = '120px';
                this.stats.dom.style.zIndex = '100';
                
                // Create custom stats panel for simulation metrics
                this.createCustomStatsPanel();
                
                // Add to DOM but hide by default
                document.body.appendChild(this.stats.dom);
                document.body.appendChild(this.customStats);
                
                // Hide stats by default
                this.stats.dom.style.display = 'none';
                this.customStats.style.display = 'none';
                
                this.isEnabled = true;
                console.log('PerformanceMonitor: Stats.js integration successful');
            } else {
                throw new Error('Stats.js not available');
            }
            
        } catch (error) {
            console.warn('PerformanceMonitor: Failed to load Stats.js, using fallback metrics', error);
            this.createFallbackDisplay();
        }
    }
    
    /**
     * Create custom statistics panel for simulation-specific metrics
     */
    createCustomStatsPanel() {
        this.customStats = document.createElement('div');
        this.customStats.style.cssText = `
            position: absolute;
            left: 20px;
            top: 200px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 8px;
            border-radius: 4px;
            z-index: 100;
            min-width: 180px;
            line-height: 1.4;
        `;
        
        this.updateCustomStats();
    }
    
    /**
     * Create fallback display when Stats.js fails to load
     */
    createFallbackDisplay() {
        this.customStats = document.createElement('div');
        this.customStats.style.cssText = `
            position: absolute;
            left: 20px;
            top: 120px;
            background: rgba(0, 0, 0, 0.8);
            color: #ffff00;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 8px;
            border-radius: 4px;
            z-index: 100;
            min-width: 200px;
            line-height: 1.4;
        `;
        
        document.body.appendChild(this.customStats);
        
        // Hide stats by default
        this.customStats.style.display = 'none';
        
        this.isEnabled = true;
    }
    
    /**
     * Update performance metrics
     * @param {Object} gameState - Current game state
     * @param {Object} renderer - Three.js renderer
     */
    updateMetrics(gameState, renderer) {
        if (!this.isEnabled) return;
        
        const currentTime = performance.now();
        const frameTime = currentTime - this.lastFrameTime;
        this.lastFrameTime = currentTime;
        
        // Update frame time statistics
        this.frameTimeHistory.push(frameTime);
        if (this.frameTimeHistory.length > this.maxHistoryLength) {
            this.frameTimeHistory.shift();
        }
        
        // Calculate frame time metrics
        this.metrics.avgFrameTime = this.frameTimeHistory.reduce((a, b) => a + b, 0) / this.frameTimeHistory.length;
        this.metrics.minFrameTime = Math.min(this.metrics.minFrameTime, frameTime);
        this.metrics.maxFrameTime = Math.max(this.metrics.maxFrameTime, frameTime);
        
        // Update simulation metrics
        if (gameState) {
            const sheep = gameState.getSheep();
            this.metrics.sheepCount = sheep ? sheep.length : 0;
            // Count sheep that haven't passed the gate and aren't retiring (active sheep)
            this.metrics.activeSheepCount = sheep ? sheep.filter(s => !s.hasPassedGate && !s.isRetiring).length : 0;
        }
        
        // Update renderer metrics
        if (renderer && renderer.info) {
            this.metrics.drawCalls = renderer.info.render.calls;
            this.metrics.triangles = renderer.info.render.triangles;
            this.metrics.geometries = renderer.info.memory.geometries;
            this.metrics.textures = renderer.info.memory.textures;
            this.metrics.programs = renderer.info.programs ? renderer.info.programs.length : 0;
        }
        
        this.frameCount++;
        
        // Update displays
        if (this.stats) {
            this.stats.update();
        }
        
        // Update custom stats every 10 frames to reduce overhead
        if (this.frameCount % 10 === 0) {
            this.updateCustomStats();
        }
    }
    
    /**
     * Update custom statistics display
     */
    updateCustomStats() {
        if (!this.customStats) return;
        
        const fps = this.frameTimeHistory.length > 0 ? 
            (1000 / this.metrics.avgFrameTime).toFixed(1) : '0';
        
        const memoryInfo = this.getMemoryInfo();
        
        // Color-code FPS for performance indication
        const fpsColor = parseFloat(fps) >= 58 ? '#00ff00' : parseFloat(fps) >= 45 ? '#ffff00' : '#ff4444';
        
        this.customStats.innerHTML = `
            <div style="color: #00ff00; font-weight: bold; margin-bottom: 4px;">SIMULATION STATS</div>
            <div>Sheep Total: ${this.metrics.sheepCount}</div>
            <div>Sheep Active: ${this.metrics.activeSheepCount}</div>
            <div>Grass Instances: ${this.metrics.grassInstances.toLocaleString()}</div>
            <div style="margin-top: 4px; color: #ffff00;">RENDER STATS</div>
            <div>Draw Calls: ${this.metrics.drawCalls}</div>
            <div>Triangles: ${this.metrics.triangles.toLocaleString()}</div>
            <div>Geometries: ${this.metrics.geometries}</div>
            <div>Textures: ${this.metrics.textures}</div>
            <div>Programs: ${this.metrics.programs}</div>
            <div style="margin-top: 4px; color: #ff8800;">FRAME STATS</div>
            <div style="color: ${fpsColor};">Avg FPS: ${fps}</div>
            <div>Frame Time: ${this.metrics.avgFrameTime.toFixed(2)}ms</div>
            <div>Min/Max: ${this.metrics.minFrameTime.toFixed(1)}/${this.metrics.maxFrameTime.toFixed(1)}ms</div>
            ${memoryInfo}
        `;
    }
    
    /**
     * Get memory information if available
     */
    getMemoryInfo() {
        if (performance.memory) {
            const used = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
            const total = (performance.memory.totalJSHeapSize / 1048576).toFixed(1);
            return `
                <div style="margin-top: 4px; color: #ff4444;">MEMORY</div>
                <div>Used: ${used} MB</div>
                <div>Total: ${total} MB</div>
            `;
        }
        return '';
    }
    
    /**
     * Set grass instance count for display
     * @param {number} count - Number of grass instances
     */
    setGrassInstanceCount(count) {
        this.metrics.grassInstances = count;
    }
    
    /**
     * Toggle performance monitor visibility
     */
    toggle() {
        if (!this.isEnabled) return;
        
        const isVisible = this.stats ? this.stats.dom.style.display !== 'none' : 
                         this.customStats.style.display !== 'none';
        
        if (this.stats) {
            this.stats.dom.style.display = isVisible ? 'none' : 'block';
        }
        if (this.customStats) {
            this.customStats.style.display = isVisible ? 'none' : 'block';
        }
    }
    
    /**
     * Show performance monitor
     */
    show() {
        if (!this.isEnabled) return;
        
        if (this.stats) {
            this.stats.dom.style.display = 'block';
        }
        if (this.customStats) {
            this.customStats.style.display = 'block';
        }
    }
    
    /**
     * Hide performance monitor
     */
    hide() {
        if (!this.isEnabled) return;
        
        if (this.stats) {
            this.stats.dom.style.display = 'none';
        }
        if (this.customStats) {
            this.customStats.style.display = 'none';
        }
    }
    
    /**
     * Reset performance statistics
     */
    reset() {
        this.frameTimeHistory = [];
        this.metrics.minFrameTime = Infinity;
        this.metrics.maxFrameTime = 0;
        this.frameCount = 0;
    }
    
    /**
     * Get current performance metrics
     * @returns {Object} Current metrics object
     */
    getMetrics() {
        return { ...this.metrics };
    }
    
    /**
     * Check if performance monitor is enabled
     * @returns {boolean} True if enabled
     */
    isActive() {
        return this.isEnabled;
    }
    
    /**
     * Get performance recommendations based on current metrics
     * @returns {Array} Array of performance recommendations
     */
    getPerformanceRecommendations() {
        const recommendations = [];
        const avgFps = this.frameTimeHistory.length > 0 ? 
            (1000 / this.metrics.avgFrameTime) : 0;
        
        if (avgFps < 45) {
            recommendations.push("Low FPS detected. Consider reducing grass instances or shadow quality.");
        }
        
        if (this.metrics.drawCalls > 50) {
            recommendations.push("High draw call count. Consider using more instanced rendering.");
        }
        
        if (this.metrics.triangles > 2000000) {
            recommendations.push("High triangle count. Consider using LOD (Level of Detail) systems.");
        }
        
        if (this.metrics.grassInstances > 500000 && avgFps < 60) {
            recommendations.push("Grass instance count may be too high for current hardware.");
        }
        
        return recommendations;
    }
    
    /**
     * Log performance summary to console
     */
    logPerformanceSummary() {
        if (!this.isEnabled) return;
        
        const avgFps = this.frameTimeHistory.length > 0 ? 
            (1000 / this.metrics.avgFrameTime).toFixed(1) : '0';
        
        console.group('🔍 Performance Summary');
        console.log(`📊 Average FPS: ${avgFps}`);
        console.log(`🐑 Active Sheep: ${this.metrics.activeSheepCount}/${this.metrics.sheepCount}`);
        console.log(`🌱 Grass Instances: ${this.metrics.grassInstances.toLocaleString()}`);
        console.log(`🎨 Draw Calls: ${this.metrics.drawCalls}`);
        console.log(`📐 Triangles: ${this.metrics.triangles.toLocaleString()}`);
        console.log(`⏱️ Frame Time: ${this.metrics.avgFrameTime.toFixed(2)}ms`);
        
        const recommendations = this.getPerformanceRecommendations();
        if (recommendations.length > 0) {
            console.group('💡 Recommendations');
            recommendations.forEach(rec => console.log(`• ${rec}`));
            console.groupEnd();
        }
        
        console.groupEnd();
    }
}
```

## js/SceneManager.js

```javascript
import * as THREE from 'three';

/**
 * SceneManager - Handles Three.js scene setup, lighting, and camera management
 * Enhanced with mobile zoom control support
 */
export class SceneManager {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(
            75, 
            window.innerWidth / window.innerHeight, 
            0.1, 
            1000
        );
        
        this.renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance", // Use discrete GPU if available
            stencil: false // Disable stencil buffer if not needed
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        // Performance optimizations
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        
        // Enable frustum culling and other optimizations
        this.renderer.sortObjects = true;
        this.renderer.autoClear = true;
        
        document.getElementById('canvas-container').appendChild(this.renderer.domElement);
        
        // Camera control
        this.cameraDistance = 80;
        this.minCameraDistance = 20;
        this.maxCameraDistance = 150;
        this.mobileControls = null;
        
        this.init();
    }
    
    init() {
        // Set scene background
        this.scene.background = new THREE.Color(0x87CEEB); // Sky blue
        this.scene.fog = new THREE.Fog(0x87CEEB, 200, 600); // Extended fog for larger world
        
        // Setup camera - adjusted for larger field
        this.camera.position.set(0, 60, -60);
        this.camera.lookAt(0, 0, 0);
        
        // Add lighting
        this.setupLighting();
        
        // Handle window resize
        window.addEventListener('resize', () => this.onWindowResize());
    }
    
    setupLighting() {
        // Ambient light - adjusted for new lighting model (multiply by PI for similar appearance)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7 * Math.PI);
        this.scene.add(ambientLight);
        
        // Directional light (sun) - adjusted for new lighting model
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8 * Math.PI);
        directionalLight.position.set(30, 70, 30);
        directionalLight.castShadow = true;
        
        // Shadow configuration - adjusted for larger field
        directionalLight.shadow.camera.left = -120;
        directionalLight.shadow.camera.right = 120;
        directionalLight.shadow.camera.top = 120;
        directionalLight.shadow.camera.bottom = -120;
        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 150;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        
        this.scene.add(directionalLight);
        
        // Add a subtle secondary light for better depth - adjusted for new lighting model
        const secondaryLight = new THREE.DirectionalLight(0xffd4a3, 0.3 * Math.PI);
        secondaryLight.position.set(-50, 40, -50);
        this.scene.add(secondaryLight);
    }
    
    updateCamera(sheepdog) {
        // Update camera to follow sheepdog - adjusted for dynamic zoom
        const cameraOffset = new THREE.Vector3(0, this.cameraDistance, -this.cameraDistance);
        const targetPosition = new THREE.Vector3(
            sheepdog.position.x,
            0,
            sheepdog.position.z
        );
        
        this.camera.position.lerp(targetPosition.clone().add(cameraOffset), 0.05);
        this.camera.lookAt(targetPosition);
    }
    
    // Set mobile controls reference for zoom integration
    setMobileControls(mobileControls) {
        this.mobileControls = mobileControls;
        
        // Set up zoom change callback for mobile controls
        if (mobileControls) {
            mobileControls.setZoomChangeCallback((zoomLevel) => {
                this.cameraDistance = zoomLevel;
            });
        }
    }
    
    setupMouseControls() {
        // Mouse wheel for zoom (desktop only)
        this.renderer.domElement.addEventListener('wheel', (event) => {
            event.preventDefault();
            
            // Only handle mouse wheel if not on mobile device
            if (this.mobileControls && this.mobileControls.getIsTouchDevice()) {
                return;
            }
            
            const zoomSpeed = 5;
            
            if (event.deltaY > 0) {
                // Zoom out
                this.cameraDistance = Math.min(this.maxCameraDistance, this.cameraDistance + zoomSpeed);
            } else {
                // Zoom in
                this.cameraDistance = Math.max(this.minCameraDistance, this.cameraDistance - zoomSpeed);
            }
            
            // Update mobile zoom slider if available
            if (this.mobileControls && this.mobileControls.zoomSlider) {
                this.mobileControls.zoomSlider.value = this.cameraDistance;
                this.mobileControls.zoomLevel = this.cameraDistance;
            }
        });
    }
    
    // Get current camera distance for mobile controls synchronization
    getCameraDistance() {
        return this.cameraDistance;
    }
    
    // Set camera distance (used by mobile controls)
    setCameraDistance(distance) {
        this.cameraDistance = Math.max(this.minCameraDistance, 
                                     Math.min(this.maxCameraDistance, distance));
    }
    
    render() {
        this.renderer.render(this.scene, this.camera);
    }
    
    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    add(object) {
        this.scene.add(object);
    }
    
    remove(object) {
        this.scene.remove(object);
    }
    
    getScene() {
        return this.scene;
    }
    
    getCamera() {
        return this.camera;
    }
    
    getRenderer() {
        return this.renderer;
    }
}
```

## js/Sheepdog.js

```javascript
import * as THREE from 'three';
import { Vector2D } from './Vector2D.js';

/**
 * Sheepdog class - player controlled entity
 * Toony design with smooth animations and buttery controls
 */
export class Sheepdog {
    constructor(x, z, dogType = 'jep') {
        this.position = new Vector2D(x, z);
        this.velocity = new Vector2D(0, 0);
        this.targetVelocity = new Vector2D(0, 0);
        this.dogType = dogType;
        
        // Configure dog based on type
        if (dogType === 'rory') {
            // Rory: Less stamina but longer interaction distance
            this.maxSpeed = 15; // Normal max speed
            this.sprintSpeed = 25; // Sprint max speed
            this.acceleration = 40; // How fast we reach max speed
            this.deceleration = 30; // How fast we stop
            this.turnSpeed = 8; // How fast we rotate
            
            // Reduced stamina for Rory
            this.maxStamina = 70; // 30% less stamina
            this.stamina = this.maxStamina;
            this.staminaDrainRate = 35; // Drains slightly faster
            this.staminaRegenRate = 15; // Regenerates slower
            this.minStaminaToSprint = 10; // Minimum stamina needed to start sprinting
            
            // Longer interaction distance (set in GameState)
            this.fleeRadius = 12; // 50% longer range (normal is 8)
        } else if (dogType === 'pip') {
            // Pip: Higher stamina, shorter range, faster movement
            this.maxSpeed = 18; // 20% faster normal speed
            this.sprintSpeed = 30; // 20% faster sprint speed
            this.acceleration = 50; // Quicker acceleration
            this.deceleration = 35; // Quicker stops
            this.turnSpeed = 10; // More agile turning
            
            // Higher stamina for Pip
            this.maxStamina = 130; // 30% more stamina
            this.stamina = this.maxStamina;
            this.staminaDrainRate = 25; // Drains slower
            this.staminaRegenRate = 25; // Regenerates faster
            this.minStaminaToSprint = 10; // Minimum stamina needed to start sprinting
            
            // Shorter interaction distance (small dog, less intimidating)
            this.fleeRadius = 6; // 25% shorter range
        } else {
            // Jep: Standard configuration
            this.maxSpeed = 15; // Normal max speed
            this.sprintSpeed = 25; // Sprint max speed
            this.acceleration = 40; // How fast we reach max speed
            this.deceleration = 30; // How fast we stop
            this.turnSpeed = 8; // How fast we rotate
            
            // Standard stamina
            this.maxStamina = 100;
            this.stamina = this.maxStamina;
            this.staminaDrainRate = 30; // Stamina per second when sprinting
            this.staminaRegenRate = 20; // Stamina per second when not sprinting
            this.minStaminaToSprint = 10; // Minimum stamina needed to start sprinting
            
            // Standard interaction distance
            this.fleeRadius = 8; // Standard range
        }
        
        this.isSprinting = false;
        
        // Animation properties
        this.animationTime = 0;
        this.runCycle = 0;
        this.tailWag = 0;
        this.earFlap = 0;
        this.currentRotation = 0;
        this.targetRotation = 0;
        
        // Idle animation properties
        this.idleTime = 0;
        this.nextIdleAction = 0;
        this.currentIdleAction = 'breathing';
        this.idleActionDuration = 0;
        this.lookDirection = 0;
        this.targetLookDirection = 0;
        
        // Store references to animated parts
        this.animatedParts = {
            body: null,
            head: null,
            tail: null,
            ears: [],
            legs: [],
            tongue: null
        };
        
        this.mesh = null;
        this.isMoving = false;
        this.audioManager = null;
        
        // Audio tracking
        this.lastBarkTime = 0;
        this.barkCooldown = 2000; // 2 seconds between barks
        this.nearSheep = false; // Track if dog is near sheep for barking
        
        // Initialize shared resources
        this.initializeSharedResources();
    }
    
    // Static initialization for shared resources
    initializeSharedResources() {
        if (Sheepdog.sharedGeometries) return;
        
        Sheepdog.sharedGeometries = {
            // Body parts
            body: new THREE.CapsuleGeometry(0.35, 1.0, 6, 8),
            chest: new THREE.SphereGeometry(0.3, 8, 6),
            head: new THREE.SphereGeometry(0.35, 8, 6),
            snout: new THREE.ConeGeometry(0.2, 0.4, 6),
            nose: new THREE.SphereGeometry(0.08, 6, 5),
            
            // Features
            eye: new THREE.SphereGeometry(0.12, 8, 6),
            pupil: new THREE.SphereGeometry(0.08, 6, 5),
            ear: new THREE.TetrahedronGeometry(0.25, 0),
            
            // Limbs
            leg: new THREE.CapsuleGeometry(0.08, 0.4, 4, 6),
            paw: new THREE.SphereGeometry(0.12, 6, 5),
            
            // Tail segments
            tailBase: new THREE.CylinderGeometry(0.12, 0.08, 0.3, 6),
            tailMid: new THREE.CylinderGeometry(0.08, 0.06, 0.3, 6),
            tailTip: new THREE.SphereGeometry(0.08, 6, 5),
            
            // Tongue
            tongue: new THREE.BoxGeometry(0.15, 0.02, 0.2)
        };
        
        Sheepdog.sharedMaterials = {
            // Main colors - Jep (Black and White Border Collie)
            blackFur: new THREE.MeshToonMaterial({ 
                color: 0x2a2a2a,
                emissive: 0x1a1a1a,
                emissiveIntensity: 0.1,
                fog: true
            }),
            whiteFur: new THREE.MeshToonMaterial({ 
                color: 0xffffff,
                emissive: 0xf5f5f5,
                emissiveIntensity: 0.1,
                fog: true
            }),
            
            // Main colors - Rory (Chocolate/Red-Brown)
            brownFur: new THREE.MeshToonMaterial({
                color: 0x8B4513, // Chocolate brown
                emissive: 0x5D2E0C,
                emissiveIntensity: 0.1,
                fog: true
            }),
            redBrownFur: new THREE.MeshToonMaterial({
                color: 0xA0522D, // Sienna/red-brown
                emissive: 0x704020,
                emissiveIntensity: 0.1,
                fog: true
            }),
            
            // Merle speckling for Rory's paws
            speckledFur: new THREE.MeshToonMaterial({
                color: 0xD2B48C, // Tan with darker spots implied
                emissive: 0x8B7355,
                emissiveIntensity: 0.1,
                fog: true
            }),
            
            // Silvering for Rory's muzzle
            silverFur: new THREE.MeshToonMaterial({
                color: 0xC0C0C0,
                emissive: 0xA0A0A0,
                emissiveIntensity: 0.1,
                fog: true
            }),
            
            // Features
            nose: new THREE.MeshToonMaterial({
                color: 0x222222,
                fog: true
            }),
            eye: new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                fog: false
            }),
            pupil: new THREE.MeshBasicMaterial({ 
                color: 0x000000,
                fog: false
            }),
            amberPupil: new THREE.MeshBasicMaterial({
                color: 0x8B4513, // Warm amber/brown eyes for Rory
                fog: false
            }),
            tongue: new THREE.MeshToonMaterial({
                color: 0xff6b9d,
                emissive: 0xff4b7d,
                emissiveIntensity: 0.2,
                fog: true
            })
        };
        
        // Create gradient map for toon shading
        const gradientTexture = new THREE.DataTexture(
            new Uint8Array([0, 0, 0, 255, 100, 100, 100, 255, 200, 200, 200, 255, 255, 255, 255, 255]),
            4, 1, THREE.RGBAFormat
        );
        gradientTexture.magFilter = THREE.NearestFilter;
        gradientTexture.minFilter = THREE.NearestFilter;
        
        // Apply gradient map
        Sheepdog.sharedMaterials.blackFur.gradientMap = gradientTexture;
        Sheepdog.sharedMaterials.whiteFur.gradientMap = gradientTexture;
        Sheepdog.sharedMaterials.nose.gradientMap = gradientTexture;
        Sheepdog.sharedMaterials.tongue.gradientMap = gradientTexture;
    }

    // Create Three.js mesh for the sheepdog
    createMesh() {
        const geom = Sheepdog.sharedGeometries;
        const mat = Sheepdog.sharedMaterials;
        
        this.mesh = new THREE.Group();
        
        // BODY GROUP (will bounce)
        const bodyGroup = new THREE.Group();
        this.animatedParts.body = bodyGroup;
        
        // Configure materials based on dog type
        const isRory = this.dogType === 'rory';
        const isPip = this.dogType === 'pip';
        const mainFurMat = isRory ? mat.redBrownFur : (isPip ? mat.brownFur : mat.blackFur);
        const chestMat = mat.whiteFur; // All have white chest
        const pupilMat = isRory ? mat.amberPupil : mat.pupil;
        
        // Main body
        const body = new THREE.Mesh(geom.body, mainFurMat);
        body.rotation.x = Math.PI / 2; // Rotate around X axis to make it horizontal
        body.position.set(0, 0, 0);
        // Rory is slightly stockier, Pip has corgi proportions
        if (isRory) {
            body.scale.set(1.1, 1, 1); // Slightly wider
        } else if (isPip) {
            body.scale.set(1.2, 0.8, 1.3); // Wider and longer but shorter height
        }
        body.castShadow = true;
        body.receiveShadow = true;
        bodyGroup.add(body);
        
        // White chest/belly (white blaze from muzzle down chest)
        const chest = new THREE.Mesh(geom.chest, chestMat);
        chest.position.set(0, -0.15, 0.3);
        chest.scale.set(0.6, 0.5, 0.4);
        bodyGroup.add(chest);
        
        // HEAD GROUP
        const headGroup = new THREE.Group();
        this.animatedParts.head = headGroup;
        
        // Head
        const head = new THREE.Mesh(geom.head, mainFurMat);
        // Different head shapes for each dog
        if (isRory) {
            head.scale.set(1.15, 1, 1.1); // Broader and slightly larger
        } else if (isPip) {
            head.scale.set(1.1, 1, 1.2); // Corgi-like proportions
        } else {
            head.scale.set(1, 0.9, 1);
        }
        headGroup.add(head);
        
        // White muzzle marking/blaze
        const muzzle = new THREE.Mesh(geom.snout, mat.whiteFur);
        muzzle.rotation.x = -Math.PI / 2;
        muzzle.position.set(0, -0.05, 0.35);
        muzzle.scale.set(0.8, 0.8, 0.9);
        headGroup.add(muzzle);
        
        // Snout with silvering for Rory
        const snoutMat = isRory ? mat.silverFur : mainFurMat;
        const snout = new THREE.Mesh(geom.snout, snoutMat);
        snout.rotation.x = -Math.PI / 2;
        snout.position.set(0, -0.05, 0.4);
        snout.scale.set(0.6, 0.6, 0.7);
        headGroup.add(snout);
        
        // Nose (dark for both)
        const nose = new THREE.Mesh(geom.nose, mat.nose);
        nose.position.set(0, -0.05, 0.55);
        headGroup.add(nose);
        
        // EYES
        const leftEye = new THREE.Mesh(geom.eye, mat.eye);
        leftEye.position.set(-0.15, 0.12, 0.25);
        // Make Jep's eyes smaller and less prominent
        if (!isRory) {
            leftEye.scale.set(0.7, 0.7, 0.7);
        }
        headGroup.add(leftEye);
        
        const leftPupil = new THREE.Mesh(geom.pupil, pupilMat);
        // Jep has closer pupils, Rory needs them more forward
        leftPupil.position.set(-0.15, 0.12, isRory ? 0.35 : 0.29);
        leftPupil.renderOrder = 1; // Ensure pupils render on top
        if (!isRory) {
            leftPupil.scale.set(0.7, 0.7, 0.7);
        }
        headGroup.add(leftPupil);
        
        const rightEye = new THREE.Mesh(geom.eye, mat.eye);
        rightEye.position.set(0.15, 0.12, 0.25);
        // Make Jep's eyes smaller and less prominent
        if (!isRory) {
            rightEye.scale.set(0.7, 0.7, 0.7);
        }
        headGroup.add(rightEye);
        
        const rightPupil = new THREE.Mesh(geom.pupil, pupilMat);
        // Jep has closer pupils, Rory needs them more forward
        rightPupil.position.set(0.15, 0.12, isRory ? 0.35 : 0.29);
        rightPupil.renderOrder = 1; // Ensure pupils render on top
        if (!isRory) {
            rightPupil.scale.set(0.7, 0.7, 0.7);
        }
        headGroup.add(rightPupil);
        
        // EARS
        const leftEar = new THREE.Mesh(geom.ear, mainFurMat);
        // Different ear styles for each dog
        if (isRory) {
            leftEar.scale.set(1.2, 1.8, 0.6); // Larger ears
            leftEar.position.set(-0.28, 0.15, -0.1);
            leftEar.rotation.set(0, -0.1, 0.6); // More upright, slight outward tip
        } else if (isPip) {
            leftEar.scale.set(1.5, 2.2, 0.8); // Large Corgi ears
            leftEar.position.set(-0.3, 0.2, -0.05);
            leftEar.rotation.set(0, -0.2, 0.3); // Very upright
        } else {
            leftEar.scale.set(1, 1.5, 0.5);
            leftEar.position.set(-0.25, 0.1, -0.1);
            leftEar.rotation.set(0, 0, 0.8);
        }
        this.animatedParts.ears.push(leftEar);
        headGroup.add(leftEar);
        
        const rightEar = new THREE.Mesh(geom.ear, mainFurMat);
        if (isRory) {
            rightEar.scale.set(1.2, 1.8, 0.6); // Larger ears
            rightEar.position.set(0.28, 0.15, -0.1);
            rightEar.rotation.set(0, 0.1, -0.6); // More upright, slight outward tip
        } else if (isPip) {
            rightEar.scale.set(1.5, 2.2, 0.8); // Large Corgi ears
            rightEar.position.set(0.3, 0.2, -0.05);
            rightEar.rotation.set(0, 0.2, -0.3); // Very upright
        } else {
            rightEar.scale.set(1, 1.5, 0.5);
            rightEar.position.set(0.25, 0.1, -0.1);
            rightEar.rotation.set(0, 0, -0.8);
        }
        this.animatedParts.ears.push(rightEar);
        headGroup.add(rightEar);
        
        // TONGUE (hanging out when running)
        const tongue = new THREE.Mesh(geom.tongue, mat.tongue);
        tongue.position.set(0.1, -0.2, 0.45);
        tongue.rotation.z = 0.1;
        tongue.visible = false; // Hidden by default
        this.animatedParts.tongue = tongue;
        headGroup.add(tongue);
        
        headGroup.position.set(0, 0.45, 0.7);
        bodyGroup.add(headGroup);
        
        // TAIL (segmented for wagging)
        const tailGroup = new THREE.Group();
        
        // Different tail styles
        if (isRory) {
            // Just a small nub
            const tailNub = new THREE.Mesh(geom.tailTip, mainFurMat);
            tailNub.position.set(0, 0.05, -0.65);
            tailNub.scale.set(1.2, 1.2, 0.8); // Stubby tail
            tailGroup.add(tailNub);
        } else if (isPip) {
            // Corgi has a fluffy, medium-length tail
            const tailBase = new THREE.Mesh(geom.tailBase, mainFurMat);
            tailBase.rotation.z = -0.9; // More upright
            tailBase.position.set(0, 0.15, -0.55);
            tailBase.scale.set(1.3, 1, 1.3); // Fluffier
            tailGroup.add(tailBase);
            
            const tailTip = new THREE.Mesh(geom.tailTip, mat.whiteFur);
            tailTip.position.set(0, 0.3, -0.7);
            tailTip.scale.set(1.2, 1.2, 1.2); // Fluffy tip
            tailGroup.add(tailTip);
        } else {
            // Jep has normal tail
            const tailBase = new THREE.Mesh(geom.tailBase, mat.blackFur);
            tailBase.rotation.z = -0.7;
            tailBase.position.set(0, 0.1, -0.6);
            tailGroup.add(tailBase);
            
            const tailMid = new THREE.Mesh(geom.tailMid, mat.blackFur);
            tailMid.rotation.z = -0.5;
            tailMid.position.set(0, 0.25, -0.8);
            tailGroup.add(tailMid);
            
            const tailTip = new THREE.Mesh(geom.tailTip, mat.whiteFur);
            tailTip.position.set(0, 0.35, -0.95);
            tailGroup.add(tailTip);
        }
        
        this.animatedParts.tail = tailGroup;
        bodyGroup.add(tailGroup);
        
        // LEGS - spread out more for realistic dog proportions
        const legPositions = [
            { x: -0.15, z: 0.6, name: 'frontLeft' },
            { x: 0.15, z: 0.6, name: 'frontRight' },
            { x: -0.15, z: -0.6, name: 'backLeft' },
            { x: 0.15, z: -0.6, name: 'backRight' }
        ];
        
        legPositions.forEach((pos, i) => {
            const legGroup = new THREE.Group();
            
            // Upper leg (shorter)
            const leg = new THREE.Mesh(geom.leg, mainFurMat);
            leg.position.y = -0.15;
            // Different leg styles
            if (isRory) {
                leg.scale.set(1.1, 0.7, 1.1); // Thicker legs
            } else if (isPip) {
                leg.scale.set(1.3, 0.4, 1.3); // Very short, thick Corgi legs
                leg.position.y = -0.1; // Higher up due to shorter legs
            } else {
                leg.scale.set(1, 0.7, 1); // Make legs shorter
            }
            legGroup.add(leg);
            
            // White socks - Different patterns for each dog
            if (isRory || (isPip && i < 2) || (!isPip && !isRory && i < 2)) {
                const sock = new THREE.Mesh(geom.leg, mat.whiteFur);
                if (isPip) {
                    sock.position.y = -0.12; // Adjusted for shorter legs
                    sock.scale.set(1.4, 0.3, 1.4);
                } else {
                    sock.position.y = -0.22;
                    sock.scale.set(1.1, 0.4, 1.1);
                }
                legGroup.add(sock);
            }
            
            // Paw - Different styles for each dog
            const pawMat = isRory ? mat.speckledFur : mainFurMat;
            const paw = new THREE.Mesh(geom.paw, pawMat);
            if (isPip) {
                paw.position.y = -0.18; // Higher due to shorter legs
                paw.scale.set(1, 1, 1); // Bigger paws for Corgi
            } else {
                paw.position.y = -0.32;
                paw.scale.set(0.8, 0.8, 0.8); // Slightly smaller paws
            }
            legGroup.add(paw);
            
            legGroup.position.set(pos.x, -0.15, pos.z);
            legGroup.userData = { 
                index: i, 
                baseX: pos.x,
                baseY: -0.15,
                baseZ: pos.z,
                name: pos.name 
            };
            
            this.animatedParts.legs.push(legGroup);
            bodyGroup.add(legGroup);
        });
        
        // Adjust body height based on dog type
        if (isPip) {
            bodyGroup.position.y = 0.4; // Lower body for short legs
        } else {
            bodyGroup.position.y = 0.6;
        }
        this.mesh.add(bodyGroup);
        
        // Position mesh
        this.mesh.position.set(this.position.x, 0, this.position.z);
        
        return this.mesh;
    }

    // Smooth movement with acceleration
    move(direction, bounds, deltaTime = 0.016, wantsSprint = false) {
        // Update stamina based on sprint state
        this.updateStamina(wantsSprint, deltaTime);
        
        // Determine current max speed based on sprint state
        const currentMaxSpeed = this.isSprinting ? this.sprintSpeed : this.maxSpeed;
        
        // Set target velocity based on input
        this.targetVelocity = direction.clone().normalize().multiply(currentMaxSpeed);
        
        // Smooth acceleration/deceleration
        const accelerationRate = direction.magnitude() > 0 ? this.acceleration : this.deceleration;
        const velocityDiff = this.targetVelocity.clone().subtract(this.velocity);
        const velocityChange = velocityDiff.clone().multiply(accelerationRate * deltaTime);
        
        // Apply velocity change
        this.velocity.add(velocityChange);
        
        // Limit to current max speed
        if (this.velocity.magnitude() > currentMaxSpeed) {
            this.velocity.normalize().multiply(currentMaxSpeed);
        }
        
        // Calculate new position
        const newPosition = this.position.clone().add(this.velocity.clone().multiply(deltaTime));
        
        // Apply position update first
        this.position = newPosition;
        
        // Apply boundary constraints (matching server-side logic)
        let hitBoundary = false;
        if (this.position.x < bounds.minX) {
            this.position.x = bounds.minX;
            this.velocity.x = Math.max(0, this.velocity.x);
            hitBoundary = true;
        }
        if (this.position.x > bounds.maxX) {
            this.position.x = bounds.maxX;
            this.velocity.x = Math.min(0, this.velocity.x);
            hitBoundary = true;
        }
        if (this.position.z < bounds.minZ) {
            this.position.z = bounds.minZ;
            this.velocity.z = Math.max(0, this.velocity.z);
            hitBoundary = true;
        }
        if (this.position.z > bounds.maxZ) {
            this.position.z = bounds.maxZ;
            this.velocity.z = Math.min(0, this.velocity.z);
            hitBoundary = true;
        }
        
        this.isMoving = this.velocity.magnitude() > 0.5;
        const speedNormalized = Math.min(this.velocity.magnitude() / this.maxSpeed, 1);
        
        // Play bark sound when actively herding sheep (near sheep and moving)
        if (this.audioManager && this.isMoving && this.nearSheep) {
            const now = Date.now();
            if (now - this.lastBarkTime > this.barkCooldown) {
                this.audioManager.playSheepdogBark();
                this.lastBarkTime = now;
            }
        }
        
        // Update mesh position and rotation
        if (this.mesh) {
            this.mesh.position.x = this.position.x;
            this.mesh.position.z = this.position.z;
            
            // Smooth rotation
            if (this.velocity.magnitude() > 0.1) {
                this.targetRotation = -this.velocity.angle() + Math.PI / 2;
            }
            
            // Normalize rotation difference
            let rotationDiff = this.targetRotation - this.currentRotation;
            while (rotationDiff > Math.PI) rotationDiff -= 2 * Math.PI;
            while (rotationDiff < -Math.PI) rotationDiff += 2 * Math.PI;
            
            // Apply smooth rotation
            this.currentRotation += rotationDiff * this.turnSpeed * deltaTime;
            this.mesh.rotation.y = this.currentRotation;
            
            // Animate
            this.animate(deltaTime);
        }
    }
    
    // Update stamina system
    updateStamina(wantsSprint, deltaTime) {
        const isMoving = this.velocity.magnitude() > 0.1;
        
        // Determine if we can/should sprint
        if (wantsSprint && isMoving && this.stamina >= this.minStaminaToSprint) {
            this.isSprinting = true;
            // Drain stamina when sprinting
            this.stamina = Math.max(0, this.stamina - this.staminaDrainRate * deltaTime);
        } else {
            this.isSprinting = false;
            // Regenerate stamina - faster when idle (not moving)
            const regenRate = isMoving ? this.staminaRegenRate : this.staminaRegenRate * 2;
            this.stamina = Math.min(this.maxStamina, this.stamina + regenRate * deltaTime);
        }
        
        // Force stop sprinting if stamina is depleted
        if (this.stamina <= 0) {
            this.isSprinting = false;
        }
    }
    
    // Get stamina information for UI
    getStaminaInfo() {
        return {
            current: this.stamina,
            max: this.maxStamina,
            percentage: (this.stamina / this.maxStamina) * 100,
            isSprinting: this.isSprinting,
            canSprint: this.stamina >= this.minStaminaToSprint
        };
    }
    
    // Update speeds for multiplayer mode (2x faster)
    setMultiplayerSpeeds(isMultiplayer = true) {
        const speedMultiplier = isMultiplayer ? 2 : 1;
        this.maxSpeed = 15 * speedMultiplier;
        this.sprintSpeed = 25 * speedMultiplier;
        this.acceleration = 40 * speedMultiplier;
        this.deceleration = 35 * speedMultiplier;
    }
    
    // Animate the dog based on movement
    animate(deltaTime) {
        if (!this.animatedParts.body) return;
        
        this.animationTime += deltaTime;
        const speed = this.velocity.magnitude();
        const speedNormalized = Math.min(speed / this.maxSpeed, 1);
        
        // Running animation
        if (this.isMoving) {
            // Increase animation speed when sprinting
            const animationMultiplier = this.isSprinting ? 1.5 : 1.0;
            this.runCycle += deltaTime * speed * 0.5 * animationMultiplier;
            
            // Body bounce (more intense when sprinting)
            const bounceIntensity = this.isSprinting ? 0.1 : 0.06;
            const bounce = Math.sin(this.runCycle * 2) * speedNormalized * bounceIntensity;
            const baseHeight = this.dogType === 'pip' ? 0.4 : 0.6;
            this.animatedParts.body.position.y = baseHeight + bounce;
            
            // Body lean forward when running (more when sprinting)
            const leanIntensity = this.isSprinting ? 0.25 : 0.15;
            const leanAmount = speedNormalized * leanIntensity;
            this.animatedParts.body.rotation.x = leanAmount;
            
            // Adjust body position to keep back legs grounded when leaning
            // Move body forward and down slightly when leaning
            this.animatedParts.body.position.z = leanAmount * 0.3; // Move forward
            this.animatedParts.body.position.y = baseHeight + bounce - (leanAmount * 0.15); // Lower slightly
            
            // Head bob and reset idle rotations
            const headBob = Math.sin(this.runCycle * 2 + 0.5) * speedNormalized * 0.05;
            this.animatedParts.head.position.y = 0.35 + headBob;
            this.animatedParts.head.rotation.x = Math.sin(this.runCycle * 2) * speedNormalized * 0.1;
            
            // Reset idle head rotations when moving
            this.animatedParts.head.rotation.y *= 0.9; // Reset look direction
            this.animatedParts.head.rotation.z *= 0.9; // Reset head tilt
            this.lookDirection *= 0.9;
            
            // More realistic dog galloping animation
            this.animatedParts.legs.forEach((leg, i) => {
                // Front legs move together, back legs move together (dog gait)
                const isFrontLeg = i < 2;
                const isLeftLeg = i % 2 === 0;
                
                // Different phases for front and back legs
                const frontPhase = 0;
                const backPhase = Math.PI * 0.5; // Back legs slightly offset
                const sideOffset = isLeftLeg ? 0 : Math.PI * 0.1; // Slight left/right offset
                
                const phase = isFrontLeg ? frontPhase : backPhase;
                const cycleSpeed = this.runCycle * 2.5; // Slightly faster cycle
                
                // Leg lift (more subtle)
                const lift = Math.max(0, Math.sin(cycleSpeed + phase + sideOffset)) * speedNormalized;
                leg.position.y = leg.userData.baseY + lift * 0.12;
                
                // Forward/backward leg extension (more realistic)
                const extension = Math.cos(cycleSpeed + phase + sideOffset) * speedNormalized;
                leg.position.z = leg.userData.baseZ + extension * 0.15;
                
                // Leg rotation (more subtle)
                leg.rotation.x = Math.sin(cycleSpeed + phase + sideOffset) * speedNormalized * 0.4;
            });
            
            // Show tongue when running fast or sprinting
            if (this.animatedParts.tongue) {
                this.animatedParts.tongue.visible = speedNormalized > 0.6 || this.isSprinting;
                if (this.animatedParts.tongue.visible) {
                    const tongueIntensity = this.isSprinting ? 0.15 : 0.1;
                    this.animatedParts.tongue.rotation.z = Math.sin(this.runCycle * 3) * tongueIntensity;
                }
            }
        } else {
            // Enhanced idle animation system
            this.runCycle *= 0.9; // Slow down run cycle
            this.idleTime += deltaTime;
            
            // Reset body position when idle
            this.animatedParts.body.position.z *= 0.9; // Smoothly return to center
            
            // Check if it's time for a new idle action
            if (this.idleTime >= this.nextIdleAction) {
                this.chooseNextIdleAction();
            }
            
            // Perform current idle action
            this.performIdleAction(deltaTime);
            
            // Reset leg positions smoothly
            this.animatedParts.legs.forEach((leg) => {
                leg.position.y += (leg.userData.baseY - leg.position.y) * 0.1;
                leg.position.z += (leg.userData.baseZ - leg.position.z) * 0.1;
                leg.rotation.x *= 0.9;
            });
            
            // Hide tongue when idle
            if (this.animatedParts.tongue) {
                this.animatedParts.tongue.visible = false;
            }
        }
        
        // Tail wagging (faster when moving, even faster when sprinting)
        const tailSpeedMultiplier = this.isSprinting ? 1.5 : 1.0;
        this.tailWag += deltaTime * (2 + speedNormalized * 4) * tailSpeedMultiplier;
        if (this.animatedParts.tail) {
            const wagAmount = 0.3 + speedNormalized * 0.3 + (this.isSprinting ? 0.2 : 0);
            this.animatedParts.tail.rotation.y = Math.sin(this.tailWag) * wagAmount;
            this.animatedParts.tail.rotation.x = Math.cos(this.tailWag * 0.5) * wagAmount * 0.3;
        }
        
        // Ear flapping
        this.earFlap += deltaTime * (1 + speedNormalized * 2);
        this.animatedParts.ears.forEach((ear, i) => {
            const baseRotation = i === 0 ? 0.8 : -0.8;
            const flap = Math.sin(this.earFlap + i * Math.PI * 0.5) * speedNormalized * 0.2;
            ear.rotation.z = baseRotation + flap;
            ear.rotation.x = -0.2 + Math.cos(this.earFlap * 0.5) * speedNormalized * 0.1;
        });
    }

    // Choose next idle action
    chooseNextIdleAction() {
        const actions = ['breathing', 'lookAround', 'headTilt', 'earTwitch', 'stretch', 'sit'];
        const weights = [30, 25, 20, 15, 8, 2]; // Breathing most common, sitting rare
        
        // Weighted random selection
        const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
        let random = Math.random() * totalWeight;
        
        for (let i = 0; i < actions.length; i++) {
            random -= weights[i];
            if (random <= 0) {
                this.currentIdleAction = actions[i];
                break;
            }
        }
        
        // Set duration and next action time
        this.idleActionDuration = 0;
        switch (this.currentIdleAction) {
            case 'breathing':
                this.nextIdleAction = this.idleTime + 2 + Math.random() * 3; // 2-5 seconds
                break;
            case 'lookAround':
                this.nextIdleAction = this.idleTime + 1.5 + Math.random() * 2; // 1.5-3.5 seconds
                this.targetLookDirection = (Math.random() - 0.5) * Math.PI * 0.8; // Look left/right
                break;
            case 'headTilt':
                this.nextIdleAction = this.idleTime + 1 + Math.random() * 1.5; // 1-2.5 seconds
                break;
            case 'earTwitch':
                this.nextIdleAction = this.idleTime + 0.5 + Math.random() * 1; // 0.5-1.5 seconds
                break;
            case 'stretch':
                this.nextIdleAction = this.idleTime + 3 + Math.random() * 2; // 3-5 seconds
                break;
            case 'sit':
                this.nextIdleAction = this.idleTime + 4 + Math.random() * 3; // 4-7 seconds
                break;
        }
    }
    
    // Perform the current idle action
    performIdleAction(deltaTime) {
        this.idleActionDuration += deltaTime;
        
        switch (this.currentIdleAction) {
            case 'breathing':
                this.performBreathing();
                break;
            case 'lookAround':
                this.performLookAround(deltaTime);
                break;
            case 'headTilt':
                this.performHeadTilt();
                break;
            case 'earTwitch':
                this.performEarTwitch();
                break;
            case 'stretch':
                this.performStretch();
                break;
            case 'sit':
                this.performSit();
                break;
        }
    }
    
    // Individual idle animations
    performBreathing() {
        const breathe = Math.sin(this.animationTime * 2.5) * 0.025;
        const baseHeight = this.dogType === 'pip' ? 0.4 : 0.6;
        this.animatedParts.body.position.y = baseHeight + breathe;
        this.animatedParts.body.rotation.x *= 0.95; // Return to neutral slowly
        
        // Gentle head movement
        if (this.animatedParts.head) {
            this.animatedParts.head.position.y = 0.45 + breathe * 0.5;
        }
    }
    
    performLookAround(deltaTime) {
        // Smooth head turning
        const lookDiff = this.targetLookDirection - this.lookDirection;
        this.lookDirection += lookDiff * 2 * deltaTime;
        
        if (this.animatedParts.head) {
            this.animatedParts.head.rotation.y = this.lookDirection;
            
            // Slight body breathing
            const breathe = Math.sin(this.animationTime * 2) * 0.02;
            const baseHeight = this.dogType === 'pip' ? 0.4 : 0.6;
            this.animatedParts.body.position.y = baseHeight + breathe;
        }
    }
    
    performHeadTilt() {
        const tilt = Math.sin(this.idleActionDuration * 3) * 0.3;
        if (this.animatedParts.head) {
            this.animatedParts.head.rotation.z = tilt;
            
            // Breathing
            const breathe = Math.sin(this.animationTime * 2) * 0.02;
            this.animatedParts.body.position.y = 0.6 + breathe;
        }
    }
    
    performEarTwitch() {
        const twitch = Math.sin(this.idleActionDuration * 8) * 0.4;
        this.animatedParts.ears.forEach((ear, i) => {
            const baseRotation = i === 0 ? 0.8 : -0.8;
            ear.rotation.z = baseRotation + (i === 0 ? twitch : -twitch);
        });
        
        // Breathing
        const breathe = Math.sin(this.animationTime * 2) * 0.02;
        const baseHeight = this.dogType === 'pip' ? 0.4 : 0.6;
        this.animatedParts.body.position.y = baseHeight + breathe;
    }
    
    performStretch() {
        const stretchPhase = this.idleActionDuration / 3; // 3 second stretch
        const baseHeight = this.dogType === 'pip' ? 0.4 : 0.6;
        
        if (stretchPhase < 0.3) {
            // Stretch forward
            this.animatedParts.body.rotation.x = -0.2 * (stretchPhase / 0.3);
            this.animatedParts.body.position.y = baseHeight - 0.1 * (stretchPhase / 0.3);
        } else if (stretchPhase < 0.7) {
            // Hold stretch
            this.animatedParts.body.rotation.x = -0.2;
            this.animatedParts.body.position.y = baseHeight - 0.1;
        } else {
            // Return to normal
            const returnPhase = (stretchPhase - 0.7) / 0.3;
            this.animatedParts.body.rotation.x = -0.2 * (1 - returnPhase);
            this.animatedParts.body.position.y = (baseHeight - 0.1) + 0.1 * returnPhase;
        }
    }
    
    performSit() {
        const sitPhase = Math.min(this.idleActionDuration / 1, 1); // 1 second to sit
        const baseHeight = this.dogType === 'pip' ? 0.4 : 0.6;
        
        // Lower body and rotate back legs
        this.animatedParts.body.position.y = baseHeight - 0.2 * sitPhase;
        this.animatedParts.body.rotation.x = 0.3 * sitPhase;
        
        // Move back legs
        if (this.animatedParts.legs.length >= 4) {
            this.animatedParts.legs[2].rotation.x = -0.8 * sitPhase; // Back left
            this.animatedParts.legs[3].rotation.x = -0.8 * sitPhase; // Back right
            this.animatedParts.legs[2].position.y = this.animatedParts.legs[2].userData.baseY - 0.1 * sitPhase;
            this.animatedParts.legs[3].position.y = this.animatedParts.legs[3].userData.baseY - 0.1 * sitPhase;
        }
        
        // Gentle breathing while sitting
        const breathe = Math.sin(this.animationTime * 2) * 0.015;
        this.animatedParts.body.position.y += breathe;
    }
    
    // Stop movement
    stop() {
        this.targetVelocity.multiply(0);
        
        // Reset look direction when stopping
        this.targetLookDirection = 0;
    }
    
    setAudioManager(audioManager) {
        this.audioManager = audioManager;
    }
    
    /**
     * Update whether the dog is near sheep for barking purposes
     * @param {Array} sheep - Array of sheep to check distance to
     */
    updateNearSheepStatus(sheep) {
        if (!sheep || sheep.length === 0) {
            this.nearSheep = false;
            return;
        }
        
        const barkRadius = 12; // Slightly larger than sheep flee radius (8)
        this.nearSheep = false;
        
        // Check if any sheep are within barking distance
        for (let i = 0; i < sheep.length; i++) {
            const sheepInstance = sheep[i];
            if (sheepInstance && sheepInstance.position) {
                const distance = this.position.distanceTo(sheepInstance.position);
                if (distance < barkRadius) {
                    this.nearSheep = true;
                    break;
                }
            }
        }
    }
}
```

## js/StaminaUI.js

```javascript
/**
 * StaminaUI class - manages the stamina bar display
 */
export class StaminaUI {
    constructor() {
        this.staminaFill = document.getElementById('stamina-fill');
        this.staminaText = document.getElementById('stamina-text');
        this.staminaLabel = document.getElementById('stamina-label');
        
        // Cache DOM elements for performance
        this.elements = {
            fill: this.staminaFill,
            text: this.staminaText,
            label: this.staminaLabel
        };
        
        // Track previous state to avoid unnecessary updates
        this.previousPercentage = 100;
        this.previousState = 'normal';
    }
    
    /**
     * Update the stamina bar based on sheepdog stamina info
     * @param {Object} staminaInfo - Object containing stamina data from sheepdog
     */
    update(staminaInfo) {
        const { percentage, isSprinting, canSprint } = staminaInfo;
        const roundedPercentage = Math.round(percentage);
        
        // Only update if percentage changed to avoid unnecessary DOM manipulation
        if (roundedPercentage !== this.previousPercentage) {
            this.elements.fill.style.width = `${percentage}%`;
            this.elements.text.textContent = `${roundedPercentage}%`;
            this.previousPercentage = roundedPercentage;
        }
        
        // Determine current state for styling
        let currentState = 'normal';
        if (isSprinting) {
            currentState = 'sprinting';
        } else if (percentage <= 10) {
            currentState = 'critical';
        } else if (percentage <= 30) {
            currentState = 'low';
        }
        
        // Update styling only if state changed
        if (currentState !== this.previousState) {
            // Remove all state classes
            this.elements.fill.classList.remove('low', 'critical', 'sprinting');
            
            // Add current state class
            if (currentState !== 'normal') {
                this.elements.fill.classList.add(currentState);
            }
            
            // Update label based on state
            if (isSprinting) {
                this.elements.label.textContent = 'Sprinting!';
                this.elements.label.style.color = '#2196F3';
            } else if (!canSprint) {
                this.elements.label.textContent = 'Stamina (Exhausted)';
                this.elements.label.style.color = '#F44336';
            } else {
                this.elements.label.textContent = 'Stamina';
                this.elements.label.style.color = '#333';
            }
            
            this.previousState = currentState;
        }
    }
    
    /**
     * Show the stamina bar (called when game starts)
     */
    show() {
        const staminaBar = document.getElementById('stamina-bar');
        if (staminaBar) {
            staminaBar.classList.add('visible');
        }
    }
    
    /**
     * Hide the stamina bar (called when game ends or on start screen)
     */
    hide() {
        const staminaBar = document.getElementById('stamina-bar');
        if (staminaBar) {
            staminaBar.classList.remove('visible');
        }
    }
    
    /**
     * Reset stamina bar to full
     */
    reset() {
        this.elements.fill.style.width = '100%';
        this.elements.text.textContent = '100%';
        this.elements.label.textContent = 'Stamina';
        this.elements.label.style.color = '#333';
        this.elements.fill.classList.remove('low', 'critical', 'sprinting');
        this.previousPercentage = 100;
        this.previousState = 'normal';
    }
}
```

## js/StartScreen.js

```javascript
import * as THREE from 'three';
import { NetworkManager } from './NetworkManager.js';

/**
 * StartScreen - Manages the enhanced start screen with room-based multiplayer
 */
export class StartScreen {
    constructor(sceneManager) {
        this.sceneManager = sceneManager;
        this.isActive = true;
        this.gameStarted = false;
        this.audioManager = null;
        
        // Initialize NetworkManager
        this.networkManager = new NetworkManager();
        this.setupNetworkHandlers();
        
        // Cinematic camera settings
        this.cinematicCamera = {
            angle: 0,
            radius: 120,
            height: 80,
            speed: 0.05,
            centerX: 0,
            centerZ: 0
        };
        
        // UI state management
        this.currentScreen = 'main'; // 'main', 'online', 'create', 'join', 'lobby', 'connecting'
        this.selectedMode = null; // 'solo' or 'multiplayer'
        this.selectedDog = 'jep'; // Default dog selection
        this.isConnecting = false;
        this.isHost = false;
        this.currentRoom = null;
        
        // UI elements
        this.startScreenElement = document.getElementById('start-screen');
        this.gameUIElements = document.querySelectorAll('.game-ui');
        this.musicNote = document.getElementById('music-note');
        
        // Main mode selection
        this.modeSelection = document.getElementById('mode-selection');
        this.soloButton = document.getElementById('solo-button');
        this.onlineButton = document.getElementById('online-button');
        
        // Online options
        this.onlineOptions = document.getElementById('online-options');
        this.createRoomButton = document.getElementById('create-room-button');
        this.joinRoomButton = document.getElementById('join-room-button');
        this.quickMatchButton = document.getElementById('quick-match-button');
        this.backToMainButton = document.getElementById('back-to-main-button');
        
        // Room creation
        this.roomCreation = document.getElementById('room-creation');
        this.roomNameInput = document.getElementById('room-name');
        this.maxPlayersSelect = document.getElementById('max-players');
        this.privateRoomCheckbox = document.getElementById('private-room');
        this.createRoomConfirm = document.getElementById('create-room-confirm');
        this.backToOnlineButton = document.getElementById('back-to-online-button');
        
        // Room joining
        this.roomJoining = document.getElementById('room-joining');
        this.roomCodeInput = document.getElementById('room-code');
        this.codeError = document.getElementById('code-error');
        this.joinRoomConfirm = document.getElementById('join-room-confirm');
        this.backToOnlineButton2 = document.getElementById('back-to-online-button2');
        
        // Lobby
        this.lobbyScreen = document.getElementById('lobby-screen');
        this.lobbyRoomName = document.getElementById('lobby-room-name');
        this.currentRoomCode = document.getElementById('current-room-code');
        this.copyRoomCodeButton = document.getElementById('copy-room-code');
        this.playerCount = document.getElementById('player-count');
        this.maxPlayerCount = document.getElementById('max-player-count');
        this.playersContainer = document.getElementById('players-container');
        this.startGameButton = document.getElementById('start-game-button');
        this.leaveRoomButton = document.getElementById('leave-room-button');
        this.lobbyMessage = document.getElementById('lobby-message');
        
        // Connection status
        this.connectionStatus = document.getElementById('connection-status');
        this.connectionMessage = document.getElementById('connection-message');
        this.backToMenuButton = document.getElementById('back-to-menu-button');
        
        // Dog selection
        this.dogCards = document.querySelectorAll('.dog-card');
        
        this.init();
    }
    
    setupNetworkHandlers() {
        // Connection state changes
        this.networkManager.onConnectionStateChange = (state) => {
            console.log('Connection state changed:', state);
            if (state === 'connected') {
                // Connection successful, continue with current flow
            } else if (state === 'disconnected') {
                this.showConnectionError('Connection lost');
            }
        };
        
        // Room updates
        this.networkManager.onRoomUpdate = (room) => {
            console.log('Room updated:', room);
            this.currentRoom = room;
            this.isHost = this.networkManager.isCurrentHost();
            
            // If we're in connecting state (creating/joining room), transition to lobby
            if (this.currentScreen === 'connecting') {
                this.showLobby(room);
            } else if (this.currentScreen === 'lobby') {
                this.updateLobbyDisplay(room);
            }
        };
        
        // Player events
        this.networkManager.onPlayerUpdate = (update) => {
            console.log('Player update:', update);
            
            if (update.type === 'gameStarted') {
                // Game started by host
                this.selectedMode = 'multiplayer';
                this.startGame();
            } else if (update.type === 'hostChanged') {
                this.isHost = this.networkManager.isCurrentHost();
                if (this.currentScreen === 'lobby' && this.currentRoom) {
                    this.updateLobbyDisplay(this.currentRoom);
                }
            }
            
            // Update lobby if currently shown
            if (this.currentScreen === 'lobby' && this.currentRoom) {
                this.updateLobbyDisplay(this.currentRoom);
            }
        };
        
        // Error handling
        this.networkManager.onError = (message) => {
            console.error('Network error:', message);
            this.showConnectionError(message);
        };
    }
    
    init() {
        // Main mode selection
        this.soloButton.addEventListener('click', () => this.selectSolo());
        this.onlineButton.addEventListener('click', () => this.showOnlineOptions());
        
        // Online options
        this.createRoomButton.addEventListener('click', () => this.showCreateRoom());
        this.joinRoomButton.addEventListener('click', () => this.showJoinRoom());
        this.quickMatchButton.addEventListener('click', () => this.quickMatch());
        this.backToMainButton.addEventListener('click', () => this.showMainMenu());
        
        // Room creation
        this.createRoomConfirm.addEventListener('click', () => this.createRoom());
        this.backToOnlineButton.addEventListener('click', () => this.showOnlineOptions());
        
        // Room joining
        this.joinRoomConfirm.addEventListener('click', () => this.joinRoom());
        this.backToOnlineButton2.addEventListener('click', () => this.showOnlineOptions());
        
        // Room code input handling
        this.roomCodeInput.addEventListener('input', (e) => {
            e.target.value = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
            this.hideCodeError();
        });
        
        // Lobby controls
        this.copyRoomCodeButton.addEventListener('click', () => this.copyRoomCode());
        this.startGameButton.addEventListener('click', () => this.startMultiplayerGame());
        this.leaveRoomButton.addEventListener('click', () => this.leaveRoom());
        
        // Connection status
        this.backToMenuButton.addEventListener('click', () => this.showMainMenu());
        
        // Dog selection
        this.dogCards.forEach(card => {
            card.addEventListener('click', () => this.selectDog(card.dataset.dog));
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            if (!this.isActive) return;
            
            if (event.code === 'Enter') {
                if (this.currentScreen === 'main') {
                    this.selectSolo();
                } else if (this.currentScreen === 'join' && this.roomCodeInput.value.length === 6) {
                    this.joinRoom();
                }
            } else if (event.code === 'Escape') {
                if (this.currentScreen !== 'main') {
                    this.goBack();
                }
            }
        });
        
        // Set up mute button and music activation
        this.setupMuteButton();
        this.setupMusicActivation();
        
        // Load saved dog selection
        this.loadDogSelection();
        
        // Initialize cinematic camera
        this.setupCinematicCamera();
    }
    
    // Navigation methods
    showMainMenu() {
        this.currentScreen = 'main';
        this.hideAllScreens();
        this.modeSelection.style.display = 'flex';
    }
    
    showOnlineOptions() {
        this.currentScreen = 'online';
        this.hideAllScreens();
        this.onlineOptions.style.display = 'flex';
    }
    
    showCreateRoom() {
        this.currentScreen = 'create';
        this.hideAllScreens();
        this.roomCreation.style.display = 'block';
        this.roomNameInput.focus();
    }
    
    showJoinRoom() {
        this.currentScreen = 'join';
        this.hideAllScreens();
        this.roomJoining.style.display = 'block';
        this.roomCodeInput.focus();
    }
    
    showLobby(roomData) {
        this.currentScreen = 'lobby';
        this.hideAllScreens();
        this.lobbyScreen.style.display = 'block';
        this.updateLobbyDisplay(roomData);
    }
    
    showConnecting(message) {
        this.currentScreen = 'connecting';
        this.hideAllScreens();
        this.connectionStatus.style.display = 'block';
        this.connectionMessage.textContent = message;
    }
    
    hideAllScreens() {
        this.modeSelection.style.display = 'none';
        this.onlineOptions.style.display = 'none';
        this.roomCreation.style.display = 'none';
        this.roomJoining.style.display = 'none';
        this.lobbyScreen.style.display = 'none';
        this.connectionStatus.style.display = 'none';
        this.hideCodeError();
    }
    
    goBack() {
        if (this.currentScreen === 'online') {
            this.showMainMenu();
        } else if (this.currentScreen === 'create' || this.currentScreen === 'join') {
            this.showOnlineOptions();
        } else if (this.currentScreen === 'lobby') {
            this.leaveRoom();
        } else if (this.currentScreen === 'connecting') {
            this.showMainMenu();
        }
    }
    
    // Game mode selection
    selectSolo() {
        this.selectedMode = 'solo';
        this.playUIClick();
        this.startGame();
    }
    
    // Room management methods
    async createRoom() {
        const roomName = this.roomNameInput.value.trim() || 'Sheep Herding Room';
        const maxPlayers = parseInt(this.maxPlayersSelect.value);
        const isPrivate = this.privateRoomCheckbox.checked;
        const playerName = 'Player'; // TODO: Get from input or localStorage
        
        this.playUIClick();
        this.showConnecting('Connecting to server...');
        
        try {
            // Connect to server first
            await this.networkManager.connect();
            
            this.showConnecting('Creating room...');
            
            // Create room
            await this.networkManager.createRoom(playerName, {
                roomName: roomName,
                maxPlayers: maxPlayers,
                isPublic: !isPrivate
            }, this.selectedDog);
            
            // Room creation success - lobby transition handled by onRoomUpdate callback
            
        } catch (error) {
            console.error('Failed to create room:', error);
            this.showConnectionError('Failed to create room. Please try again.');
        }
    }
    
    async joinRoom() {
        console.log('🔍 DEBUG: joinRoom called');
        console.log('🔍 DEBUG: this.roomCodeInput:', this.roomCodeInput);
        console.log('🔍 DEBUG: this.roomCodeInput.value:', this.roomCodeInput?.value);
        
        const roomCode = this.roomCodeInput.value.trim();
        console.log('🔍 DEBUG: roomCode after trim:', `"${roomCode}"`);
        
        if (roomCode.length !== 6) {
            this.showCodeError('Room code must be 6 characters');
            return;
        }
        
        const playerName = 'Player'; // TODO: Get from input or localStorage
        
        this.playUIClick();
        this.showConnecting('Connecting to server...');
        
        try {
            // Connect to server first
            await this.networkManager.connect();
            
            this.showConnecting('Joining room...');
            
            // Join room
            await this.networkManager.joinRoom(roomCode, playerName, this.selectedDog);
            
            // Room join success - lobby transition handled by onRoomUpdate callback
            
        } catch (error) {
            console.error('Failed to join room:', error);
            if (error.message.includes('not found')) {
                this.showCodeError('Room not found');
            } else {
                this.showConnectionError('Failed to join room. Please try again.');
            }
        }
    }
    
    async quickMatch() {
        const playerName = 'Player'; // TODO: Get from input or localStorage
        
        this.playUIClick();
        this.showConnecting('Connecting to server...');
        
        try {
            // Connect to server first
            await this.networkManager.connect();
            
            this.showConnecting('Finding available room...');
            
            // Quick match
            await this.networkManager.quickMatch(playerName, this.selectedDog);
            
            // Quick match success - lobby transition handled by onRoomUpdate callback
            
        } catch (error) {
            console.error('Failed to find room:', error);
            this.showConnectionError('No available rooms found. Try creating one!');
        }
    }
    
    leaveRoom() {
        this.networkManager.leaveRoom();
        this.isHost = false;
        this.currentRoom = null;
        this.showOnlineOptions();
    }
    
    startMultiplayerGame() {
        if (!this.isHost) return;
        
        this.playUIClick();
        this.networkManager.startGame();
        // Game start will be handled by network events
    }
    
    // Utility methods
    generateRoomCode() {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        let result = '';
        for (let i = 0; i < 6; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    }
    
    copyRoomCode() {
        if (this.currentRoom) {
            navigator.clipboard.writeText(this.currentRoom.roomCode).then(() => {
                // Visual feedback
                const originalText = this.copyRoomCodeButton.textContent;
                this.copyRoomCodeButton.textContent = '✓ Copied!';
                this.copyRoomCodeButton.style.background = '#4CAF50';
                
                setTimeout(() => {
                    this.copyRoomCodeButton.textContent = originalText;
                    this.copyRoomCodeButton.style.background = '';
                }, 1500);
            }).catch(() => {
                // Fallback for older browsers
                this.copyRoomCodeButton.textContent = this.currentRoom.roomCode + ' (Copy manually)';
                setTimeout(() => {
                    this.copyRoomCodeButton.textContent = '📋 Copy';
                }, 3000);
            });
        }
    }
    
    updateLobbyDisplay(roomData) {
        this.lobbyRoomName.textContent = `Room: ${roomData.name || 'Sheep Herding Room'}`;
        this.currentRoomCode.textContent = roomData.roomCode;
        this.playerCount.textContent = roomData.players.length;
        this.maxPlayerCount.textContent = roomData.maxPlayers || 4;
        
        // Update player list
        this.playersContainer.innerHTML = '';
        roomData.players.forEach(player => {
            const playerDiv = document.createElement('div');
            playerDiv.className = `player-item ${player.isHost ? 'player-host' : ''}`;
            playerDiv.innerHTML = `
                <span class="player-name">${player.name}</span>
                <span class="player-status">Ready</span>
            `;
            this.playersContainer.appendChild(playerDiv);
        });
        
        // Show/hide host controls
        if (this.isHost) {
            this.lobbyScreen.classList.add('is-host');
            this.startGameButton.style.display = 'block';
            this.lobbyMessage.textContent = 'Click Start Game when ready!';
        } else {
            this.lobbyScreen.classList.remove('is-host');
            this.startGameButton.style.display = 'none';
            this.lobbyMessage.textContent = 'Waiting for host to start the game...';
        }
    }
    
    showCodeError(message) {
        this.codeError.textContent = message;
        this.codeError.style.display = 'block';
        this.roomCodeInput.style.borderColor = '#F44336';
    }
    
    hideCodeError() {
        this.codeError.style.display = 'none';
        this.roomCodeInput.style.borderColor = '';
    }
    
    showConnectionError(message) {
        this.connectionMessage.textContent = message + ' Click back to return to menu.';
    }
    
    playUIClick() {
        if (this.audioManager) {
            this.audioManager.playUIClick();
        }
    }
    
    // Dog selection methods
    selectDog(dogType) {
        this.selectedDog = dogType;
        this.playUIClick();
        
        // Update UI
        this.dogCards.forEach(card => {
            card.classList.remove('active');
            if (card.dataset.dog === dogType) {
                card.classList.add('active');
            }
        });
        
        // Store selection in localStorage for persistence
        localStorage.setItem('selectedDog', dogType);
        
        console.log(`Selected dog: ${dogType}`);
    }
    
    getSelectedDog() {
        return this.selectedDog;
    }
    
    // Load dog selection from localStorage if available
    loadDogSelection() {
        const savedDog = localStorage.getItem('selectedDog');
        if (savedDog && ['jep', 'rory', 'pip'].includes(savedDog)) {
            this.selectDog(savedDog);
        }
    }
    
    // Camera and scene methods
    setupCinematicCamera() {
        const camera = this.sceneManager.getCamera();
        camera.position.set(
            this.cinematicCamera.centerX + this.cinematicCamera.radius,
            this.cinematicCamera.height,
            this.cinematicCamera.centerZ
        );
        camera.lookAt(this.cinematicCamera.centerX, 0, this.cinematicCamera.centerZ);
    }
    
    updateCinematicCamera() {
        if (!this.isActive) return;
        
        this.cinematicCamera.angle += this.cinematicCamera.speed * 0.016;
        
        const camera = this.sceneManager.getCamera();
        const x = this.cinematicCamera.centerX + Math.cos(this.cinematicCamera.angle) * this.cinematicCamera.radius;
        const z = this.cinematicCamera.centerZ + Math.sin(this.cinematicCamera.angle) * this.cinematicCamera.radius;
        
        const targetPosition = new THREE.Vector3(x, this.cinematicCamera.height, z);
        camera.position.lerp(targetPosition, 0.02);
        
        const lookAtTarget = new THREE.Vector3(this.cinematicCamera.centerX, 0, this.cinematicCamera.centerZ);
        const currentLookAt = new THREE.Vector3();
        camera.getWorldDirection(currentLookAt);
        currentLookAt.multiplyScalar(-1).add(camera.position);
        currentLookAt.lerp(lookAtTarget, 0.02);
        camera.lookAt(currentLookAt);
    }
    
    startGame() {
        if (!this.isActive) return;
        
        if (this.audioManager) {
            this.audioManager.fadeOutCurrentMusic(800);
            setTimeout(() => {
                this.audioManager.playGameplayMusic();
            }, 900);
        }
        
        this.isActive = false;
        this.gameStarted = true;
        
        this.startScreenElement.style.transition = 'opacity 0.8s ease-out';
        this.startScreenElement.style.opacity = '0';
        
        setTimeout(() => {
            this.startScreenElement.style.display = 'none';
            this.gameUIElements.forEach(element => {
                element.classList.add('visible');
            });
        }, 800);
        
        if (this.onGameStart) {
            // Ensure we have room data for multiplayer mode
            let roomData = this.currentRoom;
            if (this.selectedMode === 'multiplayer' && !roomData) {
                roomData = this.networkManager.getCurrentRoom();
            }
            
            console.log('🎮 Starting game:', {
                mode: this.selectedMode || 'solo',
                room: roomData ? roomData.roomCode : 'none',
                players: roomData ? roomData.players?.length : 0
            });
            
            this.onGameStart(this.selectedMode || 'solo', roomData);
        }
    }
    
    // Audio setup methods
    setupMuteButton() {
        this.muteToggle = document.getElementById('mute-toggle');
        if (this.muteToggle) {
            this.muteToggle.addEventListener('click', () => {
                if (this.audioManager) {
                    this.audioManager.toggleMute();
                    this.updateMuteButton();
                }
            });
        }
    }
    
    updateMuteButton() {
        if (!this.muteToggle || !this.audioManager) return;
        
        const isMuted = this.audioManager.isMutedState();
        const icon = isMuted ? '🔇' : '🔊';
        this.muteToggle.innerHTML = `${icon} <strong>Click</strong> - Toggle Sound`;
        this.muteToggle.title = isMuted ? 'Click to unmute sound' : 'Click to mute sound';
        
        if (isMuted) {
            this.muteToggle.classList.add('muted');
        } else {
            this.muteToggle.classList.remove('muted');
        }
    }
    
    setupMusicActivation() {
        const handleStartScreenClick = (event) => {
            // Don't trigger music if clicking buttons
            if (event.target.closest('button') || event.target.closest('input') || event.target.closest('select')) {
                return;
            }
            
            if (this.audioManager && this.isActive) {
                this.audioManager.triggerStartMusic();
                if (this.musicNote) {
                    this.musicNote.style.display = 'none';
                }
            }
        };
        
        if (this.startScreenElement) {
            this.startScreenElement.addEventListener('click', handleStartScreenClick);
        }
    }
    
    // Public API methods
    setGameStartCallback(callback) {
        this.onGameStart = callback;
    }
    
    setAudioManager(audioManager) {
        this.audioManager = audioManager;
        this.updateMuteButton();
    }
    
    isStartScreenActive() {
        return this.isActive;
    }
    
    hasGameStarted() {
        return this.gameStarted;
    }
    
    getSelectedMode() {
        return this.selectedMode;
    }
    
    isMultiplayerMode() {
        return this.selectedMode === 'multiplayer';
    }
    
    isSoloMode() {
        return this.selectedMode === 'solo';
    }
    
    getCurrentRoom() {
        return this.currentRoom;
    }
    
    reset() {
        this.isActive = true;
        this.gameStarted = false;
        this.selectedMode = null;
        this.isConnecting = false;
        this.isHost = false;
        this.currentRoom = null;
        
        this.startScreenElement.style.display = 'flex';
        this.startScreenElement.style.opacity = '1';
        this.startScreenElement.style.transition = 'none';
        
        this.showMainMenu();
        
        this.gameUIElements.forEach(element => {
            element.classList.remove('visible');
        });
        
        // Reset form inputs
        this.roomNameInput.value = '';
        this.roomCodeInput.value = '';
        this.maxPlayersSelect.value = '3';
        this.privateRoomCheckbox.checked = false;
        
        this.cinematicCamera.angle = 0;
        this.setupCinematicCamera();
    }
}
```

## js/StructureBuilder.js

```javascript
import * as THREE from 'three';

/**
 * StructureBuilder - Handles fences, gates, and pasture structures
 */
export class StructureBuilder {
    constructor(scene) {
        this.scene = scene;
    }
    
    createFieldBoundaryFence(bounds, gate) {
        // Fence post geometry and material
        const postGeometry = new THREE.CylinderGeometry(0.25, 0.25, 3.5, 8);
        const postMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x5a4a3a,
            emissive: 0x1a0a00,
            emissiveIntensity: 0.05
        });
        
        // Rail geometry and material
        const railMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x6a5a4a,
            emissive: 0x1a0a00,
            emissiveIntensity: 0.05
        });
        
        // Fence parameters
        const postSpacing = 10; // Distance between posts
        const postHeight = 3.5;
        const railHeight1 = 1.2; // Lower rail
        const railHeight2 = 2.4; // Upper rail
        
        const fencePosts = [];
        
        // Create fence posts around the perimeter
        // Bottom edge (z = -100)
        for (let x = bounds.minX; x <= bounds.maxX; x += postSpacing) {
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.set(x, postHeight/2, bounds.minZ);
            post.castShadow = true;
            post.receiveShadow = true;
            this.scene.add(post);
            fencePosts.push({x: x, z: bounds.minZ, type: 'bottom'});
        }
        
        // Top edge (z = 100) - connect properly to gate posts
        for (let x = bounds.minX; x <= bounds.maxX; x += postSpacing) {
            // Skip posts that would be too close to gate posts
            const gateLeftPost = gate.position.x - gate.width/2;
            const gateRightPost = gate.position.x + gate.width/2;
            
            if (x < gateLeftPost - 1 || x > gateRightPost + 1) {
                const post = new THREE.Mesh(postGeometry, postMaterial);
                post.position.set(x, postHeight/2, bounds.maxZ);
                post.castShadow = true;
                post.receiveShadow = true;
                this.scene.add(post);
                fencePosts.push({x: x, z: bounds.maxZ, type: 'top'});
            }
        }
        
        // Left edge (x = -100)
        for (let z = bounds.minZ; z <= bounds.maxZ; z += postSpacing) {
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.set(bounds.minX, postHeight/2, z);
            post.castShadow = true;
            post.receiveShadow = true;
            this.scene.add(post);
            fencePosts.push({x: bounds.minX, z: z, type: 'left'});
        }
        
        // Right edge (x = 100)
        for (let z = bounds.minZ; z <= bounds.maxZ; z += postSpacing) {
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.set(bounds.maxX, postHeight/2, z);
            post.castShadow = true;
            post.receiveShadow = true;
            this.scene.add(post);
            fencePosts.push({x: bounds.maxX, z: z, type: 'right'});
        }
        
        // Add horizontal rails between posts
        // Bottom edge rails
        for (let x = bounds.minX; x < bounds.maxX; x += postSpacing) {
            this.createFenceRail(x, bounds.minZ, x + postSpacing, bounds.minZ, railHeight1, railMaterial);
            this.createFenceRail(x, bounds.minZ, x + postSpacing, bounds.minZ, railHeight2, railMaterial);
        }
        
        // Top edge rails - connect to gate posts properly
        const gateLeftPost = gate.position.x - gate.width/2;
        const gateRightPost = gate.position.x + gate.width/2;
        
        for (let x = bounds.minX; x < bounds.maxX; x += postSpacing) {
            const nextX = x + postSpacing;
            
            // Left side of gate - connect to left gate post
            if (nextX <= gateLeftPost + 1) {
                const endX = (nextX > gateLeftPost - 1) ? gateLeftPost : nextX;
                this.createFenceRail(x, bounds.maxZ, endX, bounds.maxZ, railHeight1, railMaterial);
                this.createFenceRail(x, bounds.maxZ, endX, bounds.maxZ, railHeight2, railMaterial);
            }
            
            // Right side of gate - connect from right gate post
            if (x >= gateRightPost - 1) {
                const startX = (x < gateRightPost + 1) ? gateRightPost : x;
                this.createFenceRail(startX, bounds.maxZ, nextX, bounds.maxZ, railHeight1, railMaterial);
                this.createFenceRail(startX, bounds.maxZ, nextX, bounds.maxZ, railHeight2, railMaterial);
            }
        }
        
        // Left edge rails
        for (let z = bounds.minZ; z < bounds.maxZ; z += postSpacing) {
            this.createFenceRail(bounds.minX, z, bounds.minX, z + postSpacing, railHeight1, railMaterial);
            this.createFenceRail(bounds.minX, z, bounds.minX, z + postSpacing, railHeight2, railMaterial);
        }
        
        // Right edge rails
        for (let z = bounds.minZ; z < bounds.maxZ; z += postSpacing) {
            this.createFenceRail(bounds.maxX, z, bounds.maxX, z + postSpacing, railHeight1, railMaterial);
            this.createFenceRail(bounds.maxX, z, bounds.maxX, z + postSpacing, railHeight2, railMaterial);
        }
        
        return fencePosts;
    }
    
    createFenceRail(x1, z1, x2, z2, height, material) {
        const distance = Math.sqrt((x2-x1)*(x2-x1) + (z2-z1)*(z2-z1));
        if (distance < 0.1) return; // Skip very short rails
        
        const railGeometry = new THREE.CylinderGeometry(0.08, 0.08, distance, 6);
        const rail = new THREE.Mesh(railGeometry, material);
        
        // Position rail at midpoint
        rail.position.set((x1 + x2) / 2, height, (z1 + z2) / 2);
        
        // Rotate rail to connect posts
        // First rotate to horizontal (from vertical default)
        rail.rotation.z = Math.PI / 2;
        
        // Then rotate around Y axis to point in the right direction
        const angle = Math.atan2(z2 - z1, x2 - x1);
        rail.rotation.y = angle;
        
        rail.castShadow = true;
        rail.receiveShadow = true;
        this.scene.add(rail);
        
        return rail;
    }

    createGateAndPasture(gate, pasture) {
        const gateElements = [];
        
        // Create gate posts - taller and more prominent
        const postGeometry = new THREE.CylinderGeometry(0.4, 0.4, gate.height + 1, 8);
        const postMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x4a3c28,
            emissive: 0x1a0a00,
            emissiveIntensity: 0.1
        });
        
        // Left post
        const leftPost = new THREE.Mesh(postGeometry, postMaterial);
        leftPost.position.set(gate.position.x - gate.width/2, (gate.height + 1)/2, gate.position.z);
        leftPost.castShadow = true;
        leftPost.receiveShadow = true;
        this.scene.add(leftPost);
        gateElements.push(leftPost);
        
        // Right post
        const rightPost = new THREE.Mesh(postGeometry, postMaterial);
        rightPost.position.set(gate.position.x + gate.width/2, (gate.height + 1)/2, gate.position.z);
        rightPost.castShadow = true;
        rightPost.receiveShadow = true;
        this.scene.add(rightPost);
        gateElements.push(rightPost);
        
        // Decorative gate arch
        const archGeometry = new THREE.CylinderGeometry(0.2, 0.2, gate.width + 1, 8);
        const archMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x6a5a4a,
            emissive: 0x2a1a00,
            emissiveIntensity: 0.1
        });
        
        const arch = new THREE.Mesh(archGeometry, archMaterial);
        arch.position.set(gate.position.x, gate.height + 0.5, gate.position.z);
        arch.rotation.z = Math.PI / 2;
        arch.castShadow = true;
        this.scene.add(arch);
        gateElements.push(arch);
        
        // Gate threshold marker (on ground) - more prominent
        const thresholdGeometry = new THREE.BoxGeometry(gate.width + 2, 0.15, 3);
        const thresholdMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xFFD700, // Gold
            emissive: 0x806000,
            emissiveIntensity: 0.3
        });
        
        const threshold = new THREE.Mesh(thresholdGeometry, thresholdMaterial);
        threshold.position.set(gate.position.x, 0.075, gate.position.z);
        this.scene.add(threshold);
        gateElements.push(threshold);
        
        // Add welcome sign above gate
        this.createWelcomeSign(gate.position.x, gate.height + 1.5, gate.position.z - 1);
        
        // Create enhanced pasture area
        const pastureElements = this.createEnhancedPasture(pasture, gate);
        
        return {
            gate: gateElements,
            pasture: pastureElements
        };
    }
    
    createWelcomeSign(x, y, z) {
        // Sign post
        const postGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 6);
        const postMaterial = new THREE.MeshPhongMaterial({ color: 0x4a3c28 });
        const signPost = new THREE.Mesh(postGeometry, postMaterial);
        signPost.position.set(x, y - 0.5, z);
        signPost.castShadow = true;
        this.scene.add(signPost);
        
        // Sign board
        const signGeometry = new THREE.BoxGeometry(3, 0.8, 0.2);
        const signMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x8B4513,
            emissive: 0x2a1a00,
            emissiveIntensity: 0.05
        });
        const signBoard = new THREE.Mesh(signGeometry, signMaterial);
        signBoard.position.set(x, y, z);
        signBoard.castShadow = true;
        this.scene.add(signBoard);
    }
    
    createEnhancedPasture(pasture, gate) {
        const pastureElements = [];
        
        // Create a more enclosed pen with proper fencing
        this.createPenFencing(pasture, pastureElements);
        
        // Enhanced pasture ground with better texture
        const pastureGeometry = new THREE.PlaneGeometry(
            pasture.maxX - pasture.minX + 4, 
            pasture.maxZ - pasture.minZ + 4
        );
        
        // Create enhanced pasture texture
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 1024;
        const context = canvas.getContext('2d');
        
        // Rich, comfortable grass for sleeping pasture
        const gradient = context.createRadialGradient(512, 512, 0, 512, 512, 512);
        gradient.addColorStop(0, '#6a8a5a');
        gradient.addColorStop(0.5, '#5a7a4a');
        gradient.addColorStop(1, '#4a6a3a');
        context.fillStyle = gradient;
        context.fillRect(0, 0, 1024, 1024);
        
        // Add clover patches
        for (let i = 0; i < 50; i++) {
            const x = Math.random() * 1024;
            const y = Math.random() * 1024;
            const radius = 20 + Math.random() * 30;
            
            const cloverGradient = context.createRadialGradient(x, y, 0, x, y, radius);
            cloverGradient.addColorStop(0, '#7a9a6a');
            cloverGradient.addColorStop(1, 'transparent');
            context.fillStyle = cloverGradient;
            context.beginPath();
            context.arc(x, y, radius, 0, Math.PI * 2);
            context.fill();
        }
        
        // Add texture details
        for (let i = 0; i < 2000; i++) {
            context.fillStyle = `rgba(${60 + Math.random() * 40}, ${120 + Math.random() * 40}, ${60 + Math.random() * 40}, 0.15)`;
            context.fillRect(Math.random() * 1024, Math.random() * 1024, 2, 2);
        }
        
        const pastureTexture = new THREE.CanvasTexture(canvas);
        pastureTexture.wrapS = THREE.RepeatWrapping;
        pastureTexture.wrapT = THREE.RepeatWrapping;
        pastureTexture.repeat.set(3, 3);
        pastureTexture.colorSpace = THREE.SRGBColorSpace;
        
        const pastureMaterial = new THREE.MeshPhongMaterial({ 
            map: pastureTexture,
            emissive: 0x1a2a1a,
            emissiveIntensity: 0.08
        });
        
        const pastureMesh = new THREE.Mesh(pastureGeometry, pastureMaterial);
        pastureMesh.rotation.x = -Math.PI / 2;
        pastureMesh.position.set(
            (pasture.minX + pasture.maxX) / 2, 
            0.02, 
            (pasture.minZ + pasture.maxZ) / 2
        );
        pastureMesh.receiveShadow = true;
        this.scene.add(pastureMesh);
        pastureElements.push(pastureMesh);
        
        // Add comfort features
        this.addPastureComfortFeatures(pasture, pastureElements);
        
        return pastureElements;
    }
    
    createPenFencing(pasture, pastureElements) {
        const fencePostGeometry = new THREE.CylinderGeometry(0.25, 0.25, 3.5, 8);
        const fencePostMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x5a4a3a,
            emissive: 0x1a0a00,
            emissiveIntensity: 0.05
        });
        
        const railMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x6a5a4a,
            emissive: 0x1a0a00,
            emissiveIntensity: 0.05
        });
        
        const postSpacing = 8;
        const railHeight1 = 1.2;
        const railHeight2 = 2.4;
        
        // Back fence (complete enclosure)
        for (let x = pasture.minX - 2; x <= pasture.maxX + 2; x += postSpacing) {
            const post = new THREE.Mesh(fencePostGeometry, fencePostMaterial);
            post.position.set(x, 1.75, pasture.maxZ + 2);
            post.castShadow = true;
            this.scene.add(post);
            pastureElements.push(post);
            
            // Add rails
            if (x < pasture.maxX + 2) {
                this.createFenceRail(x, pasture.maxZ + 2, x + postSpacing, pasture.maxZ + 2, railHeight1, railMaterial);
                this.createFenceRail(x, pasture.maxZ + 2, x + postSpacing, pasture.maxZ + 2, railHeight2, railMaterial);
            }
        }
        
        // Side fences (left and right) - stop at the boundary fence line
        for (let z = pasture.maxZ + 2; z > pasture.minZ + 2; z -= postSpacing) {
            // Left side
            const leftPost = new THREE.Mesh(fencePostGeometry, fencePostMaterial);
            leftPost.position.set(pasture.minX - 2, 1.75, z);
            leftPost.castShadow = true;
            this.scene.add(leftPost);
            pastureElements.push(leftPost);
            
            // Right side
            const rightPost = new THREE.Mesh(fencePostGeometry, fencePostMaterial);
            rightPost.position.set(pasture.maxX + 2, 1.75, z);
            rightPost.castShadow = true;
            this.scene.add(rightPost);
            pastureElements.push(rightPost);
            
            // Add rails
            if (z > pasture.minZ + 2) {
                this.createFenceRail(pasture.minX - 2, z, pasture.minX - 2, z - postSpacing, railHeight1, railMaterial);
                this.createFenceRail(pasture.minX - 2, z, pasture.minX - 2, z - postSpacing, railHeight2, railMaterial);
                this.createFenceRail(pasture.maxX + 2, z, pasture.maxX + 2, z - postSpacing, railHeight1, railMaterial);
                this.createFenceRail(pasture.maxX + 2, z, pasture.maxX + 2, z - postSpacing, railHeight2, railMaterial);
            }
        }
        
        // Add corner posts to connect with boundary fence
        // Left corner post
        const leftCornerPost = new THREE.Mesh(fencePostGeometry, fencePostMaterial);
        leftCornerPost.position.set(pasture.minX - 2, 1.75, pasture.minZ + 2);
        leftCornerPost.castShadow = true;
        this.scene.add(leftCornerPost);
        pastureElements.push(leftCornerPost);
        
        // Right corner post  
        const rightCornerPost = new THREE.Mesh(fencePostGeometry, fencePostMaterial);
        rightCornerPost.position.set(pasture.maxX + 2, 1.75, pasture.minZ + 2);
        rightCornerPost.castShadow = true;
        this.scene.add(rightCornerPost);
        pastureElements.push(rightCornerPost);
        
        // Connect corner posts to the last side fence posts
        const lastSideZ = pasture.minZ + 2 + postSpacing;
        this.createFenceRail(pasture.minX - 2, lastSideZ, pasture.minX - 2, pasture.minZ + 2, railHeight1, railMaterial);
        this.createFenceRail(pasture.minX - 2, lastSideZ, pasture.minX - 2, pasture.minZ + 2, railHeight2, railMaterial);
        this.createFenceRail(pasture.maxX + 2, lastSideZ, pasture.maxX + 2, pasture.minZ + 2, railHeight1, railMaterial);
        this.createFenceRail(pasture.maxX + 2, lastSideZ, pasture.maxX + 2, pasture.minZ + 2, railHeight2, railMaterial);
        
        // Connect the nearest boundary fence posts to gate posts to close the gaps
        const gateLeftPost = -4; // Gate left post position (gate width/2 = 4)
        const gateRightPost = 4; // Gate right post position (gate width/2 = 4)
        const gateZ = 100; // Gate is at z = 100
        
        // The nearest boundary fence posts to the gate are at x = -10 and x = +10
        const nearestLeftBoundaryPost = -10;
        const nearestRightBoundaryPost = 10;
        const boundaryZ = 100; // Boundary fence is at z = 100
        
        // Left side connection from nearest boundary post to gate post
        this.createFenceRail(nearestLeftBoundaryPost, boundaryZ, gateLeftPost, gateZ, railHeight1, railMaterial);
        this.createFenceRail(nearestLeftBoundaryPost, boundaryZ, gateLeftPost, gateZ, railHeight2, railMaterial);
        
        // Right side connection from nearest boundary post to gate post
        this.createFenceRail(nearestRightBoundaryPost, boundaryZ, gateRightPost, gateZ, railHeight1, railMaterial);
        this.createFenceRail(nearestRightBoundaryPost, boundaryZ, gateRightPost, gateZ, railHeight2, railMaterial);
    }
    
    addPastureComfortFeatures(pasture, pastureElements) {
        // Add water trough
        const troughGeometry = new THREE.BoxGeometry(4, 0.8, 1.5);
        const troughMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x666666,
            emissive: 0x111111
        });
        const trough = new THREE.Mesh(troughGeometry, troughMaterial);
        trough.position.set(pasture.maxX - 5, 0.4, pasture.maxZ - 5);
        trough.castShadow = true;
        trough.receiveShadow = true;
        this.scene.add(trough);
        pastureElements.push(trough);
        
        // Add water surface
        const waterGeometry = new THREE.PlaneGeometry(3.8, 1.3);
        const waterMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x4488cc,
            transparent: true,
            opacity: 0.8,
            emissive: 0x002244,
            emissiveIntensity: 0.1
        });
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.set(pasture.maxX - 5, 0.81, pasture.maxZ - 5);
        this.scene.add(water);
        pastureElements.push(water);
        
        // Add hay bales for comfort
        const hayGeometry = new THREE.CylinderGeometry(1.5, 1.5, 1.2, 8);
        const hayMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xDAA520,
            emissive: 0x2a1a00,
            emissiveIntensity: 0.05
        });
        
        // Place several hay bales
        const hayPositions = [
            { x: pasture.minX + 5, z: pasture.maxZ - 8 },
            { x: pasture.maxX - 10, z: pasture.minZ + 8 },
            { x: (pasture.minX + pasture.maxX) / 2, z: pasture.maxZ - 12 }
        ];
        
        hayPositions.forEach(pos => {
            const hayBale = new THREE.Mesh(hayGeometry, hayMaterial);
            hayBale.position.set(pos.x, 0.6, pos.z);
            hayBale.rotation.z = Math.PI / 2; // Lay on side
            hayBale.castShadow = true;
            hayBale.receiveShadow = true;
            this.scene.add(hayBale);
            pastureElements.push(hayBale);
        });
        
        // Tree removed from pen area for better gameplay
    }
}
```

## js/TerrainBuilder.js

```javascript
import * as THREE from 'three';

/**
 * TerrainBuilder - Handles terrain, grass, mountains, and environmental elements
 */
export class TerrainBuilder {
    constructor(scene) {
        this.scene = scene;
        this.grassMaterial = null;
        this.grassInstanceCount = 0;
    }
    
    createTerrain() {
        // Create flat terrain - extended to match grass coverage
        const terrainGeometry = new THREE.PlaneGeometry(1000, 1000);
        const terrainMaterial = new THREE.MeshPhongMaterial({
            color: 0x4a7c4a,
            emissive: 0x1a3a1a,
            emissiveIntensity: 0.1,
            shininess: 0
        });
        
        const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
        terrain.rotation.x = -Math.PI / 2;
        terrain.position.y = 0;
        terrain.receiveShadow = true;
        this.scene.add(terrain);
        
        return terrain;
    }
    
    createGrass() {
        // Create instanced grass using shaders
        const grassVertexShader = `
            varying vec2 vUv;
            varying vec3 vWorldPos;
            uniform float time;
            
            void main() {
                vUv = uv;
                
                // Get instance position
                vec3 pos = position;
                vec4 mvPosition = vec4(pos, 1.0);
                
                #ifdef USE_INSTANCING
                    mvPosition = instanceMatrix * mvPosition;
                #endif
                
                vWorldPos = (modelMatrix * mvPosition).xyz;
                
                // Wind displacement - stronger at blade tips
                float dispPower = 1.0 - cos(uv.y * 3.14159 / 2.0);
                
                // Complex wind pattern
                float windX = sin(vWorldPos.z * 0.1 + time * 2.0) * cos(vWorldPos.x * 0.1 + time * 1.5);
                float windZ = cos(vWorldPos.x * 0.15 + time * 2.5) * sin(vWorldPos.z * 0.15 + time * 2.0);
                
                float displacement = windX * (0.15 * dispPower);
                mvPosition.x += displacement;
                mvPosition.z += windZ * (0.1 * dispPower);
                
                vec4 modelViewPosition = modelViewMatrix * mvPosition;
                gl_Position = projectionMatrix * modelViewPosition;
            }
        `;
        
        const grassFragmentShader = `
            varying vec2 vUv;
            varying vec3 vWorldPos;
            uniform vec3 fogColor;
            uniform float fogNear;
            uniform float fogFar;
            
            void main() {
                // Gradient from dark at base to light at tips
                vec3 baseColor = vec3(0.2, 0.5, 0.1);
                vec3 tipColor = vec3(0.41, 0.8, 0.3);
                
                // Add some color variation based on world position
                float colorVariation = sin(vWorldPos.x * 0.5) * cos(vWorldPos.z * 0.5) * 0.1;
                
                vec3 grassColor = mix(baseColor, tipColor, vUv.y);
                grassColor += vec3(colorVariation, colorVariation * 0.5, 0.0);
                
                // Apply fog
                float depth = gl_FragCoord.z / gl_FragCoord.w;
                float fogFactor = smoothstep(fogNear, fogFar, depth);
                
                vec3 finalColor = mix(grassColor, fogColor, fogFactor);
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;
        
        const grassUniforms = {
            time: { value: 0 },
            fogColor: { value: new THREE.Color(0x87CEEB) },
            fogNear: { value: 200 },
            fogFar: { value: 600 }
        };
        
        this.grassMaterial = new THREE.ShaderMaterial({
            vertexShader: grassVertexShader,
            fragmentShader: grassFragmentShader,
            uniforms: grassUniforms,
            side: THREE.DoubleSide
        });
        
        // Create grass blade geometry - small
        const bladeGeometry = new THREE.PlaneGeometry(0.05, 0.8, 1, 4);
        bladeGeometry.translate(0, 0.4, 0); // Move pivot to base
        
        // Create instanced mesh for grass - optimized for performance
        // Reduce grass count for better performance on high-end systems
        const instanceCount = 400000; // Reduced from 800k for better performance
        this.grassInstanceCount = instanceCount;
        const grassMesh = new THREE.InstancedMesh(bladeGeometry, this.grassMaterial, instanceCount);
        
        const dummy = new THREE.Object3D();
        
        // Distribute grass instances - extend much further out
        let placedCount = 0;
        for (let i = 0; i < instanceCount && placedCount < instanceCount; i++) {
            // Random position within much larger bounds - extend to horizon
            const x = (Math.random() - 0.5) * 800; // Increased from 240 to 800
            const z = (Math.random() - 0.5) * 800; // Increased from 240 to 800
            
            // Skip grass in the pasture area
            if (z > 100 && z < 130 && Math.abs(x) < 30) {
                continue;
            }
            
            dummy.position.set(x, 0, z);
            
            // Random scale and rotation with distance-based scaling
            const distanceFromCenter = Math.sqrt(x * x + z * z);
            const distanceScale = Math.max(0.3, 1.0 - distanceFromCenter / 600); // Grass gets smaller with distance
            const scale = (0.8 + Math.random() * 0.4) * distanceScale;
            dummy.scale.setScalar(scale);
            dummy.rotation.y = Math.random() * Math.PI * 2;
            
            // Slight random tilt
            dummy.rotation.z = (Math.random() - 0.5) * 0.1;
            
            dummy.updateMatrix();
            grassMesh.setMatrixAt(placedCount, dummy.matrix);
            placedCount++;
        }
        
        grassMesh.castShadow = true;
        grassMesh.receiveShadow = true;
        this.scene.add(grassMesh);
        
        return grassMesh;
    }
    
    createTrees() {
        // Tree trunk material
        const trunkMaterial = new THREE.MeshPhongMaterial({
            color: 0x4a3a2a,
            emissive: 0x1a0a00,
            emissiveIntensity: 0.05
        });
        
        // Richer foliage materials for variety & realism
        const foliageMaterials = [
            new THREE.MeshPhongMaterial({
                color: 0x355e29,
                emissive: 0x0e1a0e,
                emissiveIntensity: 0.1,
                flatShading: true
            }),
            new THREE.MeshPhongMaterial({
                color: 0x426b33,
                emissive: 0x112411,
                emissiveIntensity: 0.1,
                flatShading: true
            }),
            new THREE.MeshPhongMaterial({
                color: 0x274b1f,
                emissive: 0x091609,
                emissiveIntensity: 0.1,
                flatShading: true
            })
        ];

        // Helper to add slight noise to a spherical geometry for a fluffier canopy
        const addCanopyNoise = (geometry, amplitude = 0.4) => {
            const positionAttr = geometry.attributes.position;
            const normal = new THREE.Vector3();
            for (let i = 0; i < positionAttr.count; i++) {
                normal.set(
                    positionAttr.getX(i),
                    positionAttr.getY(i),
                    positionAttr.getZ(i)
                ).normalize();
                const offset = (Math.random() - 0.5) * amplitude;
                positionAttr.setXYZ(
                    i,
                    positionAttr.getX(i) + normal.x * offset,
                    positionAttr.getY(i) + normal.y * offset,
                    positionAttr.getZ(i) + normal.z * offset
                );
            }
            geometry.computeVertexNormals();
        };

        const trees = [];

        /***********************
         *  DECIDUOUS TREES   *
         ***********************/
        for (let i = 0; i < 200; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 120 + Math.random() * 300; // Spread trees further out
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;

            // Keep play area clear
            if (Math.abs(x) < 120 && Math.abs(z) < 120) continue;
            if (z > 100 && z < 135 && Math.abs(x) < 35) continue;

            // Trunk
            const trunkHeight = 7 + Math.random() * 5;
            const trunkRadius = 0.6 + Math.random() * 0.5;
            const trunkGeometry = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, 8);
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, trunkHeight / 2, z);
            trunk.castShadow = true;
            this.scene.add(trunk);
            trees.push(trunk);

            // Canopy – multiple irregular lumps for an organic silhouette
            const canopyLumps = 3 + Math.floor(Math.random() * 2); // 3-4 lumps
            const materialIndex = Math.floor(Math.random() * foliageMaterials.length);

            for (let l = 0; l < canopyLumps; l++) {
                const radius = 4 + Math.random() * 2 - l * 0.5;
                const icoDetail = 1; // keeps polycount low
                const canopyGeometry = new THREE.IcosahedronGeometry(radius, icoDetail);
                addCanopyNoise(canopyGeometry, 0.5);

                const canopy = new THREE.Mesh(canopyGeometry, foliageMaterials[materialIndex]);
                canopy.position.set(
                    x + (Math.random() - 0.5) * 1.5,
                    trunkHeight + radius / 2 + l * 0.8 + Math.random() * 0.5,
                    z + (Math.random() - 0.5) * 1.5
                );
                canopy.rotation.y = Math.random() * Math.PI;
                canopy.castShadow = true;
                canopy.receiveShadow = true;
                this.scene.add(canopy);
                trees.push(canopy);
            }
        }

        /***********************
         *      PINE TREES    *
         ***********************/
        for (let i = 0; i < 80; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 140 + Math.random() * 250;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;

            if (Math.abs(x) < 120 && Math.abs(z) < 120) continue;
            if (z > 100 && z < 135 && Math.abs(x) < 35) continue;

            // Trunk
            const trunkHeight = 5 + Math.random() * 3;
            const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, trunkHeight, 6);
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, trunkHeight / 2, z);
            trunk.castShadow = true;
            this.scene.add(trunk);
            trees.push(trunk);

            // Layered foliage – stacked cones for a stylised pine
            const layers = 3 + Math.floor(Math.random() * 2); // 3-4 layers
            const baseHeight = trunkHeight;
            const pineMaterial = new THREE.MeshPhongMaterial({
                color: 0x1e4b1e,
                emissive: 0x061406,
                emissiveIntensity: 0.1,
                flatShading: true
            });

            for (let l = 0; l < layers; l++) {
                const layerRadius = 3 - l * 0.6 + Math.random() * 0.4;
                const layerHeight = 4 + Math.random() * 1.5;
                const layerGeometry = new THREE.ConeGeometry(layerRadius, layerHeight, 8, 1, true);

                addCanopyNoise(layerGeometry, 0.3);

                const layerMesh = new THREE.Mesh(layerGeometry, pineMaterial);
                layerMesh.position.set(
                    x,
                    baseHeight + l * 2 + layerHeight / 2,
                    z
                );
                layerMesh.rotation.y = Math.random() * Math.PI;
                layerMesh.castShadow = true;
                layerMesh.receiveShadow = true;
                this.scene.add(layerMesh);
                trees.push(layerMesh);
            }
        }

        return trees;
    }
    
    addEnvironmentDetails() {
        // Add rocks - placed outside the play area
        const rockGeometry = new THREE.DodecahedronGeometry(1, 0);
        const rockMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x666666,
            emissive: 0x111111,
            emissiveIntensity: 0.05,
            flatShading: true
        });
        
        const rocks = [];
        
        // Play area boundaries to avoid: X: -100 to 100, Z: -100 to 130 (including pasture)
        const playAreaBounds = {
            minX: -100,
            maxX: 100,
            minZ: -100,
            maxZ: 130
        };
        
        // Increase rock count since we have more area to fill
        for (let i = 0; i < 40; i++) {
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            let x, z;
            let attempts = 0;
            
            // Find a position outside the play area
            do {
                // Generate position in larger area (400x400)
                x = (Math.random() - 0.5) * 400;
                z = (Math.random() - 0.5) * 400;
                attempts++;
                
                // Prevent infinite loop
                if (attempts > 100) {
                    // Force placement in known safe areas
                    if (Math.random() < 0.5) {
                        // Place far left or right
                        x = Math.random() < 0.5 ? -150 - Math.random() * 100 : 150 + Math.random() * 100;
                        z = (Math.random() - 0.5) * 300;
                    } else {
                        // Place far north or south
                        x = (Math.random() - 0.5) * 300;
                        z = Math.random() < 0.5 ? -150 - Math.random() * 100 : 180 + Math.random() * 100;
                    }
                    break;
                }
            } while (
                x >= playAreaBounds.minX && x <= playAreaBounds.maxX &&
                z >= playAreaBounds.minZ && z <= playAreaBounds.maxZ
            );
            
            rock.position.set(x, 0.5, z);
            rock.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            
            const scale = 0.5 + Math.random() * 1.5;
            rock.scale.set(scale, scale * 0.7, scale);
            
            rock.castShadow = true;
            rock.receiveShadow = true;
            this.scene.add(rock);
            rocks.push(rock);
        }
        
        return rocks;
    }
    
    updateGrassAnimation() {
        if (this.grassMaterial) {
            this.grassMaterial.uniforms.time.value = performance.now() * 0.001;
        }
    }
    
    getGrassMaterial() {
        return this.grassMaterial;
    }
    
    getGrassInstanceCount() {
        return this.grassInstanceCount;
    }
}
```

## js/Vector2D.js

```javascript
/**
 * Simple 2D Vector class for XZ plane calculations
 */
export class Vector2D {
    constructor(x = 0, z = 0) {
        this.x = x;
        this.z = z;
    }

    // Set the x and z components
    set(x, z) {
        this.x = x;
        this.z = z;
        return this;
    }

    // Add another vector to this one
    add(vector) {
        this.x += vector.x;
        this.z += vector.z;
        return this;
    }

    // Subtract another vector from this one
    subtract(vector) {
        this.x -= vector.x;
        this.z -= vector.z;
        return this;
    }

    // Multiply by a scalar
    multiply(scalar) {
        this.x *= scalar;
        this.z *= scalar;
        return this;
    }

    // Divide by a scalar
    divide(scalar) {
        if (scalar !== 0) {
            this.x /= scalar;
            this.z /= scalar;
        }
        return this;
    }

    // Get the magnitude (length) of the vector
    magnitude() {
        return Math.sqrt(this.x * this.x + this.z * this.z);
    }

    // Normalize the vector (make it unit length)
    normalize() {
        const len = this.magnitude();
        if (len > 0.00001) { // Use a small epsilon to prevent division by zero/tiny number
            this.x /= len;
            this.z /= len;
        } else {
            this.x = 0;
            this.z = 0;
        }
        return this;
    }

    // Limit the magnitude of the vector
    limit(max) {
        const len = this.magnitude();
        if (len > max && len > 0.00001) { // Only normalize if magnitude is significant and over max
            this.normalize();
            this.multiply(max);
        }
        return this;
    }

    // Get distance to another vector
    distanceTo(vector) {
        const dx = this.x - vector.x;
        const dz = this.z - vector.z;
        return Math.sqrt(dx * dx + dz * dz);
    }

    // Get the angle of the vector in radians
    angle() {
        return Math.atan2(this.z, this.x);
    }

    // Set the magnitude of the vector
    setMagnitude(magnitude) {
        this.normalize();
        this.multiply(magnitude);
        return this;
    }

    // Create a copy of this vector
    clone() {
        return new Vector2D(this.x, this.z);
    }

    // Static method to create a vector from an angle
    static fromAngle(angle) {
        return new Vector2D(Math.cos(angle), Math.sin(angle));
    }

    // Static method to get a random unit vector
    static random() {
        const angle = Math.random() * Math.PI * 2;
        return Vector2D.fromAngle(angle);
    }
}
```

## MOBILE_CONTROLS.md

````markdown
# Mobile Controls Implementation

## Overview
The Sheep Dog Simulator includes comprehensive mobile controls for touch-based devices, providing a native mobile gaming experience with virtual joystick, zoom controls, sprint button, and fullscreen support.

## Features

### 1. Touch Device Detection
- Multi-method detection using touch events, user agent, pointer type, and screen size
- Supports iOS Safari, Android Chrome, and other mobile browsers
- Progressive enhancement (desktop unchanged, mobile enhanced)

### 2. Virtual Joystick (nipple.js)
- 360-degree movement control in bottom-left corner
- Dynamic loading from CDN (only on touch devices)
- Smooth movement with proper vector normalization
- Visual feedback with joystick handle movement

### 3. Zoom Slider
- Vertical slider in bottom-right corner
- Range: 20-150 camera distance units
- Real-time zoom updates synchronized with desktop mouse wheel
- Touch-optimized slider handle (44px minimum touch target)

### 4. Sprint Button
- Positioned below zoom slider in bottom-right
- Integrates with stamina system
- Visual feedback on press/release
- Emoji icon (🏃) for universal recognition

### 5. Mobile Fullscreen Support
- **Automatic Detection**: Shows fullscreen button only on mobile devices
- **Cross-Browser Compatibility**: Supports all fullscreen API variants:
  - `requestFullscreen()` (Standard)
  - `webkitRequestFullscreen()` (Safari)
  - `webkitRequestFullScreen()` (Older Safari)
  - `mozRequestFullScreen()` (Firefox)
  - `msRequestFullscreen()` (IE/Edge)
- **User Interaction Required**: Only triggers on user tap/click
- **Smart Button Management**: 
  - Appears on page load for mobile devices
  - Hides when fullscreen is activated
  - Reappears when user exits fullscreen
  - Prevents duplicate buttons
- **Visual Design**: Prominent blue button with mobile icon and clear text
- **Touch Optimized**: Proper touch feedback and accessibility

### 6. Combined Mobile UI
- Timer, sheep count, and best time in single top-center element
- Replaces separate desktop UI elements on mobile
- Compact design optimized for small screens
- Responsive font sizes and spacing

### 7. Touch Prevention
- Disables zoom, scroll, and interfering mobile behaviors
- Prevents text selection and context menus
- Optimized for gaming experience

## Features Implemented

### 🕹️ Virtual Joystick (Movement Control)
- **Library**: nipple.js v0.10.2 from CDN
- **Position**: Bottom-left corner of screen
- **Functionality**: 
  - Replaces WASD keyboard movement
  - 360-degree movement control
  - Visual feedback with blue joystick
  - Automatic show/hide based on device detection

### 🔍 Zoom Slider (Camera Control)
- **Type**: Vertical range slider
- **Position**: Bottom-right corner of screen
- **Range**: 20-150 units (same as mouse wheel zoom)
- **Functionality**:
  - Smooth camera distance adjustment
  - Synchronized with mouse wheel on desktop
  - Custom styled for mobile touch interaction

### 🏃 Sprint Button
- **Position**: Above joystick (left side)
- **Functionality**:
  - Replaces Shift key for sprinting
  - Visual feedback (color change on press)
  - Integrates with existing stamina system
  - Touch-optimized size (60x60px)

### 📱 Device Detection & Responsiveness
- **Detection**: Multiple methods for touch capability detection
- **Responsive UI**: Mobile-optimized layouts and font sizes
- **Touch Prevention**: Disabled zoom, scroll, and other interfering behaviors
- **Cross-platform**: Works on iOS, Android, and other touch devices

## Technical Implementation

### File Structure
```
js/
├── MobileControls.js     # Main mobile controls system (new)
├── InputHandler.js       # Enhanced for mobile integration
├── SceneManager.js       # Enhanced for mobile zoom
├── main.js              # Updated with mobile controls
└── ...                  # Other existing files

index.html               # Enhanced with mobile CSS and meta tags
test-mobile.html         # Mobile controls test page (new)
```

### Key Classes and Methods

#### MobileControls.js
```javascript
class MobileControls {
    constructor()                    // Initialize mobile controls
    detectTouchDevice()              // Detect touch capability
    loadNippleJS()                   // Load nipple.js library
    createJoystick()                 // Create virtual joystick
    createZoomSlider()               // Create zoom control
    createSprintButton()             // Create sprint button
    enable() / disable()             // Show/hide controls
    getMovementDirection()           // Get joystick input
    getIsSprinting()                 // Get sprint button state
    setupTouchPrevention()           // Prevent default touch behaviors
    createFullscreenButton()          // Create fullscreen button
    requestFullscreen()              // Cross-browser fullscreen API implementation
    isFullscreenSupported()          // Checks for fullscreen API availability
    setupFullscreenListeners()        // Handles fullscreen state changes
}
```

#### Enhanced InputHandler.js
```javascript
class InputHandler {
    setMobileControls(mobileControls) // Connect mobile controls
    getMovementDirection()            // Combined keyboard + mobile input
    isMoving()                       // Combined movement detection
    isSprinting()                    // Combined sprint detection
}
```

#### Enhanced SceneManager.js
```javascript
class SceneManager {
    setMobileControls(mobileControls) // Connect for zoom integration
    setupMouseControls()              // Desktop-only mouse wheel
    getCameraDistance()               // Get current zoom level
    setCameraDistance(distance)       // Set zoom level from mobile
}
```

### Mobile-Specific CSS Features

#### Viewport and Touch Behavior
```css
/* Prevent zoom and scrolling */
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">

/* Prevent touch behaviors */
body {
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
}

#canvas-container {
    touch-action: none;
    overscroll-behavior: none;
}
```

#### Responsive Design
```css
/* Mobile-optimized UI scaling */
@media (max-width: 768px) {
    #game-title { font-size: 2.5rem; }
    #instructions { padding: 10px; font-size: 12px; }
    #stamina-bar { min-width: 150px; }
    /* ... other responsive adjustments */
}
```

#### Mobile Controls Styling
```css
/* Ensure mobile controls are interactive */
#mobile-joystick,
#mobile-zoom,
#mobile-sprint {
    pointer-events: auto !important;
    z-index: 1001 !important;
}
```

## Integration Points

### 1. Input System Integration
- Mobile controls integrate seamlessly with existing InputHandler
- Keyboard and touch inputs work simultaneously (desktop + mobile)
- Pause system works with both input methods
- No disruption to existing game logic

### 2. Camera System Integration
- Mobile zoom slider synchronizes with mouse wheel zoom
- Same zoom range and behavior as desktop
- Smooth transitions and consistent camera movement

### 3. UI System Integration
- Mobile controls appear only on touch devices
- Responsive layouts for different screen sizes
- Instructions update automatically for mobile users
- Pause indicator adapts to input method

### 4. Game Loop Integration
- Mobile controls update in same game loop
- No performance impact on desktop users
- Consistent frame rate across platforms

## Browser Compatibility

### Supported Browsers
- **iOS Safari**: 13+ (full support)
- **Chrome Mobile**: 80+ (full support)
- **Firefox Mobile**: 75+ (full support)
- **Samsung Internet**: 12+ (full support)
- **Edge Mobile**: 80+ (full support)

### Feature Detection
```javascript
// Multiple detection methods for maximum compatibility
detectTouchDevice() {
    return ('ontouchstart' in window) || 
           (navigator.maxTouchPoints > 0) || 
           (navigator.msMaxTouchPoints > 0);
}
```

## Performance Considerations

### Optimizations
- **Lazy Loading**: nipple.js loads only on touch devices
- **Event Throttling**: Touch events are efficiently handled
- **Memory Management**: Proper cleanup of mobile controls
- **Minimal Overhead**: No impact on desktop performance

### Resource Usage
- **nipple.js**: ~15KB compressed
- **Additional CSS**: ~2KB
- **JavaScript**: ~8KB for mobile controls
- **Total Overhead**: <25KB for mobile functionality

## Testing

### Test Page
- `test-mobile.html` - Standalone mobile controls test
- Tests joystick, zoom slider, and sprint button
- Device detection and library loading verification
- Real-time input feedback

### Testing Checklist
- [ ] Touch device detection works correctly
- [ ] Virtual joystick responds to touch input
- [ ] Zoom slider adjusts camera distance
- [ ] Sprint button activates/deactivates properly
- [ ] No interference with desktop controls
- [ ] Responsive design works on various screen sizes
- [ ] Touch prevention stops unwanted behaviors

## Usage Instructions

### For Players
1. **Movement**: Use the blue joystick in the bottom-left corner
2. **Sprint**: Tap and hold the sprint button (🏃) above the joystick
3. **Zoom**: Use the vertical slider on the bottom-right to adjust camera distance
4. **Pause**: Tap the pause indicator when game is paused

### For Developers
1. Mobile controls initialize automatically on touch devices
2. No additional setup required beyond including MobileControls.js
3. Controls integrate with existing input system transparently
4. Use `mobileControls.getIsTouchDevice()` to check device type

## Future Enhancements

### Potential Improvements
- **Haptic Feedback**: Vibration on sprint/collision
- **Gesture Controls**: Pinch-to-zoom alternative
- **Customizable Layout**: User-adjustable control positions
- **Multiple Joysticks**: Separate movement and camera controls
- **Voice Commands**: Accessibility improvements

### Performance Optimizations
- **WebGL Optimizations**: Mobile-specific rendering adjustments
- **Battery Optimization**: Reduced frame rate options
- **Memory Management**: Further optimization for low-end devices

## Troubleshooting

### Common Issues
1. **Joystick not appearing**: Check device detection and nipple.js loading
2. **Touch events not working**: Verify touch prevention setup
3. **Zoom not synchronized**: Check SceneManager mobile controls connection
4. **Performance issues**: Consider reducing grass instances on mobile

### Debug Tools
- Browser developer tools for touch event inspection
- `test-mobile.html` for isolated testing
- Console logging in MobileControls.js for debugging

## Conclusion

The mobile controls implementation provides a complete touch-based interface for the Sheep Dog Simulator while maintaining full compatibility with desktop controls. The system is designed for performance, usability, and cross-platform compatibility, ensuring a smooth gaming experience across all devices.
````

## package.json

```json
{
  "name": "sheep-dog-sim",
  "version": "1.0.0",
  "description": "An interactive herding game where players control a sheepdog to guide sheep into a pen using boid flocking algorithms",
  "type": "module",
  "main": "index.html",
  "scripts": {
    "start": "python -m http.server 8000",
    "serve": "npx http-server -p 8000"
  },
  "keywords": [
    "game",
    "simulation",
    "boids",
    "flocking",
    "three.js",
    "herding"
  ],
  "author": "",
  "license": "MIT",
  "devDependencies": {
    "http-server": "^14.1.1",
    "stats.js": "^0.17.0"
  },
  "dependencies": {
    "@geckos.io/client": "^3.0.1"
  }
}
```

## README.md

````markdown
# Sheep Dog Simulation

A sophisticated web-based herding simulation where players control a sheepdog to guide 200 sheep through a gate into a designated pasture. The simulation features realistic boid flocking behavior, immersive 3D environments, competitive timing mechanics, and polished user experience with cinematic start screen, stamina system, pause functionality, and **full mobile touch controls**.

## 🎮 Features

### Core Gameplay
- **Interactive Herding**: Control a sheepdog using WASD keys or touch controls to guide sheep through a gate
- **Stamina System**: Sprint with Shift key or sprint button while managing stamina for strategic gameplay
- **Realistic AI**: 200 sheep with sophisticated boid flocking behavior (cohesion, separation, alignment)
- **Goal-Oriented**: Guide all sheep through the gate into the sleeping pasture
- **Competitive Timing**: Race against the clock with best time tracking

### Mobile & Touch Support 📱
- **Virtual Joystick**: Touch-based movement control using nipple.js library
- **Zoom Slider**: Vertical slider for camera distance adjustment on mobile
- **Sprint Button**: Touch-optimized sprint control with visual feedback
- **Responsive Design**: Mobile-optimized UI layouts and touch-friendly interactions
- **Cross-Platform**: Seamless experience across desktop and mobile devices

### User Experience
- **Cinematic Start Screen**: Professional start screen with orbital camera showcasing the field
- **Pause System**: Escape key or touch pauses all game systems with visual indicator
- **Stamina Management**: Visual stamina bar with color-coded states and sprint mechanics
- **Smooth Transitions**: Polished UI transitions between start screen and gameplay
- **Enhanced Controls**: Responsive movement with acceleration/deceleration and sprint system

### Visual & Environmental
- **Expansive World**: Extended grass coverage reaching to the horizon (800x800 units)
- **Realistic Terrain**: Multi-layered mountains with geometric variation
- **Detailed Forests**: Realistic trees with trunks, multiple foliage layers, and pine varieties
- **Dynamic Grass**: 800,000 animated grass instances with wind effects via shaders
- **Atmospheric Effects**: Fog system and advanced lighting for depth and immersion
- **Enhanced Sheepdog**: Detailed 3D model with realistic animations and idle behaviors

### Game Systems
- **Timer System**: Automatic timing with best score persistence in localStorage
- **Progress Tracking**: Real-time sheep count and completion status
- **Boundary System**: Intelligent field boundaries with fence structures
- **Gate Mechanics**: Directional passage detection with velocity validation
- **Performance Monitor**: Toggle-able performance statistics with 'P' key

### Technical Excellence
- **Modular Architecture**: Clean, maintainable code structure with separated concerns
- **Performance Optimized**: Instanced rendering for grass, shared geometries for efficiency
- **Responsive Design**: Dynamic camera system with mouse wheel zoom control
- **Cross-Platform**: Works on desktop and modern mobile browsers with touch controls

## 🚀 Quick Start

### Prerequisites
- Modern web browser (Chrome 80+, Firefox 75+, Safari 13+, Edge 80+)
- Local web server (Python, Node.js, or any HTTP server)
- **Mobile**: iOS 13+, Android Chrome 80+, or equivalent modern mobile browser

### Installation & Setup

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd sheep-dog
   ```

2. **Start a local web server**
   
   Using Python 3:
   ```bash
   python -m http.server 8000
   ```
   
   Using Node.js (if you have `http-server` installed):
   ```bash
   npx http-server -p 8000
   ```

3. **Open in browser**
   Navigate to `http://localhost:8000`

## 🎯 How to Play

### Desktop Controls
- **W** - Move forward
- **A** - Move left  
- **S** - Move backward
- **D** - Move right
- **Shift** - Sprint (uses stamina)
- **Escape** - Pause/Resume game
- **Mouse Wheel** - Zoom in/out
- **P** - Toggle performance statistics
- **Enter** - Start game (on start screen)

### Mobile Controls 📱
- **Virtual Joystick** (bottom-left) - Move in any direction
- **Sprint Button** 🏃 (above joystick) - Hold to sprint
- **Zoom Slider** (bottom-right) - Adjust camera distance
- **Tap Pause Indicator** - Resume when paused
- **Touch Screen** - Toggle sound

### Objective
Guide all 200 sheep through the golden gate into the pasture as quickly as possible!

### Strategy Tips
1. **Manage stamina wisely** - Sprint strategically to conserve energy for crucial moments
2. **Position strategically** - Get behind the flock relative to the gate
3. **Use flock dynamics** - Moving one sheep influences nearby sheep
4. **Apply gentle pressure** - Steady guidance works better than aggressive chasing
5. **Utilize boundaries** - Use fences to help funnel sheep toward the gate
6. **Time management** - Timer starts on first movement, so plan your approach
7. **Rest when possible** - Stamina regenerates faster when not moving

## 🏗️ Architecture

### Modular Design
The simulation uses a clean, modular architecture for maintainability and extensibility:

```
js/
├── main.js              # Main orchestrator with mobile integration (204 lines)
├── SceneManager.js      # 3D scene and rendering management (141 lines)
├── TerrainBuilder.js    # Environment creation (397 lines)
├── StructureBuilder.js  # Game structures (471 lines)
├── GameState.js         # Game logic and state management (242 lines)
├── GameTimer.js         # Timer system and best time tracking (181 lines)
├── StartScreen.js       # Start screen and cinematic camera (136 lines)
├── StaminaUI.js         # Stamina bar UI management (105 lines)
├── MobileControls.js    # Mobile touch controls system (NEW - 400+ lines)
├── Boid.js             # Base AI behavior system (248 lines)
├── OptimizedSheep.js   # High-performance sheep system (788 lines)
├── Sheepdog.js         # Enhanced player controller (683 lines)
├── InputHandler.js     # Enhanced input with mobile support (182 lines)
├── PerformanceMonitor.js # Real-time performance tracking (377 lines)
└── Vector2D.js         # 2D mathematics utilities (102 lines)
```

### Module Responsibilities

#### **MobileControls** - Touch Interface (NEW)
- Touch device detection and capability assessment
- Virtual joystick creation using nipple.js library
- Zoom slider for camera control on mobile devices
- Sprint button with touch-optimized feedback
- Touch event prevention and mobile behavior management

#### **SceneManager** - 3D Rendering (Enhanced)
- Three.js scene setup and management
- Camera control and following system
- Lighting configuration (ambient + directional)
- Mouse wheel zoom functionality (desktop) + mobile zoom integration

#### **InputHandler** - Input Management (Enhanced)
- WASD movement input handling (desktop)
- Virtual joystick integration (mobile)
- Sprint control with Shift key or touch button
- Pause system with Escape key or touch
- Cross-platform input coordination

#### **TerrainBuilder** - Environment
- Flat terrain generation (1000x1000 units)
- Instanced grass system (800,000 blades with wind shaders)
- Multi-layered mountain generation with geometric variation
- Realistic tree creation (deciduous and pine varieties)
- Environmental details (rocks, atmospheric effects)

#### **StructureBuilder** - Game Structures
- Field boundary fence system
- Gate construction with detection zones
- Pasture area with custom textures
- Fence rail connection algorithms

#### **GameState** - Logic & Configuration
- Game boundaries and parameters
- Sheep flock creation and behavior coordination
- Completion detection and UI updates
- Game state management and reset functionality
- Pause state coordination

#### **GameTimer** - Timing System
- Precision timing with performance.now()
- Best time persistence in localStorage
- New record detection and celebration
- Timer display formatting and UI updates
- Pause state handling

#### **StartScreen** - Pre-Game Experience
- Start screen overlay management
- Cinematic camera system with orbital movement
- Game launch coordination and UI transitions
- Interactive start button and keyboard support

#### **StaminaUI** - Stamina System Interface
- Stamina bar display with color-coded states
- Performance-optimized UI updates
- Visual feedback for sprinting and exhaustion
- Real-time stamina percentage display

#### **Sheepdog** - Enhanced Player Controller
- Smooth movement with acceleration/deceleration
- Stamina system with sprint mechanics
- Detailed 3D model with realistic animations
- Multiple idle behaviors for immersion

## 📱 Mobile Features

### Touch Controls
- **Virtual Joystick**: 360-degree movement control with visual feedback
- **Sprint Button**: Touch-optimized sprint control with color changes
- **Zoom Slider**: Vertical slider for smooth camera distance adjustment
- **Responsive UI**: Mobile-optimized layouts and touch-friendly sizes

### Device Detection
- **Automatic Detection**: Touch capability detection using multiple methods
- **Progressive Enhancement**: Desktop controls remain fully functional
- **Cross-Platform**: Works on iOS, Android, and other touch devices

### Performance Optimizations
- **Lazy Loading**: Mobile controls load only on touch devices
- **Efficient Events**: Optimized touch event handling
- **Memory Management**: Proper cleanup and resource management
- **Battery Friendly**: Minimal overhead for mobile devices

### Mobile-Specific Features
- **Touch Prevention**: Disabled zoom, scroll, and interfering behaviors
- **Responsive Design**: Adaptive layouts for different screen sizes
- **Visual Feedback**: Enhanced touch feedback and state indicators
- **Accessibility**: Touch-optimized button sizes and interactions

For detailed mobile implementation information, see [MOBILE_CONTROLS.md](MOBILE_CONTROLS.md).

## 🎨 Visual Features

### Enhanced Sheepdog Model
- **Detailed Design**: Procedural Border Collie with realistic proportions
- **Rich Animations**: Running, idle, breathing, looking around, ear twitching, stretching
- **Visual Feedback**: Tongue visibility when running fast, different animation speeds
- **Smooth Movement**: Acceleration-based movement with realistic turning

### Grass System
- **800,000 instances** for dense, realistic coverage
- **Shader-based animation** with complex wind patterns
- **Distance-based scaling** for realistic perspective
- **Fog integration** for atmospheric depth

### Mountain Generation
- **Multi-layered depth** with front, middle, and back mountain ranges
- **Geometric variation** with procedural vertex displacement
- **Material variety** with multiple mountain materials
- **Realistic scaling** and positioning for natural appearance

### Tree System
- **Realistic structure** with separate trunks and foliage
- **Multiple varieties** including deciduous and pine trees
- **Layered foliage** for fuller, more natural appearance
- **Strategic placement** around mountains and distant areas

### User Interface
- **Professional Start Screen**: Cinematic camera with game instructions
- **Stamina Bar**: Color-coded stamina display with state indicators
- **Pause System**: Clear pause overlay with resume instructions
- **Performance Stats**: Toggle-able FPS and rendering statistics
- **Mobile UI**: Touch-optimized controls and responsive layouts

## ⚡ Performance

### Optimizations
- **Instanced rendering** for grass (single draw call for 800k instances)
- **GPU-based sheep rendering** with single InstancedMesh for all 200 sheep
- **Vertex shader animation** for sheep movement and behavior
- **Shared geometries** for environmental objects
- **LOD considerations** with distance-based scaling
- **Efficient shadow mapping** with optimized shadow camera settings
- **Mobile optimizations** with lazy loading and efficient touch handling

### System Requirements

#### Desktop
- **Recommended**: Modern desktop with dedicated graphics
- **Minimum**: Integrated graphics with hardware acceleration enabled
- **Memory**: ~150MB for full scene with optimized rendering
- **Target Performance**: 60 FPS with 200 sheep + 800k grass instances

#### Mobile
- **iOS**: 13+ (Safari, Chrome, Firefox)
- **Android**: Chrome 80+, Firefox 75+, Samsung Internet 12+
- **Memory**: ~100MB optimized for mobile constraints
- **Target Performance**: 30-60 FPS depending on device capabilities

## 🛠️ Development

### Adding New Features
The modular architecture makes it easy to extend:

1. **New Behaviors**: Extend the `Boid` class for different AI entities
2. **Environmental Elements**: Add methods to `TerrainBuilder` for new terrain features
3. **Game Mechanics**: Extend `GameState` for new gameplay systems
4. **Visual Effects**: Enhance `SceneManager` for new rendering features
5. **UI Components**: Create new UI modules following the `StaminaUI` pattern
6. **Mobile Features**: Extend `MobileControls` for new touch interactions

### Code Style
- **ES6 Classes** for clear object-oriented structure
- **Descriptive naming** for methods and variables
- **Modular design** with single responsibility principle
- **Comprehensive comments** for complex algorithms
- **Cross-platform compatibility** considerations

## 🔧 Customization

### Adjustable Parameters (in GameState.js)
```javascript
params: {
    speed: 0.1,              // Sheep movement speed
    cohesion: 1.0,           // Flock cohesion strength  
    separationDistance: 2.0   // Minimum separation distance
}
```

### Stamina Settings (in Sheepdog.js)
```javascript
maxStamina: 100,
staminaDrainRate: 30,        // Stamina per second when sprinting
staminaRegenRate: 20,        // Stamina per second when not sprinting
minStaminaToSprint: 10,      // Minimum stamina to start sprinting
maxSpeed: 15,                // Normal movement speed
sprintSpeed: 25              // Sprint movement speed
```

### Mobile Controls Settings (in MobileControls.js)
```javascript
// Joystick configuration
joystick: {
    size: 120,               // Joystick size in pixels
    color: '#00BFFF',        // Joystick color
    threshold: 0.1,          // Movement threshold
    restOpacity: 0.7         // Opacity when not in use
}

// Zoom slider configuration
zoom: {
    min: 20,                 // Minimum zoom distance
    max: 150,                // Maximum zoom distance
    default: 80              // Default zoom level
}
```

### Environment Settings
- **Field boundaries**: Modify `bounds` object in GameState
- **Grass density**: Adjust `instanceCount` in TerrainBuilder
- **Mountain placement**: Edit `mountainLayers` arrays
- **Tree distribution**: Modify tree generation loops

## 📱 Browser Compatibility

| Platform | Browser | Minimum Version | Mobile Controls |
|----------|---------|----------------|-----------------|
| Desktop  | Chrome  | 80+            | N/A             |
| Desktop  | Firefox | 75+            | N/A             |
| Desktop  | Safari  | 13+            | N/A             |
| Desktop  | Edge    | 80+            | N/A             |
| iOS      | Safari  | 13+            | ✅ Full Support |
| iOS      | Chrome  | 80+            | ✅ Full Support |
| Android  | Chrome  | 80+            | ✅ Full Support |
| Android  | Firefox | 75+            | ✅ Full Support |
| Android  | Samsung | 12+            | ✅ Full Support |

### WebGL Requirements
- **WebGL 1.0** minimum (for Three.js compatibility)
- **Hardware acceleration** enabled for optimal performance
- **Shader support** for grass animation effects
- **Touch events** for mobile control functionality

## 🏆 Scoring System

- **Timer starts** on first movement
- **Timer stops** when all sheep pass through the gate
- **Best times** are automatically saved to localStorage
- **New records** are celebrated with special animations
- **Restart functionality** to attempt better times
- **Pause system** preserves accurate timing

## 📄 License

This project is open source and available under the MIT License. Feel free to modify, distribute, and use for educational purposes.

## 🐛 Troubleshooting

### Common Issues

**Simulation won't load:**
- Ensure you're using a web server (not file:// protocol)
- Check browser console for JavaScript errors
- Verify Three.js CDN accessibility

**Mobile controls not appearing:**
- Verify touch device detection is working
- Check that nipple.js library loads successfully
- Ensure JavaScript is enabled and no ad blockers interfere

**Poor performance:**
- Enable hardware acceleration in browser settings
- Close resource-intensive applications
- Try reducing browser zoom level
- Check if WebGL is properly enabled

**Timer not working:**
- Ensure localStorage is enabled in your browser
- Check for browser extensions blocking local storage
- Verify JavaScript is enabled

**Controls unresponsive:**
- Click on the game window to ensure focus
- Check for browser extensions intercepting input
- Verify no accessibility software is interfering
- On mobile, ensure touch events are not blocked

**Stamina system not working:**
- Ensure you're holding Shift or sprint button to sprint
- Check that the stamina bar is visible (game must be started)
- Verify the sheepdog is moving (stamina only drains during movement)

### Performance Tips
- **Desktop recommended** for best experience
- **Close unnecessary browser tabs** to free up memory
- **Update graphics drivers** for optimal WebGL performance
- **Use latest browser version** for best Three.js compatibility
- **Mobile**: Close background apps for better performance

### Mobile-Specific Tips
- **Landscape orientation** recommended for better control layout
- **Stable internet** required for CDN library loading
- **Touch calibration** may be needed on some devices
- **Battery optimization** disable for best performance

## 🤝 Contributing

Contributions are welcome! Areas for improvement:
- Additional sheep behaviors and AI states
- Weather and day/night cycle systems
- Multiple difficulty levels and objectives
- Enhanced particle effects and post-processing
- Advanced mobile features (haptic feedback, gestures)
- Sound effects and ambient audio
- Achievement system and game modes
- Multiplayer functionality
- Accessibility improvements
````

## server/GameSimulation.js

```javascript
/**
 * Authoritative Game Simulation for Multiplayer Sheepdog
 * Uses shared simulation logic to ensure consistency across all clients
 */

// Import shared simulation logic
import {
    Vector2D,
    calculateFlockingForce,
    calculateFlee,
    getNeighbors,
    updateMovement,
    applyAcceleration,
    updateStamina,
    calculateBoundaryAvoidanceWithGate,
    applyHardBoundaryConstraints,
    updateSheepRetirements,
    checkGameCompletion,
    validateEntityState,
    generateInitialSheepPositions,
    createGameState,
    createBoidConfig,
    createMovementConfig
} from './shared/index.js';

export class GameSimulation {
    constructor(room) {
        this.room = room;
        this.isRunning = false;
        this.tickRate = 60; // 60 FPS server simulation
        this.deltaTime = 1 / this.tickRate;
        this.lastTickTime = 0;
        this.tickInterval = null;
        
        // Initialize game state using shared logic
        this.gameState = createGameState({
            totalSheep: 200, // Full sheep count for multiplayer
            bounds: { minX: -100, maxX: 100, minZ: -100, maxZ: 100 } // Match client field size
        });
        
        // Configuration for entities (2x faster for multiplayer)
        this.sheepConfig = createBoidConfig({
            maxSpeed: 0.24,
            maxForce: 0.05,
            perceptionRadius: 6,
            separationDistance: 2.5
        });
        
        this.dogConfigs = new Map(); // playerId -> movement config
        
        // Game state broadcasting
        this.lastGameState = null;
        this.completionData = null;
        this.completionBroadcast = false;
        
        // Initialize simulation state
        this.initializeSimulation();
        
        console.log(`🎮 Game simulation initialized for room ${room.roomCode}`);
    }

    initializeSimulation() {
        // Create initial sheep positions
        const sheepPositions = generateInitialSheepPositions(
            this.gameState.totalSheep,
            this.gameState.bounds,
            {
                spreadRadius: 25,
                centerX: -20,
                centerZ: -20
            }
        );

        // Initialize sheep entities
        this.gameState.sheep = [];
        for (let i = 0; i < this.gameState.totalSheep; i++) {
            const position = sheepPositions[i];
            const sheep = {
                id: i,
                position: position.clone(),
                velocity: new Vector2D(0, 0),
                acceleration: new Vector2D(0, 0),
                
                // Sheep-specific properties
                hasPassedGate: false,
                isRetiring: false,
                retirementTarget: null,
                state: 0, // 0: active, 1: retiring, 2: grazing
                fleeRadius: 8,
                gateAttraction: 0.5,
                
                // Animation properties for client sync
                animationPhase: Math.random() * Math.PI * 2,
                facingDirection: Math.random() * Math.PI * 2
            };
            
            this.gameState.sheep.push(sheep);
        }

        // Initialize sheepdog entities for each player
        this.sheepdogs = new Map(); // playerId -> sheepdog entity
        const playerIds = Array.from(this.room.players.keys());
        
        playerIds.forEach((playerId, index) => {
            // Position dogs in different starting locations
            const angle = (index / playerIds.length) * Math.PI * 2;
            const radius = 15;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;

            // Get dog type from room player data
            const playerInfo = this.room.getPlayer(playerId);
            const dogType = playerInfo ? playerInfo.dogType : 'jep';

            const sheepdog = {
                id: playerId,
                dogType: dogType, // Store the player's selected dog type
                position: new Vector2D(x, z),
                velocity: new Vector2D(0, 0),
                acceleration: new Vector2D(0, 0),
                
                // Sheepdog properties (2x faster for multiplayer)
                maxSpeed: 30,
                sprintSpeed: 50,
                maxStamina: 100,
                stamina: 100,
                isSprinting: false,
                
                // Add rotation tracking
                rotation: 0,
                targetRotation: 0,
                
                // Player input tracking
                inputSequence: 0,
                lastInputTime: 0,
                pendingInputs: []
            };

            this.sheepdogs.set(playerId, sheepdog);
            
            // Create movement config for this dog (2x faster for multiplayer)
            this.dogConfigs.set(playerId, createMovementConfig({
                maxSpeed: sheepdog.maxSpeed, // Already 2x (30)
                acceleration: 80, // 2x acceleration for responsiveness
                deceleration: 100  // 2x deceleration for snappier stops
            }));
        });

        // Set game as active
        this.gameState.gameActive = true;
        console.log(`🐑 Initialized ${this.gameState.totalSheep} sheep and ${this.sheepdogs.size} sheepdogs`);
    }

    start() {
        if (this.isRunning) return;
        
        this.isRunning = true;
        this.lastTickTime = Date.now();
        
        // Start the simulation loop
        this.tickInterval = setInterval(() => {
            this.tick();
        }, 1000 / this.tickRate);
        
        console.log(`🚀 Game simulation started for room ${this.room.roomCode} at ${this.tickRate} FPS`);
    }

    stop() {
        if (!this.isRunning) return;
        
        this.isRunning = false;
        
        if (this.tickInterval) {
            clearInterval(this.tickInterval);
            this.tickInterval = null;
        }
        
        console.log(`⏹️ Game simulation stopped for room ${this.room.roomCode}`);
    }

    tick() {
        if (!this.isRunning) return;
        
        const currentTime = Date.now();
        
        // Process player inputs
        this.processPlayerInputs();
        
        // Update sheepdog physics
        this.updateSheepdogs();
        
        // Update sheep behavior and movement
        this.updateSheep();
        
        // Check game completion
        this.checkGameCompletion();
        
        // Broadcast state to all clients in room
        this.broadcastGameState();
        
        this.lastTickTime = currentTime;
    }

    processPlayerInputs() {
        for (const [playerId, sheepdog] of this.sheepdogs.entries()) {
            // Process any pending inputs for this player
            while (sheepdog.pendingInputs.length > 0) {
                const input = sheepdog.pendingInputs.shift();
                this.applyPlayerInput(playerId, input);
            }
        }
    }

    applyPlayerInput(playerId, input) {
        const sheepdog = this.sheepdogs.get(playerId);
        if (!sheepdog) return;

        const { direction, sprint, inputSequence, timestamp, clientPosition } = input;
        
        // Validate input sequence to prevent old/duplicate inputs
        if (inputSequence <= sheepdog.inputSequence) {
            return; // Ignore old input
        }
        
        sheepdog.inputSequence = inputSequence;
        sheepdog.lastInputTime = timestamp;

        // Apply movement input
        const targetVelocity = new Vector2D(direction.x, direction.z);
        const currentMaxSpeed = sprint && sheepdog.stamina > 10 ? sheepdog.sprintSpeed : sheepdog.maxSpeed;
        
        if (targetVelocity.magnitude() > 0) {
            targetVelocity.normalize().multiply(currentMaxSpeed);
        }

        // Handle client-sent stopping position for smooth reconciliation
        if (clientPosition && targetVelocity.magnitude() === 0) {
            // Client is stopping and sent their final position
            // Set up interpolation target instead of normal physics
            sheepdog.clientStopTarget = new Vector2D(clientPosition.x, clientPosition.z);
            sheepdog.isInterpolatingToClient = true;
            
            // Immediately stop velocity to prevent further movement
            sheepdog.velocity.multiply(0);
            sheepdog.acceleration.multiply(0);
        } else {
            // Normal movement - clear any client interpolation
            sheepdog.clientStopTarget = null;
            sheepdog.isInterpolatingToClient = false;
            
            // Apply normal acceleration
            const config = this.dogConfigs.get(playerId);
            applyAcceleration(sheepdog, targetVelocity, this.deltaTime, config);
        }
        
        // Update stamina
        const staminaResult = updateStamina(sheepdog, sprint, this.deltaTime, {
            maxStamina: sheepdog.maxStamina,
            drainRate: 35,
            regenRate: 25,
            minStaminaToConsume: 10
        });
        
        sheepdog.stamina = staminaResult.current;
        sheepdog.isSprinting = staminaResult.isConsuming;
    }

    updateSheepdogs() {
        for (const [playerId, sheepdog] of this.sheepdogs.entries()) {
            // Use time-based movement for sheepdogs (like client)
            this.updateSheepdogMovementTimeStyle(sheepdog);

            // Update rotation based on movement direction
            if (sheepdog.velocity.magnitude() > 0.1) {
                sheepdog.targetRotation = -sheepdog.velocity.angle() + Math.PI / 2;
            }
            
            // Smooth rotation interpolation (similar to client)
            let rotationDiff = sheepdog.targetRotation - sheepdog.rotation;
            while (rotationDiff > Math.PI) rotationDiff -= 2 * Math.PI;
            while (rotationDiff < -Math.PI) rotationDiff += 2 * Math.PI;
            
            const rotationSpeed = 8; // Match client rotation speed
            sheepdog.rotation += rotationDiff * rotationSpeed * this.deltaTime;

            // Apply boundary constraints
            const constrainedPosition = applyHardBoundaryConstraints(
                sheepdog,
                this.gameState.bounds,
                null,
                { margin: 1 }
            );
            
            sheepdog.position = constrainedPosition;
            
            // Validate state to prevent NaN/Infinity
            validateEntityState(sheepdog, new Vector2D(0, 0));
        }
    }

    updateSheepdogMovementTimeStyle(sheepdog) {
        // Handle interpolation to client stopping position
        if (sheepdog.isInterpolatingToClient && sheepdog.clientStopTarget) {
            // Calculate distance to client target
            const targetPos = sheepdog.clientStopTarget;
            const currentPos = sheepdog.position;
            const distance = Math.sqrt(
                (targetPos.x - currentPos.x) ** 2 + 
                (targetPos.z - currentPos.z) ** 2
            );
            
            // If close enough, snap to target and stop interpolating
            if (distance < 0.05) {
                sheepdog.position.x = targetPos.x;
                sheepdog.position.z = targetPos.z;
                sheepdog.velocity.multiply(0);
                sheepdog.isInterpolatingToClient = false;
                sheepdog.clientStopTarget = null;
            } else {
                // Interpolate toward client position with high speed
                const interpolationSpeed = 8.0; // Fast interpolation
                const interpolationFactor = Math.min(interpolationSpeed * this.deltaTime, 0.8);
                
                sheepdog.position.x += (targetPos.x - currentPos.x) * interpolationFactor;
                sheepdog.position.z += (targetPos.z - currentPos.z) * interpolationFactor;
                sheepdog.velocity.multiply(0); // Keep velocity at zero during interpolation
            }
            
            // Reset acceleration during interpolation
            sheepdog.acceleration.multiply(0);
            return;
        }
        
        // Normal time-based physics when not interpolating to client
        const maxSpeed = sheepdog.isSprinting ? sheepdog.sprintSpeed : sheepdog.maxSpeed;
        const dampingFactor = 0.85; // More aggressive damping for snappier stops
        const velocitySmoothing = 0.6; // Less smoothing for more responsive movement
        const minMovementThreshold = 0.1; // Higher threshold for quicker stops
        
        // Store previous velocity for smoothing
        const previousVelocity = sheepdog.velocity.clone();
        
        // Update velocity with acceleration
        sheepdog.velocity.add(sheepdog.acceleration);
        sheepdog.velocity.limit(maxSpeed);
        
        // Apply velocity damping to reduce oscillations
        sheepdog.velocity.multiply(dampingFactor);
        
        // Smooth velocity with previous velocity to reduce jittering
        const smoothedVelocity = previousVelocity
            .multiply(velocitySmoothing)
            .add(sheepdog.velocity.clone().multiply(1 - velocitySmoothing));
        
        // Only apply movement if above threshold to prevent micro-movements
        if (smoothedVelocity.magnitude() > minMovementThreshold) {
            sheepdog.velocity = smoothedVelocity;
            // TIME-BASED position update (WITH deltaTime) - matches client
            sheepdog.position.add(sheepdog.velocity.clone().multiply(this.deltaTime));
        } else {
            // Stop micro-movements
            sheepdog.velocity.multiply(0);
        }
        
        // Reset acceleration for next frame
        sheepdog.acceleration.multiply(0);
    }

    updateSheep() {
        // Update each sheep using shared flocking logic
        for (let sheep of this.gameState.sheep) {
            // Skip sheep that are grazing
            if (sheep.state === 2) {
                this.updateGrazingSheep(sheep);
                continue;
            }

            // Handle retiring sheep (seeking pasture)
            if (sheep.isRetiring) {
                if (sheep.retirementTarget) {
                    // Seek retirement target in pasture
                    const desired = sheep.retirementTarget.clone().subtract(sheep.position);
                    desired.normalize();
                    desired.multiply(this.sheepConfig.maxSpeed * 0.5); // Slower when retiring
                    
                    const steer = desired.subtract(sheep.velocity);
                    steer.limit(this.sheepConfig.maxForce * 0.5);
                    sheep.acceleration.add(steer);
                    
                    // Check if reached target to transition to grazing
                    const distanceToTarget = sheep.position.distanceTo(sheep.retirementTarget);
                    if (distanceToTarget < 2) {
                        sheep.retirementTarget = null;
                        sheep.state = 2; // Set to grazing state
                    }
                }
                
                // Apply pasture containment forces
                this.applyPastureContainment(sheep);
                
                // Skip main flock behavior for retiring sheep
                this.updateSheepMovementClientStyle(sheep);
                continue;
            }

            // Get neighboring sheep for flocking (only for active sheep)
            const neighbors = getNeighbors(sheep, this.gameState.sheep, this.sheepConfig.perceptionRadius);
            
            // Apply flocking behavior
            const flockingForce = calculateFlockingForce(sheep, neighbors, this.sheepConfig);
            sheep.acceleration.add(flockingForce);

            // Apply flee behavior from all sheepdogs
            for (const sheepdog of this.sheepdogs.values()) {
                const fleeForce = calculateFlee(
                    sheep,
                    sheepdog.position,
                    sheep.fleeRadius,
                    this.sheepConfig.maxSpeed,
                    this.sheepConfig.maxForce
                );
                
                if (fleeForce.magnitude() > 0) {
                    fleeForce.multiply(1.2); // Stronger flee response
                    sheep.acceleration.add(fleeForce);
                }
            }

            // Gate attraction logic (if sheep is being herded toward gate)
            if (this.shouldSeekGate(sheep)) {
                const gateForce = this.calculateGateAttraction(sheep);
                sheep.acceleration.add(gateForce);
            }

            // Boundary avoidance
            const boundaryForce = calculateBoundaryAvoidanceWithGate(
                sheep,
                this.gameState.bounds,
                this.gameState.gate,
                {
                    margin: 4,
                    maxSpeed: this.sheepConfig.maxSpeed,
                    maxForce: this.sheepConfig.maxForce
                }
            );
            sheep.acceleration.add(boundaryForce);

            // Update movement using client-style frame-based physics (no deltaTime)
            // This matches the memory note about sheep using frame-based physics
            this.updateSheepMovementClientStyle(sheep);

            // Apply hard boundary constraints (except in gate area)
            if (!sheep.hasPassedGate) {
                const constrainedPosition = applyHardBoundaryConstraints(
                    sheep,
                    this.gameState.bounds,
                    this.gameState.gate,
                    { margin: 0.5, allowGatePassage: true }
                );
                sheep.position = constrainedPosition;
            }

            // Update facing direction for animation
            if (sheep.velocity.magnitude() > 0.001) {
                sheep.facingDirection = sheep.velocity.angle();
            }

            // Validate entity state
            validateEntityState(sheep, new Vector2D(-20, -20));
        }

        // Check for sheep retirement
        const retirementResult = updateSheepRetirements(
            this.gameState.sheep,
            this.gameState.gate,
            this.gameState.pasture
        );
        
        this.gameState.sheepRetired = retirementResult.totalRetired;
    }

    updateSheepMovementClientStyle(sheep) {
        // Frame-based physics like client Boid.js (no deltaTime multiplication)
        // This ensures consistent movement speed between client and server
        
        const maxSpeed = this.sheepConfig.maxSpeed;
        const dampingFactor = 0.98;
        const velocitySmoothing = 0.85;
        const minMovementThreshold = 0.001;
        
        // Store previous velocity for smoothing
        const previousVelocity = sheep.velocity.clone();
        
        // Update velocity with acceleration
        sheep.velocity.add(sheep.acceleration);
        sheep.velocity.limit(maxSpeed);
        
        // Apply velocity damping to reduce oscillations
        sheep.velocity.multiply(dampingFactor);
        
        // Smooth velocity with previous velocity to reduce jittering
        const smoothedVelocity = previousVelocity
            .multiply(velocitySmoothing)
            .add(sheep.velocity.clone().multiply(1 - velocitySmoothing));
        
        // Only apply movement if above threshold to prevent micro-movements
        if (smoothedVelocity.magnitude() > minMovementThreshold) {
            sheep.velocity = smoothedVelocity;
            // Frame-based position update (no deltaTime)
            sheep.position.add(sheep.velocity);
        } else {
            // Stop micro-movements
            sheep.velocity.multiply(0);
        }
        
        // Reset acceleration for next frame
        sheep.acceleration.multiply(0);
    }

    updateGrazingSheep(sheep) {
        // Gentle grazing behavior
        sheep.animationPhase += this.deltaTime;
        
        // Occasional gentle movement
        if (Math.random() < 0.002) {
            const wanderDirection = Vector2D.random();
            wanderDirection.multiply(0.3);
            sheep.acceleration.add(wanderDirection);
        }

        // Stay within pasture bounds
        this.applyPastureContainment(sheep);

        // Gentle movement update (still time-based for grazing)
        updateMovement(sheep, this.deltaTime, {
            maxSpeed: 0.03,
            dampingFactor: 0.95,
            velocitySmoothing: 0.9
        });
    }

    applyPastureContainment(sheep) {
        // Keep sheep within pasture bounds
        const pastureMargin = 2;
        const steer = new Vector2D(0, 0);
        
        if (sheep.position.x < this.gameState.pasture.minX + pastureMargin) {
            steer.x = 0.01;
        } else if (sheep.position.x > this.gameState.pasture.maxX - pastureMargin) {
            steer.x = -0.01;
        }
        
        if (sheep.position.z < this.gameState.pasture.minZ + pastureMargin) {
            steer.z = 0.01;
        } else if (sheep.position.z > this.gameState.pasture.maxZ - pastureMargin) {
            steer.z = -0.01;
        }
        
        if (steer.magnitude() > 0) {
            sheep.acceleration.add(steer);
        }
    }

    shouldSeekGate(sheep) {
        // Check if any sheepdog is nearby and sheep should be attracted to gate
        for (const sheepdog of this.sheepdogs.values()) {
            const distanceToGate = sheep.position.distanceTo(this.gameState.gate.position);
            const distanceToDog = sheep.position.distanceTo(sheepdog.position);
            
            if (distanceToDog < sheep.fleeRadius * 1.5 && distanceToGate < 30) {
                const toGate = this.gameState.gate.position.clone().subtract(sheep.position);
                const toDog = sheepdog.position.clone().subtract(sheep.position);
                
                const dotProduct = toGate.x * toDog.x + toGate.z * toDog.z;
                if (dotProduct < 0) { // Gate is opposite direction from dog
                    return true;
                }
            }
        }
        return false;
    }

    calculateGateAttraction(sheep) {
        const desired = this.gameState.gate.position.clone().subtract(sheep.position);
        desired.normalize();
        desired.multiply(this.sheepConfig.maxSpeed);
        
        const steer = desired.subtract(sheep.velocity);
        steer.limit(this.sheepConfig.maxForce);
        steer.multiply(sheep.gateAttraction);
        
        return steer;
    }

    checkGameCompletion() {
        const completion = checkGameCompletion(
            this.gameState.sheep,
            this.gameState.totalSheep,
            this.gameState.gameActive
        );

        // Debug logging for completion checking
        console.log(`Checking completion: retired=${this.gameState.sheepRetired}, total=${this.gameState.totalSheep}, isComplete=${completion.isComplete}, gameCompleted=${this.gameState.gameCompleted}`);

        if (completion.isComplete && !this.gameState.gameCompleted) {
            this.gameState.gameCompleted = true;
            
            console.log(`🎉 Game completed in room ${this.room.roomCode}! Final count: ${this.gameState.sheepRetired}/${this.gameState.totalSheep}`);
            
            // Store completion data FIRST (before finishing game)
            this.broadcastGameCompletion();
            
            // THEN finish the game (which changes room state to 'finished')
            this.room.finishGame();
        }
    }

    broadcastGameState() {
        // Create state snapshot for clients
        const gameStateSnapshot = this.createGameStateSnapshot();
        
        // Store last game state for external access
        this.lastGameState = gameStateSnapshot;
        
        // Broadcasting will be handled by the server through periodic polling
        // The server will call getLatestGameState() to get updates
    }

    broadcastGameCompletion() {
        const completionData = {
            type: 'gameComplete',
            totalSheep: this.gameState.totalSheep,
            sheepRetired: this.gameState.sheepRetired,
            gameCompleted: true,
            completionTime: Date.now() - this.room.createdAt
        };
        
        console.log('Server storing completion data:', JSON.stringify(completionData, null, 2));
        
        // Store completion data for external access
        this.completionData = completionData;
        
        // Immediately broadcast final game state and completion to all players
        // We need to access the server instance to broadcast to room
        const finalGameState = this.getLatestGameState();
        if (finalGameState && this.room.server) {
            console.log(`Immediately broadcasting final game state: sheepRetired=${finalGameState.sheepRetired}/${finalGameState.totalSheep}`);
            this.room.server.broadcastToRoom(this.room.roomCode, 'gameStateUpdate', finalGameState);
            
            console.log('Immediately broadcasting gameComplete event:', JSON.stringify(completionData, null, 2));
            this.room.server.broadcastToRoom(this.room.roomCode, 'gameComplete', completionData);
            this.completionBroadcast = true;
            
            console.log(`🎉 Immediate completion broadcast for room ${this.room.roomCode}`);
        }
    }

    // Get the latest game state for server broadcasting
    getLatestGameState() {
        return this.lastGameState;
    }

    // Get completion data if game is complete
    getCompletionData() {
        return this.completionData;
    }

    // Handle player input from network
    handlePlayerInput(playerId, inputData) {
        const sheepdog = this.sheepdogs.get(playerId);
        if (!sheepdog) return;

        // Add input to pending queue for processing on next tick
        sheepdog.pendingInputs.push({
            ...inputData,
            timestamp: Date.now()
        });
    }
    
    // Cleanup simulation resources
    cleanup() {
        this.stop();
        this.gameState = null;
        this.sheepdogs.clear();
        this.dogConfigs.clear();
        
        console.log(`🧹 Game simulation cleaned up for room ${this.room.roomCode}`);
    }

    // Get current simulation statistics
    getStats() {
        return {
            isRunning: this.isRunning,
            tickRate: this.tickRate,
            sheepCount: this.gameState.sheep.length,
            sheepRetired: this.gameState.sheepRetired,
            sheepdogCount: this.sheepdogs.size,
            gameCompleted: this.gameState.gameCompleted,
            roomCode: this.room.roomCode
        };
    }
    
    createGameStateSnapshot() {
        // Create a lightweight state snapshot for network transmission
        return {
            timestamp: Date.now(),
            sheepRetired: this.gameState.sheepRetired,
            totalSheep: this.gameState.totalSheep,
            gameCompleted: this.gameState.gameCompleted,
            
            // Sheep positions and states (simplified for network efficiency)
            sheep: this.gameState.sheep.map(sheep => ({
                id: sheep.id,
                x: Math.round(sheep.position.x * 100) / 100, // Round to 2 decimal places
                z: Math.round(sheep.position.z * 100) / 100,
                vx: Math.round(sheep.velocity.x * 100) / 100,
                vz: Math.round(sheep.velocity.z * 100) / 100,
                state: sheep.state,
                facing: Math.round(sheep.facingDirection * 100) / 100,
                hasPassedGate: sheep.hasPassedGate,
                isRetiring: sheep.isRetiring,
                // Only send retirement target if it exists (to save bandwidth)
                ...(sheep.retirementTarget && {
                    targetX: Math.round(sheep.retirementTarget.x * 100) / 100,
                    targetZ: Math.round(sheep.retirementTarget.z * 100) / 100
                })
            })),
            
            // Sheepdog positions and states
            sheepdogs: Array.from(this.sheepdogs.entries()).map(([playerId, dog]) => ({
                playerId,
                dogType: dog.dogType || 'jep', // Include dog type for client rendering
                x: Math.round(dog.position.x * 100) / 100,
                z: Math.round(dog.position.z * 100) / 100,
                vx: Math.round(dog.velocity.x * 100) / 100,
                vz: Math.round(dog.velocity.z * 100) / 100,
                rotation: Math.round(dog.rotation * 100) / 100,
                stamina: Math.round(dog.stamina),
                sprinting: dog.isSprinting,
                sequence: dog.inputSequence,
                interpolatingToClient: dog.isInterpolatingToClient || false
            }))
        };
    }
}
```

## server/index.js

```javascript
/**
 * Multiplayer Sheepdog Simulation Server
 * Main entry point with Geckos.io networking
 */

import geckos from '@geckos.io/server';
import { RoomManager } from './RoomManager.js';
import { GameSimulation } from './GameSimulation.js';

class MultiplayerServer {
    constructor(options = {}) {
        this.port = options.port || 3001;
        this.host = options.host || 'localhost';
        
        // Initialize systems
        this.roomManager = new RoomManager();
        this.io = null;
        this.players = new Map(); // socketId -> playerInfo
        
        // Server statistics
        this.stats = {
            startTime: Date.now(),
            connectionsTotal: 0,
            connectionsActive: 0,
            messagesReceived: 0,
            messagesSent: 0
        };
        
        // Maintenance interval
        this.maintenanceInterval = null;
        
        // Game state broadcast interval
        this.broadcastInterval = null;
    }

    async start() {
        try {
            console.log(`🔧 Configuring Geckos.io server with host: ${this.host}, port: ${this.port}`);
            
            // Create Geckos.io server with proper configuration for production
            this.io = geckos({
                authorization: false,
                cors: {
                    origin: '*',
                    allowAuthorization: false
                },
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ],
                // Production settings for Fly.io proxy
                maxPayload: 200000,
                pingTimeout: 60000,
                pingInterval: 25000
            });

            this.setupEventHandlers();
            this.startMaintenanceLoop();
            this.startBroadcastLoop();
            
            // Health check endpoint removed to prevent conflicts with Geckos.io routes
            
            // Listen on the specified port and host
            this.io.listen(this.port, this.host);
            
            console.log(`🚀 Multiplayer server started on ${this.host}:${this.port}`);
            console.log(`🎮 Ready for connections!`);
            console.log(`🔗 WebRTC signaling available at http://${this.host}:${this.port}/.wrtc/v2/connections`);
            console.log(`📍 Server process ID: ${process.pid}`);
            
        } catch (error) {
            console.error('❌ Failed to start server:', error);
            console.error('Stack trace:', error.stack);
            process.exit(1);
        }
    }

    // setupHealthCheck() method removed to prevent conflicts with Geckos.io internal routes

    setupEventHandlers() {
        this.io.onConnection((channel) => {
            const playerId = channel.id;
            
            console.log(`👤 Player ${playerId} connected`);
            this.stats.connectionsTotal++;
            this.stats.connectionsActive++;
            
            // Initialize player data
            this.players.set(playerId, {
                id: playerId,
                channel: channel,
                name: 'Anonymous',
                dogType: 'jep', // Default dog type
                roomCode: null,
                connectedAt: Date.now(),
                lastActivity: Date.now()
            });

            // Set up player event handlers
            this.setupPlayerEventHandlers(channel, playerId);
        });
    }

    setupPlayerEventHandlers(channel, playerId) {
        // Handle player disconnection
        channel.onDisconnect(() => {
            console.log(`👋 Player ${playerId} disconnected`);
            this.handlePlayerDisconnect(playerId);
        });

        // Room management events
        channel.on('createRoom', (data) => {
            this.handleCreateRoom(playerId, data);
        });

        channel.on('joinRoom', (data) => {
            this.handleJoinRoom(playerId, data);
        });

        channel.on('leaveRoom', () => {
            this.handleLeaveRoom(playerId);
        });

        channel.on('quickMatch', (data) => {
            this.handleQuickMatch(playerId, data);
        });

        channel.on('startGame', () => {
            this.handleStartGame(playerId);
        });

        channel.on('setReady', (data) => {
            this.handleSetReady(playerId, data.ready);
        });

        // Game input events
        channel.on('playerInput', (data) => {
            this.handlePlayerInput(playerId, data);
        });

        // Dog type updates
        channel.on('setDogType', (data) => {
            this.handleSetDogType(playerId, data);
        });

        // Utility events
        channel.on('ping', () => {
            channel.emit('pong', { timestamp: Date.now() });
        });

        channel.on('getStats', () => {
            channel.emit('serverStats', this.getServerStats());
        });
    }

    handleCreateRoom(playerId, data) {
        try {
            const player = this.players.get(playerId);
            if (!player) return;

            console.log(`🔍 DEBUG: createRoom data for ${playerId}:`, JSON.stringify(data, null, 2));
            const { roomSettings, dogType } = data;
            const room = this.roomManager.createRoom(playerId, roomSettings, dogType || 'jep');
            
            player.roomCode = room.roomCode;
            player.name = data.playerName || 'Host';
            player.dogType = dogType || 'jep'; // Store dog type in player data
            player.lastActivity = Date.now();

            // Send success response
            player.channel.emit('roomCreated', {
                success: true,
                playerId: playerId,
                room: room.getSerializableState()
            });

            console.log(`🏠 Room ${room.roomCode} created by ${playerId}`);
            
        } catch (error) {
            console.error(`❌ Error creating room for ${playerId}:`, error.message);
            this.sendError(playerId, 'createRoom', error.message);
        }
    }

    handleJoinRoom(playerId, data) {
        try {
            const player = this.players.get(playerId);
            if (!player) return;

            console.log(`🔍 DEBUG: joinRoom data for ${playerId}:`, JSON.stringify(data, null, 2));
            const { roomCode, playerName, dogType } = data;
            console.log(`🔍 DEBUG: Extracted roomCode: "${roomCode}", playerName: "${playerName}", dogType: "${dogType}"`);
            const room = this.roomManager.joinRoom(roomCode, playerId, playerName, dogType || 'jep');
            
            player.roomCode = room.roomCode;
            player.name = playerName || 'Anonymous';
            player.dogType = dogType || 'jep'; // Store dog type in player data
            player.lastActivity = Date.now();

            // Send success response to joining player
            player.channel.emit('roomJoined', {
                success: true,
                playerId: playerId,
                room: room.getSerializableState()
            });

            // Broadcast player joined to all players in room
            this.broadcastToRoom(room.roomCode, 'playerJoined', {
                playerId: playerId,
                playerName: player.name,
                room: room.getSerializableState()
            });

            console.log(`✅ Player ${playerId} joined room ${room.roomCode}`);
            
        } catch (error) {
            console.error(`❌ Error joining room for ${playerId}:`, error.message);
            this.sendError(playerId, 'joinRoom', error.message);
        }
    }

    handleLeaveRoom(playerId) {
        try {
            const player = this.players.get(playerId);
            if (!player || !player.roomCode) return;

            const oldRoomCode = player.roomCode;
            const room = this.roomManager.leaveRoom(playerId);
            
            player.roomCode = null;
            player.lastActivity = Date.now();

            // Send confirmation to leaving player
            player.channel.emit('roomLeft', { success: true });

            // If room still exists, broadcast to remaining players
            if (room) {
                this.broadcastToRoom(room.roomCode, 'playerLeft', {
                    playerId: playerId,
                    playerName: player.name,
                    room: room.getSerializableState()
                });
            }

            console.log(`👋 Player ${playerId} left room ${oldRoomCode}`);
            
        } catch (error) {
            console.error(`❌ Error leaving room for ${playerId}:`, error.message);
            this.sendError(playerId, 'leaveRoom', error.message);
        }
    }

    handleQuickMatch(playerId, data = {}) {
        try {
            const player = this.players.get(playerId);
            if (!player) return;

            const { playerName, dogType } = data;
            
            // Try to find an existing public room
            let room = this.roomManager.findQuickMatchRoom();
            
            if (!room) {
                // Create a new public room
                room = this.roomManager.createRoom(playerId, {
                    name: 'Quick Match Game',
                    maxPlayers: 4,
                    isPublic: true
                }, dogType || 'jep');
                
                player.roomCode = room.roomCode;
                player.name = playerName || 'Host';
                player.dogType = dogType || 'jep';

                player.channel.emit('roomCreated', {
                    success: true,
                    playerId: playerId,
                    room: room.getSerializableState(),
                    isQuickMatch: true
                });
            } else {
                // Join existing room
                this.roomManager.joinRoom(room.roomCode, playerId, playerName || 'Quick Match Player', dogType || 'jep');
                
                player.roomCode = room.roomCode;
                player.name = playerName || 'Quick Match Player';
                player.dogType = dogType || 'jep';

                player.channel.emit('roomJoined', {
                    success: true,
                    playerId: playerId,
                    room: room.getSerializableState(),
                    isQuickMatch: true
                });

                // Broadcast to room
                this.broadcastToRoom(room.roomCode, 'playerJoined', {
                    playerId: playerId,
                    playerName: player.name,
                    room: room.getSerializableState()
                });
            }

            player.lastActivity = Date.now();
            console.log(`⚡ Quick match for ${playerId} -> room ${room.roomCode} with dog type: ${dogType || 'jep'}`);
            
        } catch (error) {
            console.error(`❌ Error with quick match for ${playerId}:`, error.message);
            this.sendError(playerId, 'quickMatch', error.message);
        }
    }

    handleStartGame(playerId) {
        try {
            const player = this.players.get(playerId);
            if (!player || !player.roomCode) return;

            const room = this.roomManager.startGame(player.roomCode, playerId);
            
            // Add server reference to room for broadcasting
            room.server = this;
            
            // Initialize game simulation
            room.simulation = new GameSimulation(room);
            room.simulation.start();

            // Broadcast game start to all players in room
            this.broadcastToRoom(room.roomCode, 'gameStarted', {
                room: room.getSerializableState(),
                gameState: room.simulation.createGameStateSnapshot()
            });

            console.log(`🎮 Game started in room ${room.roomCode}`);
            
        } catch (error) {
            console.error(`❌ Error starting game for ${playerId}:`, error.message);
            this.sendError(playerId, 'startGame', error.message);
        }
    }

    handleSetReady(playerId, ready) {
        try {
            const player = this.players.get(playerId);
            if (!player || !player.roomCode) return;

            const room = this.roomManager.getRoom(player.roomCode);
            if (!room) return;

            room.setPlayerReady(playerId, ready);
            player.lastActivity = Date.now();

            // Broadcast ready state change to all players in room
            this.broadcastToRoom(room.roomCode, 'playerReadyChanged', {
                playerId: playerId,
                ready: ready,
                room: room.getSerializableState()
            });

            console.log(`${ready ? '✅' : '❌'} Player ${playerId} ready state: ${ready}`);
            
        } catch (error) {
            console.error(`❌ Error setting ready state for ${playerId}:`, error.message);
        }
    }

    handlePlayerInput(playerId, inputData) {
        try {
            const player = this.players.get(playerId);
            if (!player || !player.roomCode) return;

            const room = this.roomManager.getRoom(player.roomCode);
            if (!room || !room.simulation) return;

            // Forward input to game simulation
            room.simulation.handlePlayerInput(playerId, inputData);
            player.lastActivity = Date.now();
            this.stats.messagesReceived++;
            
        } catch (error) {
            console.error(`❌ Error handling input for ${playerId}:`, error.message);
        }
    }

    handleSetDogType(playerId, data) {
        try {
            const player = this.players.get(playerId);
            if (!player || !player.roomCode) return;

            const { dogType } = data;
            if (!dogType || !['jep', 'rory', 'pip'].includes(dogType)) {
                console.warn(`Invalid dog type received from ${playerId}: ${dogType}`);
                return;
            }

            const room = this.roomManager.getRoom(player.roomCode);
            if (!room) return;

            // Update player's dog type in server data
            player.dogType = dogType;
            
            // Update room player data
            const roomPlayer = room.getPlayer(playerId);
            if (roomPlayer) {
                roomPlayer.dogType = dogType;
            }

            // Update game simulation if it exists (during gameplay)
            if (room.simulation && room.simulation.sheepdogs.has(playerId)) {
                const sheepdog = room.simulation.sheepdogs.get(playerId);
                sheepdog.dogType = dogType;
            }

            player.lastActivity = Date.now();
            console.log(`🐕 Player ${playerId} changed dog type to: ${dogType}`);
            
        } catch (error) {
            console.error(`❌ Error setting dog type for ${playerId}:`, error.message);
        }
    }

    handlePlayerDisconnect(playerId) {
        this.stats.connectionsActive--;
        
        // Clean up player from room
        this.handleLeaveRoom(playerId);
        
        // Remove player data
        this.players.delete(playerId);
    }

    broadcastToRoom(roomCode, event, data) {
        const room = this.roomManager.getRoom(roomCode);
        if (!room) return;

        let messagesSent = 0;
        for (const playerId of room.players.keys()) {
            const player = this.players.get(playerId);
            if (player && player.channel) {
                player.channel.emit(event, data);
                messagesSent++;
            }
        }
        
        this.stats.messagesSent += messagesSent;
    }

    sendError(playerId, context, message) {
        const player = this.players.get(playerId);
        if (player) {
            player.channel.emit('error', {
                context: context,
                message: message,
                timestamp: Date.now()
            });
        }
    }

    startMaintenanceLoop() {
        // Run maintenance every 5 minutes
        this.maintenanceInterval = setInterval(() => {
            this.performMaintenance();
        }, 5 * 60 * 1000);
    }

    startBroadcastLoop() {
        // Broadcast game state updates every 16ms (60 FPS)
        this.broadcastInterval = setInterval(() => {
            this.broadcastGameStates();
        }, 16);
    }

    broadcastGameStates() {
        // Broadcast game state updates for all active rooms
        for (const room of this.roomManager.rooms.values()) {
            if (room.state === 'in-game' && room.simulation) {
                const gameState = room.simulation.getLatestGameState();
                if (gameState) {
                    this.broadcastToRoom(room.roomCode, 'gameStateUpdate', gameState);
                }
                
                // Note: Game completion is now handled immediately in GameSimulation.broadcastGameCompletion()
                // No need to check for completion here to avoid race conditions
            }
        }
    }

    performMaintenance() {
        console.log('🧹 Performing server maintenance...');
        
        // Clean up stale rooms
        this.roomManager.performMaintenance();
        
        // Clean up inactive players
        const now = Date.now();
        const inactiveThreshold = 10 * 60 * 1000; // 10 minutes
        
        for (const [playerId, player] of this.players.entries()) {
            if (now - player.lastActivity > inactiveThreshold) {
                console.log(`🧹 Removing inactive player ${playerId}`);
                this.handlePlayerDisconnect(playerId);
            }
        }
        
        // Log server stats
        const stats = this.getServerStats();
        console.log(`📊 Server Stats:`, stats);
    }

    getServerStats() {
        const roomStats = this.roomManager.getStats();
        const uptime = Date.now() - this.stats.startTime;
        
        return {
            uptime: uptime,
            uptimeHours: Math.floor(uptime / (1000 * 60 * 60)),
            connectionsTotal: this.stats.connectionsTotal,
            connectionsActive: this.stats.connectionsActive,
            messagesReceived: this.stats.messagesReceived,
            messagesSent: this.stats.messagesSent,
            ...roomStats
        };
    }

    stop() {
        console.log('🛑 Stopping multiplayer server...');
        
        if (this.maintenanceInterval) {
            clearInterval(this.maintenanceInterval);
        }
        
        if (this.broadcastInterval) {
            clearInterval(this.broadcastInterval);
        }
        
        // Stop all room simulations
        for (const room of this.roomManager.rooms.values()) {
            if (room.simulation) {
                room.simulation.cleanup();
            }
        }
        
        // Disconnect all players
        for (const player of this.players.values()) {
            if (player.channel) {
                player.channel.disconnect();
            }
        }
        
        if (this.io) {
            // Geckos.io server cleanup
            try {
                if (this.io.server) {
                    this.io.server.close();
                }
            } catch (error) {
                console.log('Server cleanup completed');
            }
        }
        
        console.log('✅ Server stopped');
    }
}

// Production environment logging
console.log(`🚀 Starting server in ${process.env.NODE_ENV || 'development'} mode`);
console.log(`🌐 Server will bind to ${process.env.HOST || '0.0.0.0'}:${process.env.PORT || 9208}`);
console.log(`🔧 Environment variables:`);
console.log(`   NODE_ENV: ${process.env.NODE_ENV}`);
console.log(`   HOST: ${process.env.HOST}`);
console.log(`   PORT: ${process.env.PORT}`);
console.log(`   PWD: ${process.env.PWD}`);

// Create and start server
const isLocalDevelopment = !process.env.NODE_ENV || process.env.NODE_ENV === 'development';
const server = new MultiplayerServer({
    port: parseInt(process.env.PORT) || 9208,
    host: process.env.HOST || (isLocalDevelopment ? '127.0.0.1' : '0.0.0.0')  // localhost for dev, all interfaces for production
});

// Handle graceful shutdown
process.on('SIGINT', () => {
    console.log('\n🛑 Received SIGINT, shutting down gracefully...');
    server.stop();
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log('\n🛑 Received SIGTERM, shutting down gracefully...');
    server.stop();
    process.exit(0);
});

// Start the server
server.start().catch((error) => {
    console.error('💥 Fatal error starting server:', error);
    process.exit(1);
});
```

## server/package.json

```json
{
  "name": "sds-multiplayer-server",
  "version": "1.0.0",
  "description": "Multiplayer server for Sheepdog Simulation with room-based gameplay",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "node --watch index.js",
    "test": "node test.js"
  },
  "dependencies": {
    "@geckos.io/server": "^3.0.1"
  },
  "devDependencies": {
    "@flydotio/dockerfile": "^0.7.10",
    "nodemon": "^3.0.0"
  },
  "keywords": [
    "multiplayer",
    "game-server",
    "sheepdog",
    "simulation",
    "websockets"
  ],
  "author": "SDS Team",
  "license": "MIT",
  "engines": {
    "node": ">=16.0.0"
  }
}
```

## server/RoomManager.js

```javascript
/**
 * Room Management System for Multiplayer Sheepdog Simulation
 * Handles room creation, player management, and state transitions
 */

export class RoomManager {
    constructor() {
        this.rooms = new Map(); // roomCode -> Room
        this.playerRooms = new Map(); // playerId -> roomCode
        this.publicRooms = new Set(); // Set of public room codes for quick match
    }

    /**
     * Generate a unique 6-digit room code (ABC123 format)
     */
    generateRoomCode() {
        const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const numbers = '0123456789';
        
        let code;
        let attempts = 0;
        const maxAttempts = 100;
        
        do {
            code = '';
            // Generate 3 letters
            for (let i = 0; i < 3; i++) {
                code += letters.charAt(Math.floor(Math.random() * letters.length));
            }
            // Generate 3 numbers
            for (let i = 0; i < 3; i++) {
                code += numbers.charAt(Math.floor(Math.random() * numbers.length));
            }
            attempts++;
        } while (this.rooms.has(code) && attempts < maxAttempts);
        
        if (attempts >= maxAttempts) {
            throw new Error('Failed to generate unique room code');
        }
        
        return code;
    }

    /**
     * Validate room code format (ABC123)
     */
    validateRoomCode(roomCode) {
        if (typeof roomCode !== 'string' || roomCode.length !== 6) {
            return false;
        }
        
        // Check format: 3 letters followed by 3 numbers
        const pattern = /^[A-Z]{3}[0-9]{3}$/;
        return pattern.test(roomCode.toUpperCase());
    }

    /**
     * Create a new room
     */
    createRoom(hostPlayerId, roomSettings = {}, hostDogType = 'jep') {
        const {
            name = 'Sheepdog Game',
            maxPlayers = 4,
            isPublic = false
        } = roomSettings;

        // Validate maxPlayers
        if (maxPlayers < 2 || maxPlayers > 4) {
            throw new Error('Room must allow 2-4 players');
        }

        // Check if player is already in a room
        if (this.playerRooms.has(hostPlayerId)) {
            throw new Error('Player is already in a room');
        }

        const roomCode = this.generateRoomCode();
        const room = new Room(roomCode, hostPlayerId, { name, maxPlayers, isPublic }, hostDogType);
        
        this.rooms.set(roomCode, room);
        this.playerRooms.set(hostPlayerId, roomCode);
        
        if (isPublic) {
            this.publicRooms.add(roomCode);
        }

        console.log(`✅ Room ${roomCode} created by ${hostPlayerId} (${isPublic ? 'public' : 'private'})`);
        return room;
    }

    /**
     * Join an existing room
     */
    joinRoom(roomCode, playerId, playerName = 'Anonymous', dogType = 'jep') {
        roomCode = roomCode.toUpperCase();
        
        if (!this.validateRoomCode(roomCode)) {
            throw new Error('Invalid room code format');
        }

        if (!this.rooms.has(roomCode)) {
            throw new Error('Room not found');
        }

        if (this.playerRooms.has(playerId)) {
            throw new Error('Player is already in a room');
        }

        const room = this.rooms.get(roomCode);
        
        if (room.state !== 'waiting') {
            throw new Error('Room is not accepting new players');
        }

        if (room.players.size >= room.maxPlayers) {
            throw new Error('Room is full');
        }

        room.addPlayer(playerId, playerName, dogType);
        this.playerRooms.set(playerId, roomCode);

        console.log(`✅ Player ${playerId} joined room ${roomCode}`);
        return room;
    }

    /**
     * Leave a room
     */
    leaveRoom(playerId) {
        if (!this.playerRooms.has(playerId)) {
            return null; // Player not in any room
        }

        const roomCode = this.playerRooms.get(playerId);
        const room = this.rooms.get(roomCode);
        
        if (!room) {
            this.playerRooms.delete(playerId);
            return null;
        }

        room.removePlayer(playerId);
        this.playerRooms.delete(playerId);

        // Handle host migration or room cleanup
        if (room.hostId === playerId) {
            if (room.players.size > 0) {
                // Migrate host to another player
                const newHostId = Array.from(room.players.keys())[0];
                room.hostId = newHostId;
                console.log(`🔄 Host migrated to ${newHostId} in room ${roomCode}`);
            } else {
                // Room is empty, clean it up
                this.cleanupRoom(roomCode);
                return null;
            }
        }

        console.log(`👋 Player ${playerId} left room ${roomCode}`);
        return room;
    }

    /**
     * Get a room for quick match (public rooms with space)
     */
    findQuickMatchRoom() {
        for (const roomCode of this.publicRooms) {
            const room = this.rooms.get(roomCode);
            if (room && room.state === 'waiting' && room.players.size < room.maxPlayers) {
                return room;
            }
        }
        return null;
    }

    /**
     * Get room by code
     */
    getRoom(roomCode) {
        return this.rooms.get(roomCode?.toUpperCase());
    }

    /**
     * Get room by player ID
     */
    getPlayerRoom(playerId) {
        const roomCode = this.playerRooms.get(playerId);
        return roomCode ? this.rooms.get(roomCode) : null;
    }

    /**
     * Start a game in a room
     */
    startGame(roomCode, hostId) {
        const room = this.getRoom(roomCode);
        
        if (!room) {
            throw new Error('Room not found');
        }

        if (room.hostId !== hostId) {
            throw new Error('Only the host can start the game');
        }

        if (room.players.size < 2) {
            throw new Error('Need at least 2 players to start');
        }

        if (room.state !== 'waiting') {
            throw new Error('Game cannot be started in current room state');
        }

        room.startGame();
        console.log(`🎮 Game started in room ${roomCode} with ${room.players.size} players`);
        return room;
    }

    /**
     * Clean up an empty room
     */
    cleanupRoom(roomCode) {
        const room = this.rooms.get(roomCode);
        if (room) {
            this.rooms.delete(roomCode);
            this.publicRooms.delete(roomCode);
            
            // Clean up any simulation resources
            if (room.simulation) {
                room.simulation.cleanup();
            }
            
            console.log(`🧹 Cleaned up empty room ${roomCode}`);
        }
    }

    /**
     * Get room statistics
     */
    getStats() {
        const totalRooms = this.rooms.size;
        const publicRooms = this.publicRooms.size;
        const totalPlayers = this.playerRooms.size;
        
        let waitingRooms = 0;
        let activeGames = 0;
        let finishedGames = 0;
        
        for (const room of this.rooms.values()) {
            switch (room.state) {
                case 'waiting': waitingRooms++; break;
                case 'in-game': activeGames++; break;
                case 'finished': finishedGames++; break;
            }
        }

        return {
            totalRooms,
            publicRooms,
            totalPlayers,
            waitingRooms,
            activeGames,
            finishedGames
        };
    }

    /**
     * Periodic cleanup of stale rooms
     */
    performMaintenance() {
        const now = Date.now();
        const staleRoomThreshold = 30 * 60 * 1000; // 30 minutes
        
        for (const [roomCode, room] of this.rooms.entries()) {
            if (now - room.lastActivity > staleRoomThreshold) {
                console.log(`🧹 Cleaning up stale room ${roomCode}`);
                this.cleanupRoom(roomCode);
            }
        }
    }
}

/**
 * Individual Room class
 */
export class Room {
    constructor(roomCode, hostId, settings = {}, hostDogType = 'jep') {
        this.roomCode = roomCode;
        this.hostId = hostId;
        this.name = settings.name || 'Sheepdog Game';
        this.maxPlayers = settings.maxPlayers || 4;
        this.isPublic = settings.isPublic || false;
        
        this.players = new Map(); // playerId -> PlayerInfo
        this.state = 'waiting'; // 'waiting', 'in-game', 'finished'
        this.createdAt = Date.now();
        this.lastActivity = Date.now();
        
        // Game simulation will be initialized when game starts
        this.simulation = null;
        
        // Add the host as the first player
        this.addPlayer(hostId, 'Host', hostDogType);
    }

    addPlayer(playerId, playerName = 'Anonymous', dogType = 'jep') {
        const playerInfo = {
            id: playerId,
            name: playerName,
            dogType: dogType, // Store the player's selected dog type
            isHost: playerId === this.hostId,
            isReady: true, // All players are ready by default for testing
            joinedAt: Date.now(),
            // Game-specific data will be added when game starts
            dogPosition: null,
            dogStamina: 100,
            inputSequence: 0
        };
        
        this.players.set(playerId, playerInfo);
        this.lastActivity = Date.now();
        
        return playerInfo;
    }

    removePlayer(playerId) {
        this.players.delete(playerId);
        this.lastActivity = Date.now();
    }

    getPlayer(playerId) {
        return this.players.get(playerId);
    }

    setPlayerReady(playerId, ready = true) {
        const player = this.players.get(playerId);
        if (player) {
            player.isReady = ready;
            this.lastActivity = Date.now();
        }
    }

    areAllPlayersReady() {
        for (const player of this.players.values()) {
            if (!player.isReady) {
                return false;
            }
        }
        return this.players.size >= 2; // Need at least 2 players
    }

    startGame() {
        if (this.state !== 'waiting') {
            throw new Error('Game cannot be started in current state');
        }

        if (!this.areAllPlayersReady()) {
            throw new Error('Not all players are ready');
        }

        this.state = 'in-game';
        this.lastActivity = Date.now();
        
        // Game simulation will be initialized by the server
        this.simulation = null;
        
        return true;
    }

    finishGame() {
        this.state = 'finished';
        this.lastActivity = Date.now();
        
        if (this.simulation) {
            this.simulation.stop();
        }
    }

    getSerializableState() {
        return {
            roomCode: this.roomCode,
            name: this.name,
            hostId: this.hostId,
            maxPlayers: this.maxPlayers,
            isPublic: this.isPublic,
            state: this.state,
            playerCount: this.players.size,
            players: Array.from(this.players.values()).map(p => ({
                id: p.id,
                name: p.name,
                dogType: p.dogType, // Include dog type in serialized state
                isHost: p.isHost,
                isReady: p.isReady
            })),
            createdAt: this.createdAt,
            lastActivity: this.lastActivity
        };
    }
}
```

## server/shared/BoundaryCollision.js

```javascript
import { Vector2D } from './Vector2D.js';

/**
 * Pure boundary and collision detection functions
 * Stateless and deterministic - no external dependencies
 */

/**
 * Calculate boundary avoidance force for standard boundaries
 * @param {Object} entity - Entity with position and velocity
 * @param {Object} bounds - Boundary definition {minX, maxX, minZ, maxZ}
 * @param {Object} config - Boundary configuration
 * @returns {Vector2D} - Boundary avoidance force
 */
export function calculateBoundaryAvoidance(entity, bounds, config = {}) {
    const {
        margin = 10,
        maxSpeed = 1.5,
        maxForce = 0.05,
        forceMultiplier = 1.5
    } = config;
    
    const steer = new Vector2D(0, 0);
    const position = entity.position;
    
    // Calculate distances to boundaries
    const distToMinX = position.x - bounds.minX;
    const distToMaxX = bounds.maxX - position.x;
    const distToMinZ = position.z - bounds.minZ;
    const distToMaxZ = bounds.maxZ - position.z;
    
    // Apply repulsion force based on proximity to boundary
    if (distToMinX < margin) {
        const force = (margin - distToMinX) / margin;
        steer.x = maxSpeed * force * 1.2;
    } else if (distToMaxX < margin) {
        const force = (margin - distToMaxX) / margin;
        steer.x = -maxSpeed * force * 1.2;
    }
    
    if (distToMinZ < margin) {
        const force = (margin - distToMinZ) / margin;
        steer.z = maxSpeed * force * 1.2;
    } else if (distToMaxZ < margin) {
        const force = (margin - distToMaxZ) / margin;
        steer.z = -maxSpeed * force * 1.2;
    }
    
    if (steer.magnitude() > 0) {
        steer.normalize();
        steer.multiply(maxSpeed * forceMultiplier);
        steer.subtract(entity.velocity);
        steer.limit(maxForce * 2.5);
    }
    
    return steer;
}

/**
 * Calculate boundary avoidance force that excludes gate area
 * @param {Object} entity - Entity with position and velocity
 * @param {Object} bounds - Boundary definition
 * @param {Object} gate - Gate definition {position, width}
 * @param {Object} config - Configuration
 * @returns {Vector2D} - Boundary avoidance force
 */
export function calculateBoundaryAvoidanceWithGate(entity, bounds, gate, config = {}) {
    const {
        margin = 3,
        maxSpeed = 0.1,
        maxForce = 0.02
    } = config;
    
    const steer = new Vector2D(0, 0);
    const position = entity.position;
    
    const distToMinX = position.x - bounds.minX;
    const distToMaxX = bounds.maxX - position.x;
    const distToMinZ = position.z - bounds.minZ;
    const distToMaxZ = bounds.maxZ - position.z;
    
    if (distToMinX < margin) {
        const force = (margin - distToMinX) / margin;
        steer.x = maxSpeed * force * 1.2;
    } else if (distToMaxX < margin) {
        const force = (margin - distToMaxX) / margin;
        steer.x = -maxSpeed * force * 1.2;
    }
    
    if (distToMinZ < margin) {
        const force = (margin - distToMinZ) / margin;
        steer.z = maxSpeed * force * 1.2;
    } else if (distToMaxZ < margin) {
        // Only check for gate if gate exists
        const nearGateX = gate ? Math.abs(position.x - gate.position.x) < gate.width / 2 + 2 : false;
        if (!nearGateX) {
            const force = (margin - distToMaxZ) / margin;
            steer.z = -maxSpeed * force * 1.2;
        }
    }
    
    if (steer.magnitude() > 0) {
        steer.normalize();
        steer.multiply(maxSpeed * 1.5);
        steer.subtract(entity.velocity);
        steer.limit(maxForce * 2.5);
    }
    
    return steer;
}

/**
 * Apply hard boundary constraints to entity position
 * @param {Object} entity - Entity with position
 * @param {Object} bounds - Boundary definition
 * @param {Object} gate - Optional gate definition
 * @param {Object} config - Configuration
 * @returns {Vector2D} - Constrained position
 */
export function applyHardBoundaryConstraints(entity, bounds, gate = null, config = {}) {
    const {
        margin = 0.2,
        allowGatePassage = false
    } = config;
    
    const position = entity.position.clone();
    
    // Check if entity is in the gate area
    const inGateArea = allowGatePassage && gate && 
        Math.abs(position.x) <= gate.width / 2 && 
        position.z >= gate.position.z - 2 && 
        position.z <= gate.position.z + 2;
    
    if (!inGateArea) {
        // Apply hard constraints
        position.x = Math.max(bounds.minX + margin, Math.min(bounds.maxX - margin, position.x));
        position.z = Math.max(bounds.minZ + margin, Math.min(bounds.maxZ - margin, position.z));
    } else if (gate) {
        // In gate area - only constrain X to gate width, allow Z movement
        position.x = Math.max(-gate.width / 2, Math.min(gate.width / 2, position.x));
    }
    
    return position;
}

/**
 * Check if entity is within a specific area
 * @param {Vector2D} position - Entity position
 * @param {Object} area - Area definition {minX, maxX, minZ, maxZ}
 * @returns {boolean} - Whether entity is within area
 */
export function isWithinArea(position, area) {
    return position.x >= area.minX && 
           position.x <= area.maxX && 
           position.z >= area.minZ && 
           position.z <= area.maxZ;
}

/**
 * Check if entity has passed through a gate
 * @param {Vector2D} position - Entity position
 * @param {Vector2D} velocity - Entity velocity
 * @param {Object} gatePassageZone - Gate passage zone definition
 * @returns {boolean} - Whether entity has passed through gate
 */
export function checkGatePassage(position, velocity, gatePassageZone) {
    const inGateX = position.x >= gatePassageZone.minX && 
                   position.x <= gatePassageZone.maxX;
    const inGateZ = position.z >= gatePassageZone.minZ && 
                   position.z <= gatePassageZone.maxZ;
    
    // Must be in gate area and moving forward (positive Z direction)
    return inGateX && inGateZ && velocity.z > 0;
}

/**
 * Calculate distance to nearest boundary
 * @param {Vector2D} position - Entity position
 * @param {Object} bounds - Boundary definition
 * @returns {Object} - Distance info {distance, side, isNear}
 */
export function getDistanceToNearestBoundary(position, bounds) {
    const distances = {
        left: position.x - bounds.minX,
        right: bounds.maxX - position.x,
        bottom: position.z - bounds.minZ,
        top: bounds.maxZ - position.z
    };
    
    // Find minimum distance and corresponding side
    let minDistance = Infinity;
    let nearestSide = null;
    
    for (const [side, distance] of Object.entries(distances)) {
        if (distance < minDistance) {
            minDistance = distance;
            nearestSide = side;
        }
    }
    
    return {
        distance: minDistance,
        side: nearestSide,
        isNear: minDistance < 10, // Within warning distance
        distances: distances
    };
}

/**
 * Generate random position within bounds
 * @param {Object} bounds - Boundary definition
 * @param {Object} config - Configuration {margin, exclusionZones}
 * @returns {Vector2D} - Random position within bounds
 */
export function generateRandomPositionInBounds(bounds, config = {}) {
    const {
        margin = 5,
        exclusionZones = [],
        maxAttempts = 50
    } = config;
    
    const availableBounds = {
        minX: bounds.minX + margin,
        maxX: bounds.maxX - margin,
        minZ: bounds.minZ + margin,
        maxZ: bounds.maxZ - margin
    };
    
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
        const x = availableBounds.minX + Math.random() * (availableBounds.maxX - availableBounds.minX);
        const z = availableBounds.minZ + Math.random() * (availableBounds.maxZ - availableBounds.minZ);
        const position = new Vector2D(x, z);
        
        // Check if position is in any exclusion zone
        let inExclusionZone = false;
        for (const zone of exclusionZones) {
            if (isWithinArea(position, zone)) {
                inExclusionZone = true;
                break;
            }
        }
        
        if (!inExclusionZone) {
            return position;
        }
    }
    
    // Fallback to center if no valid position found
    return new Vector2D(
        (availableBounds.minX + availableBounds.maxX) / 2,
        (availableBounds.minZ + availableBounds.maxZ) / 2
    );
}
```

## server/shared/FlockingAlgorithms.js

```javascript
import { Vector2D } from './Vector2D.js';

/**
 * Pure flocking algorithm functions
 * Stateless and deterministic - no external dependencies
 */

/**
 * Apply flocking behavior (separation, alignment, cohesion) to a boid
 * @param {Object} boid - The boid to apply flocking to (with position, velocity)
 * @param {Array} neighbors - Array of neighboring boids
 * @param {Object} config - Flocking configuration
 * @returns {Vector2D} - Combined flocking force
 */
export function calculateFlockingForce(boid, neighbors, config) {
    const {
        separationDistance = 2.0,
        separationWeight = 1.5,
        alignmentWeight = 1.0,
        cohesionWeight = 1.0,
        maxSpeed = 1.5,
        maxForce = 0.05
    } = config;
    
    if (neighbors.length === 0) {
        return new Vector2D(0, 0);
    }
    
    // Calculate individual forces
    const separation = calculateSeparation(boid, neighbors, separationDistance, maxSpeed, maxForce);
    const alignment = calculateAlignment(boid, neighbors, maxSpeed, maxForce);
    const cohesion = calculateCohesion(boid, neighbors, maxSpeed, maxForce);
    
    // Weight and combine forces
    separation.multiply(separationWeight);
    alignment.multiply(alignmentWeight);
    cohesion.multiply(cohesionWeight);
    
    const totalForce = new Vector2D(0, 0);
    totalForce.add(separation);
    totalForce.add(alignment);
    totalForce.add(cohesion);
    
    return totalForce;
}

/**
 * Separation: steer to avoid crowding local flockmates
 * @param {Object} boid - The boid
 * @param {Array} neighbors - Neighboring boids
 * @param {number} desiredSeparation - Desired separation distance
 * @param {number} maxSpeed - Maximum speed
 * @param {number} maxForce - Maximum force
 * @returns {Vector2D} - Separation force
 */
export function calculateSeparation(boid, neighbors, desiredSeparation, maxSpeed, maxForce) {
    const steer = new Vector2D(0, 0);
    let count = 0;

    for (let neighbor of neighbors) {
        const distance = boid.position.distanceTo(neighbor.position);
        
        if (distance > 0 && distance < desiredSeparation) {
            // Calculate vector pointing away from neighbor
            const diff = boid.position.clone().subtract(neighbor.position);
            diff.normalize();
            diff.divide(distance); // Weight by distance (closer = stronger)
            steer.add(diff);
            count++;
        }
    }

    if (count > 0) {
        steer.divide(count);
        steer.normalize();
        steer.multiply(maxSpeed);
        steer.subtract(boid.velocity);
        steer.limit(maxForce);
    }

    return steer;
}

/**
 * Alignment: steer towards the average heading of local flockmates
 * @param {Object} boid - The boid
 * @param {Array} neighbors - Neighboring boids
 * @param {number} maxSpeed - Maximum speed
 * @param {number} maxForce - Maximum force
 * @returns {Vector2D} - Alignment force
 */
export function calculateAlignment(boid, neighbors, maxSpeed, maxForce) {
    const sum = new Vector2D(0, 0);
    
    for (let neighbor of neighbors) {
        sum.add(neighbor.velocity);
    }
    
    sum.divide(neighbors.length);
    sum.normalize();
    sum.multiply(maxSpeed);
    
    const steer = sum.subtract(boid.velocity);
    steer.limit(maxForce);
    
    return steer;
}

/**
 * Cohesion: steer to move toward the average position of local flockmates
 * @param {Object} boid - The boid
 * @param {Array} neighbors - Neighboring boids
 * @param {number} maxSpeed - Maximum speed
 * @param {number} maxForce - Maximum force
 * @returns {Vector2D} - Cohesion force
 */
export function calculateCohesion(boid, neighbors, maxSpeed, maxForce) {
    const sum = new Vector2D(0, 0);
    
    for (let neighbor of neighbors) {
        sum.add(neighbor.position);
    }
    
    sum.divide(neighbors.length);
    return calculateSeek(boid, sum, maxSpeed, maxForce);
}

/**
 * Seek a target position
 * @param {Object} boid - The boid
 * @param {Vector2D} target - Target position
 * @param {number} maxSpeed - Maximum speed
 * @param {number} maxForce - Maximum force
 * @returns {Vector2D} - Seek force
 */
export function calculateSeek(boid, target, maxSpeed, maxForce) {
    const desired = target.clone().subtract(boid.position);
    desired.normalize();
    desired.multiply(maxSpeed);
    
    const steer = desired.subtract(boid.velocity);
    steer.limit(maxForce);
    
    return steer;
}

/**
 * Flee from a target position
 * @param {Object} boid - The boid
 * @param {Vector2D} target - Target position to flee from
 * @param {number} fleeRadius - Radius within which to flee
 * @param {number} maxSpeed - Maximum speed
 * @param {number} maxForce - Maximum force
 * @returns {Vector2D} - Flee force
 */
export function calculateFlee(boid, target, fleeRadius, maxSpeed, maxForce) {
    const distance = boid.position.distanceTo(target);
    
    if (distance < fleeRadius) {
        const desired = boid.position.clone().subtract(target);
        desired.normalize();
        desired.multiply(maxSpeed);
        
        const steer = desired.subtract(boid.velocity);
        steer.limit(maxForce * 2); // Stronger flee force
        
        return steer;
    }
    
    return new Vector2D(0, 0);
}

/**
 * Get neighboring boids within perception radius
 * @param {Object} boid - The boid
 * @param {Array} allBoids - All boids in the system
 * @param {number} perceptionRadius - Perception radius
 * @returns {Array} - Array of neighboring boids
 */
export function getNeighbors(boid, allBoids, perceptionRadius) {
    const neighbors = [];
    
    for (let otherBoid of allBoids) {
        if (otherBoid !== boid) {
            const distance = boid.position.distanceTo(otherBoid.position);
            if (distance < perceptionRadius) {
                neighbors.push(otherBoid);
            }
        }
    }
    
    return neighbors;
}
```

## server/shared/GameStateValidation.js

```javascript
import { Vector2D } from './Vector2D.js';
import { isWithinArea, checkGatePassage } from './BoundaryCollision.js';

/**
 * Pure game state validation functions
 * Stateless and deterministic - no external dependencies
 */

/**
 * Validate and update sheep retirement status
 * @param {Array} sheep - Array of sheep entities
 * @param {Object} gate - Gate configuration
 * @param {Object} pasture - Pasture configuration
 * @returns {Object} - Retirement status {newRetirements, totalRetired}
 */
export function updateSheepRetirements(sheep, gate, pasture) {
    let newRetirements = 0;
    let totalRetired = 0;
    
    for (let sheepEntity of sheep) {
        // Check if sheep just passed through the gate
        if (!sheepEntity.hasPassedGate && !sheepEntity.isRetiring) {
            if (checkGatePassage(sheepEntity.position, sheepEntity.velocity, gate.passageZone)) {
                sheepEntity.hasPassedGate = true;
                sheepEntity.isRetiring = true;
                
                // Set retirement target in pasture
                sheepEntity.retirementTarget = new Vector2D(
                    pasture.minX + Math.random() * (pasture.maxX - pasture.minX),
                    pasture.centerZ + Math.random() * 20
                );
                
                newRetirements++;
            }
        }
        
        // Check if sheep has reached retirement target
        if (sheepEntity.isRetiring && sheepEntity.retirementTarget) {
            const distanceToTarget = sheepEntity.position.distanceTo(sheepEntity.retirementTarget);
            if (distanceToTarget < 2) {
                sheepEntity.retirementTarget = null; // Clear target to enter grazing mode
                sheepEntity.state = 2; // Set to grazing state
            }
        }
        
        // Count all retired sheep
        if (sheepEntity.hasPassedGate || sheepEntity.isRetiring) {
            totalRetired++;
        }
    }
    
    return {
        newRetirements,
        totalRetired
    };
}

/**
 * Check if game completion conditions are met
 * @param {Array} sheep - Array of sheep entities
 * @param {number} totalSheep - Total number of sheep in game
 * @param {boolean} gameActive - Whether game is currently active
 * @returns {Object} - Completion status {isComplete, completionPercentage}
 */
export function checkGameCompletion(sheep, totalSheep, gameActive) {
    if (!gameActive) {
        return {
            isComplete: false,
            completionPercentage: 0
        };
    }
    
    const retiredCount = sheep.filter(s => s.hasPassedGate || s.isRetiring).length;
    const completionPercentage = (retiredCount / totalSheep) * 100;
    const isComplete = retiredCount === totalSheep;
    
    return {
        isComplete,
        completionPercentage
    };
}

/**
 * Validate game state consistency
 * @param {Object} gameState - Current game state
 * @returns {Object} - Validation results {isValid, issues}
 */
export function validateGameState(gameState) {
    const issues = [];
    
    // Check sheep array
    if (!Array.isArray(gameState.sheep)) {
        issues.push('sheep_not_array');
    } else {
        // Validate each sheep
        for (let i = 0; i < gameState.sheep.length; i++) {
            const sheep = gameState.sheep[i];
            
            if (!sheep.position || typeof sheep.position.x !== 'number' || typeof sheep.position.z !== 'number') {
                issues.push(`sheep_${i}_invalid_position`);
            }
            
            if (!sheep.velocity || typeof sheep.velocity.x !== 'number' || typeof sheep.velocity.z !== 'number') {
                issues.push(`sheep_${i}_invalid_velocity`);
            }
            
            if (typeof sheep.hasPassedGate !== 'boolean') {
                issues.push(`sheep_${i}_invalid_gate_status`);
            }
            
            if (typeof sheep.isRetiring !== 'boolean') {
                issues.push(`sheep_${i}_invalid_retirement_status`);
            }
        }
    }
    
    // Check sheepdog
    if (gameState.sheepdog) {
        if (!gameState.sheepdog.position || 
            typeof gameState.sheepdog.position.x !== 'number' || 
            typeof gameState.sheepdog.position.z !== 'number') {
            issues.push('sheepdog_invalid_position');
        }
        
        if (!gameState.sheepdog.velocity ||
            typeof gameState.sheepdog.velocity.x !== 'number' || 
            typeof gameState.sheepdog.velocity.z !== 'number') {
            issues.push('sheepdog_invalid_velocity');
        }
        
        if (typeof gameState.sheepdog.stamina !== 'number' || 
            gameState.sheepdog.stamina < 0 || 
            gameState.sheepdog.stamina > gameState.sheepdog.maxStamina) {
            issues.push('sheepdog_invalid_stamina');
        }
    }
    
    // Check boundaries
    if (!gameState.bounds || 
        typeof gameState.bounds.minX !== 'number' ||
        typeof gameState.bounds.maxX !== 'number' ||
        typeof gameState.bounds.minZ !== 'number' ||
        typeof gameState.bounds.maxZ !== 'number') {
        issues.push('invalid_bounds');
    }
    
    // Check gate
    if (!gameState.gate || 
        !gameState.gate.position ||
        typeof gameState.gate.width !== 'number') {
        issues.push('invalid_gate');
    }
    
    // Check numerical values
    if (typeof gameState.sheepRetired !== 'number' || gameState.sheepRetired < 0) {
        issues.push('invalid_sheep_retired_count');
    }
    
    if (typeof gameState.totalSheep !== 'number' || gameState.totalSheep <= 0) {
        issues.push('invalid_total_sheep_count');
    }
    
    return {
        isValid: issues.length === 0,
        issues
    };
}

/**
 * Calculate game progress metrics
 * @param {Array} sheep - Array of sheep entities
 * @param {number} totalSheep - Total number of sheep
 * @param {Object} pasture - Pasture configuration
 * @returns {Object} - Progress metrics
 */
export function calculateGameProgress(sheep, totalSheep, pasture) {
    let inField = 0;
    let passingGate = 0;
    let inPasture = 0;
    let grazing = 0;
    
    for (let sheepEntity of sheep) {
        if (sheepEntity.state === 2) { // Grazing state
            grazing++;
        } else if (sheepEntity.hasPassedGate || sheepEntity.isRetiring) {
            if (isWithinArea(sheepEntity.position, pasture)) {
                inPasture++;
            } else {
                passingGate++;
            }
        } else {
            inField++;
        }
    }
    
    return {
        inField,
        passingGate,
        inPasture,
        grazing,
        totalRetired: passingGate + inPasture + grazing,
        completionPercentage: ((passingGate + inPasture + grazing) / totalSheep) * 100
    };
}

/**
 * Generate initial sheep positions in a clustered formation
 * @param {number} sheepCount - Number of sheep to position
 * @param {Object} bounds - Field boundaries
 * @param {Object} config - Configuration options
 * @returns {Array} - Array of initial positions
 */
export function generateInitialSheepPositions(sheepCount, bounds, config = {}) {
    const {
        spreadRadius = 30,
        centerX = -30,
        centerZ = -30,
        avoidAreas = []
    } = config;
    
    const positions = [];
    
    for (let i = 0; i < sheepCount; i++) {
        let position;
        let attempts = 0;
        const maxAttempts = 50;
        
        do {
            // Random position in a cluster
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * spreadRadius;
            const x = centerX + Math.cos(angle) * distance;
            const z = centerZ + Math.sin(angle) * distance;
            
            position = new Vector2D(x, z);
            attempts++;
            
            // Check if position is valid (within bounds and not in avoid areas)
            const withinBounds = position.x >= bounds.minX + 5 && 
                                position.x <= bounds.maxX - 5 &&
                                position.z >= bounds.minZ + 5 && 
                                position.z <= bounds.maxZ - 5;
            
            let inAvoidArea = false;
            for (const area of avoidAreas) {
                if (isWithinArea(position, area)) {
                    inAvoidArea = true;
                    break;
                }
            }
            
            if (withinBounds && !inAvoidArea) {
                break;
            }
            
        } while (attempts < maxAttempts);
        
        positions.push(position);
    }
    
    return positions;
}

/**
 * Reset game state to initial conditions
 * @param {Object} gameState - Current game state
 * @param {Array} initialPositions - Initial sheep positions
 * @returns {Object} - Reset game state
 */
export function resetGameState(gameState, initialPositions) {
    // Reset sheep states
    for (let i = 0; i < gameState.sheep.length; i++) {
        const sheep = gameState.sheep[i];
        const initialPos = initialPositions[i] || new Vector2D(-30, -30);
        
        sheep.position = initialPos.clone();
        sheep.velocity = new Vector2D(0, 0);
        sheep.acceleration = new Vector2D(0, 0);
        sheep.hasPassedGate = false;
        sheep.isRetiring = false;
        sheep.retirementTarget = null;
        sheep.state = 0; // Active state
    }
    
    // Reset game counters
    gameState.sheepRetired = 0;
    gameState.gameCompleted = false;
    gameState.gameActive = false;
    
    return gameState;
}

/**
 * Calculate herding effectiveness metrics
 * @param {Object} sheepdog - Sheepdog entity
 * @param {Array} sheep - Array of sheep entities
 * @param {Object} gate - Gate configuration
 * @returns {Object} - Herding effectiveness metrics
 */
export function calculateHerdingEffectiveness(sheepdog, sheep, gate) {
    if (!sheepdog) {
        return {
            sheepInRange: 0,
            sheepFleeing: 0,
            averageDistanceToGate: 0,
            herdingPressure: 0
        };
    }
    
    let sheepInRange = 0;
    let sheepFleeing = 0;
    let totalDistanceToGate = 0;
    
    for (let sheepEntity of sheep) {
        const distanceToSheepdog = sheepEntity.position.distanceTo(sheepdog.position);
        const distanceToGate = sheepEntity.position.distanceTo(gate.position);
        
        if (distanceToSheepdog < 15) { // Within herding range
            sheepInRange++;
        }
        
        if (distanceToSheepdog < sheepEntity.fleeRadius) { // Within flee radius
            sheepFleeing++;
        }
        
        totalDistanceToGate += distanceToGate;
    }
    
    const averageDistanceToGate = totalDistanceToGate / sheep.length;
    const herdingPressure = (sheepFleeing / sheep.length) * 100;
    
    return {
        sheepInRange,
        sheepFleeing,
        averageDistanceToGate,
        herdingPressure
    };
}
```

## server/shared/index.js

```javascript
/**
 * Shared Simulation Logic
 * Pure functions with no dependencies on DOM/Three.js
 * 
 * This module exports all the core simulation algorithms that can be used
 * by both client-side and server-side code for consistent behavior.
 */

// Import Vector2D for use in utility functions
import { Vector2D } from './Vector2D.js';

// Core data structures
export { Vector2D } from './Vector2D.js';

// Flocking behavior algorithms
export {
    calculateFlockingForce,
    calculateSeparation,
    calculateAlignment,
    calculateCohesion,
    calculateSeek,
    calculateFlee,
    getNeighbors
} from './FlockingAlgorithms.js';

// Movement and physics calculations
export {
    updateMovement,
    applyAcceleration,
    updateStamina,
    interpolatePosition,
    interpolateRotation,
    validateEntityState
} from './MovementPhysics.js';

// Boundary and collision detection
export {
    calculateBoundaryAvoidance,
    calculateBoundaryAvoidanceWithGate,
    applyHardBoundaryConstraints,
    isWithinArea,
    checkGatePassage,
    getDistanceToNearestBoundary,
    generateRandomPositionInBounds
} from './BoundaryCollision.js';

// Game state validation and management
export {
    updateSheepRetirements,
    checkGameCompletion,
    validateGameState,
    calculateGameProgress,
    generateInitialSheepPositions,
    resetGameState,
    calculateHerdingEffectiveness
} from './GameStateValidation.js';

/**
 * Utility function to create a standard boid configuration
 * @param {Object} overrides - Configuration overrides
 * @returns {Object} - Boid configuration
 */
export function createBoidConfig(overrides = {}) {
    return {
        maxSpeed: 1.5,
        maxForce: 0.05,
        perceptionRadius: 5,
        separationDistance: 2.0,
        separationWeight: 1.5,
        alignmentWeight: 1.0,
        cohesionWeight: 1.0,
        ...overrides
    };
}

/**
 * Utility function to create a standard movement configuration
 * @param {Object} overrides - Configuration overrides
 * @returns {Object} - Movement configuration
 */
export function createMovementConfig(overrides = {}) {
    return {
        maxSpeed: 1.5,
        dampingFactor: 0.98,
        velocitySmoothing: 0.85,
        minMovementThreshold: 0.001,
        acceleration: 40,
        deceleration: 30,
        ...overrides
    };
}

/**
 * Utility function to create a standard boundary configuration
 * @param {Object} overrides - Configuration overrides
 * @returns {Object} - Boundary configuration
 */
export function createBoundaryConfig(overrides = {}) {
    return {
        margin: 10,
        maxSpeed: 1.5,
        maxForce: 0.05,
        forceMultiplier: 1.5,
        ...overrides
    };
}

/**
 * Utility function to create a standard game state structure
 * @param {Object} config - Game configuration
 * @returns {Object} - Initial game state
 */
export function createGameState(config = {}) {
    const {
        totalSheep = 200,
        bounds = { minX: -100, maxX: 100, minZ: -100, maxZ: 100 },
        gatePosition = { x: 0, z: 100 },
        gateWidth = 8,
        pastureConfig = { centerZ: 115, minX: -30, maxX: 30, minZ: 102, maxZ: 130 }
    } = config;

    return {
        bounds,
        gate: {
            position: new Vector2D(gatePosition.x, gatePosition.z),
            width: gateWidth,
            height: 4,
            passageZone: {
                minX: -gateWidth / 2,
                maxX: gateWidth / 2,
                minZ: gatePosition.z - 2,
                maxZ: gatePosition.z + 2
            }
        },
        pasture: pastureConfig,
        params: {
            speed: 0.1,
            cohesion: 1.0,
            separationDistance: 2.0
        },
        sheep: [],
        sheepdog: null,
        sheepRetired: 0,
        totalSheep,
        gameCompleted: false,
        gameActive: false
    };
}
```

## server/shared/MovementPhysics.js

```javascript
import { Vector2D } from './Vector2D.js';

/**
 * Pure movement and physics calculation functions
 * Stateless and deterministic - no external dependencies
 */

/**
 * Update entity position and velocity based on forces and constraints
 * @param {Object} entity - Entity with position, velocity, acceleration
 * @param {number} deltaTime - Time step
 * @param {Object} config - Movement configuration
 * @returns {Object} - Updated entity state
 */
export function updateMovement(entity, deltaTime = 0.016, config = {}) {
    const {
        maxSpeed = 1.5,
        dampingFactor = 0.98,
        velocitySmoothing = 0.85,
        minMovementThreshold = 0.001
    } = config;
    
    // Store previous velocity for smoothing
    const previousVelocity = entity.velocity.clone();
    
    // Update velocity with acceleration
    entity.velocity.add(entity.acceleration);
    entity.velocity.limit(maxSpeed);
    
    // Apply velocity damping to reduce oscillations
    entity.velocity.multiply(dampingFactor);
    
    // Smooth velocity with previous velocity to reduce jittering
    const smoothedVelocity = previousVelocity
        .multiply(velocitySmoothing)
        .add(entity.velocity.clone().multiply(1 - velocitySmoothing));
    
    // Only apply movement if above threshold to prevent micro-movements
    if (smoothedVelocity.magnitude() > minMovementThreshold) {
        entity.velocity = smoothedVelocity;
        entity.position.add(entity.velocity);
    } else {
        // Stop micro-movements
        entity.velocity.multiply(0);
    }
    
    // Reset acceleration for next frame
    entity.acceleration.multiply(0);
    
    return {
        position: entity.position.clone(),
        velocity: entity.velocity.clone(),
        speed: entity.velocity.magnitude(),
        facingDirection: entity.velocity.magnitude() > minMovementThreshold ? entity.velocity.angle() : null
    };
}

/**
 * Apply smooth acceleration/deceleration to an entity
 * @param {Object} entity - Entity with velocity
 * @param {Vector2D} targetVelocity - Desired velocity
 * @param {number} deltaTime - Time step
 * @param {Object} config - Acceleration configuration
 * @returns {Vector2D} - Updated velocity
 */
export function applyAcceleration(entity, targetVelocity, deltaTime, config = {}) {
    const {
        acceleration = 40,
        deceleration = 30,
        maxSpeed = 15
    } = config;
    
    // Determine if we're accelerating or decelerating
    const isAccelerating = targetVelocity.magnitude() > 0;
    const accelerationRate = isAccelerating ? acceleration : deceleration;
    
    // Calculate velocity change
    const velocityDiff = targetVelocity.clone().subtract(entity.velocity);
    const velocityChange = velocityDiff.clone().multiply(accelerationRate * deltaTime);
    
    // Apply velocity change
    entity.velocity.add(velocityChange);
    
    // Limit to max speed
    if (entity.velocity.magnitude() > maxSpeed) {
        entity.velocity.normalize().multiply(maxSpeed);
    }
    
    return entity.velocity.clone();
}

/**
 * Update stamina based on activity
 * @param {Object} entity - Entity with stamina properties
 * @param {boolean} isConsuming - Whether stamina is being consumed
 * @param {number} deltaTime - Time step
 * @param {Object} config - Stamina configuration
 * @returns {Object} - Updated stamina info
 */
export function updateStamina(entity, isConsuming, deltaTime, config = {}) {
    const {
        maxStamina = 100,
        drainRate = 30,
        regenRate = 20,
        minStaminaToConsume = 10
    } = config;
    
    const isMoving = entity.velocity && entity.velocity.magnitude() > 0.1;
    
    if (isConsuming && isMoving && entity.stamina >= minStaminaToConsume) {
        // Drain stamina
        entity.stamina = Math.max(0, entity.stamina - drainRate * deltaTime);
    } else {
        // Regenerate stamina - faster when idle
        const currentRegenRate = isMoving ? regenRate : regenRate * 2;
        entity.stamina = Math.min(maxStamina, entity.stamina + currentRegenRate * deltaTime);
    }
    
    // Force stop consuming if stamina is depleted
    const canConsume = entity.stamina >= minStaminaToConsume;
    
    return {
        current: entity.stamina,
        max: maxStamina,
        percentage: (entity.stamina / maxStamina) * 100,
        canConsume: canConsume,
        isConsuming: isConsuming && canConsume
    };
}

/**
 * Calculate interpolated position for smooth rendering
 * @param {Vector2D} currentPosition - Current physics position
 * @param {Vector2D} renderPosition - Current render position
 * @param {number} deltaTime - Time step
 * @param {number} interpolationSpeed - Speed of interpolation
 * @returns {Vector2D} - New interpolated render position
 */
export function interpolatePosition(currentPosition, renderPosition, deltaTime, interpolationSpeed = 8.0) {
    const positionDiff = currentPosition.clone().subtract(renderPosition);
    const interpolationAmount = Math.min(1.0, interpolationSpeed * deltaTime);
    
    return renderPosition.clone().add(positionDiff.multiply(interpolationAmount));
}

/**
 * Calculate interpolated rotation for smooth rendering
 * @param {number} targetRotation - Target rotation in radians
 * @param {number} currentRotation - Current render rotation
 * @param {number} deltaTime - Time step
 * @param {number} rotationSpeed - Speed of rotation interpolation
 * @returns {number} - New interpolated rotation
 */
export function interpolateRotation(targetRotation, currentRotation, deltaTime, rotationSpeed = 12.0) {
    // Handle angle wrapping for smooth rotation
    let angleDiff = targetRotation - currentRotation;
    
    // Normalize angle difference to [-π, π]
    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
    
    // Apply rotation interpolation
    const rotationInterpolationAmount = Math.min(1.0, rotationSpeed * deltaTime);
    let newRotation = currentRotation + angleDiff * rotationInterpolationAmount;
    
    // Normalize final angle
    while (newRotation > Math.PI) newRotation -= 2 * Math.PI;
    while (newRotation < -Math.PI) newRotation += 2 * Math.PI;
    
    return newRotation;
}

/**
 * Validate and clamp entity values to prevent NaN/Infinity
 * @param {Object} entity - Entity to validate
 * @param {Vector2D} fallbackPosition - Safe fallback position
 * @returns {Object} - Validation results
 */
export function validateEntityState(entity, fallbackPosition = new Vector2D(0, 0)) {
    const issues = [];
    
    // Check velocity
    if (isNaN(entity.velocity.x) || isNaN(entity.velocity.z) || 
        !isFinite(entity.velocity.x) || !isFinite(entity.velocity.z)) {
        entity.velocity.set(0, 0);
        issues.push('velocity_nan');
    }
    
    // Check position
    if (isNaN(entity.position.x) || isNaN(entity.position.z) ||
        !isFinite(entity.position.x) || !isFinite(entity.position.z)) {
        entity.position = fallbackPosition.clone();
        entity.velocity.set(0, 0);
        issues.push('position_nan');
    }
    
    // Check acceleration if present
    if (entity.acceleration) {
        if (isNaN(entity.acceleration.x) || isNaN(entity.acceleration.z) ||
            !isFinite(entity.acceleration.x) || !isFinite(entity.acceleration.z)) {
            entity.acceleration.set(0, 0);
            issues.push('acceleration_nan');
        }
    }
    
    return {
        isValid: issues.length === 0,
        issues: issues
    };
}
```

## server/shared/test.js

```javascript
/**
 * Simple test suite for shared simulation logic
 * Run with: node shared/test.js
 */

import { 
    Vector2D,
    calculateFlockingForce,
    updateMovement,
    calculateBoundaryAvoidance,
    validateGameState,
    createBoidConfig,
    createGameState 
} from './index.js';

console.log('🧪 Testing Shared Simulation Logic...\n');

// Test 1: Vector2D
console.log('1. Testing Vector2D...');
const v1 = new Vector2D(3, 4);
const v2 = new Vector2D(1, 1);
console.log(`   Original: (${v1.x}, ${v1.z})`);
console.log(`   Magnitude: ${v1.magnitude()}`); // Should be 5
console.log(`   After adding (1,1): (${v1.add(v2).x}, ${v1.z})`); // Should be (4, 5)
console.log('   ✅ Vector2D working\n');

// Test 2: Flocking algorithms
console.log('2. Testing Flocking Algorithms...');
const boid = {
    position: new Vector2D(0, 0),
    velocity: new Vector2D(1, 0)
};
const neighbors = [
    { position: new Vector2D(2, 0), velocity: new Vector2D(0, 1) },
    { position: new Vector2D(-1, 1), velocity: new Vector2D(1, 1) }
];
const flockingConfig = createBoidConfig();
const flockingForce = calculateFlockingForce(boid, neighbors, flockingConfig);
console.log(`   Flocking force: (${flockingForce.x.toFixed(3)}, ${flockingForce.z.toFixed(3)})`);
console.log('   ✅ Flocking algorithms working\n');

// Test 3: Movement physics
console.log('3. Testing Movement Physics...');
const entity = {
    position: new Vector2D(0, 0),
    velocity: new Vector2D(0.5, 0.5),
    acceleration: new Vector2D(0.1, 0.1)
};
const movementResult = updateMovement(entity, 0.016);
console.log(`   New position: (${movementResult.position.x.toFixed(3)}, ${movementResult.position.z.toFixed(3)})`);
console.log(`   Speed: ${movementResult.speed.toFixed(3)}`);
console.log('   ✅ Movement physics working\n');

// Test 4: Boundary collision
console.log('4. Testing Boundary Collision...');
const boundaryEntity = {
    position: new Vector2D(95, 0), // Near right boundary
    velocity: new Vector2D(1, 0)
};
const bounds = { minX: -100, maxX: 100, minZ: -100, maxZ: 100 };
const boundaryForce = calculateBoundaryAvoidance(boundaryEntity, bounds);
console.log(`   Boundary avoidance force: (${boundaryForce.x.toFixed(3)}, ${boundaryForce.z.toFixed(3)})`);
console.log('   ✅ Boundary collision working\n');

// Test 5: Game state validation
console.log('5. Testing Game State Validation...');
const gameState = createGameState();
gameState.sheep = [
    { position: new Vector2D(0, 0), velocity: new Vector2D(0, 0), hasPassedGate: false, isRetiring: false }
];
gameState.sheepdog = { 
    position: new Vector2D(10, 10), 
    velocity: new Vector2D(0, 0), 
    stamina: 50, 
    maxStamina: 100 
};
const validation = validateGameState(gameState);
console.log(`   Game state valid: ${validation.isValid}`);
console.log(`   Issues: ${validation.issues.length > 0 ? validation.issues.join(', ') : 'None'}`);
console.log('   ✅ Game state validation working\n');

console.log('🎉 All tests passed! Shared simulation logic is working correctly.\n');

console.log('📁 Shared modules created:');
console.log('   • Vector2D.js - Core 2D vector math');
console.log('   • FlockingAlgorithms.js - Separation, alignment, cohesion');
console.log('   • MovementPhysics.js - Movement, acceleration, stamina, interpolation');
console.log('   • BoundaryCollision.js - Boundary avoidance and collision detection');
console.log('   • GameStateValidation.js - Game state management and validation');
console.log('   • index.js - Main export module with utility functions\n');

console.log('✨ Ready for Phase 1.4: Build multiplayer server!');
```

## server/shared/Vector2D.js

```javascript
/**
 * Simple 2D Vector class for XZ plane calculations
 * Pure function implementation with no external dependencies
 */
export class Vector2D {
    constructor(x = 0, z = 0) {
        this.x = x;
        this.z = z;
    }

    // Set the x and z components
    set(x, z) {
        this.x = x;
        this.z = z;
        return this;
    }

    // Add another vector to this one
    add(vector) {
        this.x += vector.x;
        this.z += vector.z;
        return this;
    }

    // Subtract another vector from this one
    subtract(vector) {
        this.x -= vector.x;
        this.z -= vector.z;
        return this;
    }

    // Multiply by a scalar
    multiply(scalar) {
        this.x *= scalar;
        this.z *= scalar;
        return this;
    }

    // Divide by a scalar
    divide(scalar) {
        if (scalar !== 0) {
            this.x /= scalar;
            this.z /= scalar;
        }
        return this;
    }

    // Get the magnitude (length) of the vector
    magnitude() {
        return Math.sqrt(this.x * this.x + this.z * this.z);
    }

    // Normalize the vector (make it unit length)
    normalize() {
        const len = this.magnitude();
        if (len > 0.00001) { // Use a small epsilon to prevent division by zero/tiny number
            this.x /= len;
            this.z /= len;
        } else {
            this.x = 0;
            this.z = 0;
        }
        return this;
    }

    // Limit the magnitude of the vector
    limit(max) {
        const len = this.magnitude();
        if (len > max && len > 0.00001) { // Only normalize if magnitude is significant and over max
            this.normalize();
            this.multiply(max);
        }
        return this;
    }

    // Get distance to another vector
    distanceTo(vector) {
        const dx = this.x - vector.x;
        const dz = this.z - vector.z;
        return Math.sqrt(dx * dx + dz * dz);
    }

    // Get the angle of the vector in radians
    angle() {
        return Math.atan2(this.z, this.x);
    }

    // Set the magnitude of the vector
    setMagnitude(magnitude) {
        this.normalize();
        this.multiply(magnitude);
        return this;
    }

    // Create a copy of this vector
    clone() {
        return new Vector2D(this.x, this.z);
    }

    // Static method to create a vector from an angle
    static fromAngle(angle) {
        return new Vector2D(Math.cos(angle), Math.sin(angle));
    }

    // Static method to get a random unit vector
    static random() {
        const angle = Math.random() * Math.PI * 2;
        return Vector2D.fromAngle(angle);
    }
}
```

## shared/BoundaryCollision.js

```javascript
import { Vector2D } from './Vector2D.js';

/**
 * Pure boundary and collision detection functions
 * Stateless and deterministic - no external dependencies
 */

/**
 * Calculate boundary avoidance force for standard boundaries
 * @param {Object} entity - Entity with position and velocity
 * @param {Object} bounds - Boundary definition {minX, maxX, minZ, maxZ}
 * @param {Object} config - Boundary configuration
 * @returns {Vector2D} - Boundary avoidance force
 */
export function calculateBoundaryAvoidance(entity, bounds, config = {}) {
    const {
        margin = 10,
        maxSpeed = 1.5,
        maxForce = 0.05,
        forceMultiplier = 1.5
    } = config;
    
    const steer = new Vector2D(0, 0);
    const position = entity.position;
    
    // Calculate distances to boundaries
    const distToMinX = position.x - bounds.minX;
    const distToMaxX = bounds.maxX - position.x;
    const distToMinZ = position.z - bounds.minZ;
    const distToMaxZ = bounds.maxZ - position.z;
    
    // Apply repulsion force based on proximity to boundary
    if (distToMinX < margin) {
        const force = (margin - distToMinX) / margin;
        steer.x = maxSpeed * force * 1.2;
    } else if (distToMaxX < margin) {
        const force = (margin - distToMaxX) / margin;
        steer.x = -maxSpeed * force * 1.2;
    }
    
    if (distToMinZ < margin) {
        const force = (margin - distToMinZ) / margin;
        steer.z = maxSpeed * force * 1.2;
    } else if (distToMaxZ < margin) {
        const force = (margin - distToMaxZ) / margin;
        steer.z = -maxSpeed * force * 1.2;
    }
    
    if (steer.magnitude() > 0) {
        steer.normalize();
        steer.multiply(maxSpeed * forceMultiplier);
        steer.subtract(entity.velocity);
        steer.limit(maxForce * 2.5);
    }
    
    return steer;
}

/**
 * Calculate boundary avoidance force that excludes gate area
 * @param {Object} entity - Entity with position and velocity
 * @param {Object} bounds - Boundary definition
 * @param {Object} gate - Gate definition {position, width}
 * @param {Object} config - Configuration
 * @returns {Vector2D} - Boundary avoidance force
 */
export function calculateBoundaryAvoidanceWithGate(entity, bounds, gate, config = {}) {
    const {
        margin = 3,
        maxSpeed = 0.1,
        maxForce = 0.02
    } = config;
    
    const steer = new Vector2D(0, 0);
    const position = entity.position;
    
    const distToMinX = position.x - bounds.minX;
    const distToMaxX = bounds.maxX - position.x;
    const distToMinZ = position.z - bounds.minZ;
    const distToMaxZ = bounds.maxZ - position.z;
    
    if (distToMinX < margin) {
        const force = (margin - distToMinX) / margin;
        steer.x = maxSpeed * force * 1.2;
    } else if (distToMaxX < margin) {
        const force = (margin - distToMaxX) / margin;
        steer.x = -maxSpeed * force * 1.2;
    }
    
    if (distToMinZ < margin) {
        const force = (margin - distToMinZ) / margin;
        steer.z = maxSpeed * force * 1.2;
    } else if (distToMaxZ < margin) {
        // Only check for gate if gate exists
        const nearGateX = gate ? Math.abs(position.x - gate.position.x) < gate.width / 2 + 2 : false;
        if (!nearGateX) {
            const force = (margin - distToMaxZ) / margin;
            steer.z = -maxSpeed * force * 1.2;
        }
    }
    
    if (steer.magnitude() > 0) {
        steer.normalize();
        steer.multiply(maxSpeed * 1.5);
        steer.subtract(entity.velocity);
        steer.limit(maxForce * 2.5);
    }
    
    return steer;
}

/**
 * Apply hard boundary constraints to entity position
 * @param {Object} entity - Entity with position
 * @param {Object} bounds - Boundary definition
 * @param {Object} gate - Optional gate definition
 * @param {Object} config - Configuration
 * @returns {Vector2D} - Constrained position
 */
export function applyHardBoundaryConstraints(entity, bounds, gate = null, config = {}) {
    const {
        margin = 0.2,
        allowGatePassage = false
    } = config;
    
    const position = entity.position.clone();
    
    // Check if entity is in the gate area
    const inGateArea = allowGatePassage && gate && 
        Math.abs(position.x) <= gate.width / 2 && 
        position.z >= gate.position.z - 2 && 
        position.z <= gate.position.z + 2;
    
    if (!inGateArea) {
        // Apply hard constraints
        position.x = Math.max(bounds.minX + margin, Math.min(bounds.maxX - margin, position.x));
        position.z = Math.max(bounds.minZ + margin, Math.min(bounds.maxZ - margin, position.z));
    } else if (gate) {
        // In gate area - only constrain X to gate width, allow Z movement
        position.x = Math.max(-gate.width / 2, Math.min(gate.width / 2, position.x));
    }
    
    return position;
}

/**
 * Check if entity is within a specific area
 * @param {Vector2D} position - Entity position
 * @param {Object} area - Area definition {minX, maxX, minZ, maxZ}
 * @returns {boolean} - Whether entity is within area
 */
export function isWithinArea(position, area) {
    return position.x >= area.minX && 
           position.x <= area.maxX && 
           position.z >= area.minZ && 
           position.z <= area.maxZ;
}

/**
 * Check if entity has passed through a gate
 * @param {Vector2D} position - Entity position
 * @param {Vector2D} velocity - Entity velocity
 * @param {Object} gatePassageZone - Gate passage zone definition
 * @returns {boolean} - Whether entity has passed through gate
 */
export function checkGatePassage(position, velocity, gatePassageZone) {
    const inGateX = position.x >= gatePassageZone.minX && 
                   position.x <= gatePassageZone.maxX;
    const inGateZ = position.z >= gatePassageZone.minZ && 
                   position.z <= gatePassageZone.maxZ;
    
    // Must be in gate area and moving forward (positive Z direction)
    return inGateX && inGateZ && velocity.z > 0;
}

/**
 * Calculate distance to nearest boundary
 * @param {Vector2D} position - Entity position
 * @param {Object} bounds - Boundary definition
 * @returns {Object} - Distance info {distance, side, isNear}
 */
export function getDistanceToNearestBoundary(position, bounds) {
    const distances = {
        left: position.x - bounds.minX,
        right: bounds.maxX - position.x,
        bottom: position.z - bounds.minZ,
        top: bounds.maxZ - position.z
    };
    
    // Find minimum distance and corresponding side
    let minDistance = Infinity;
    let nearestSide = null;
    
    for (const [side, distance] of Object.entries(distances)) {
        if (distance < minDistance) {
            minDistance = distance;
            nearestSide = side;
        }
    }
    
    return {
        distance: minDistance,
        side: nearestSide,
        isNear: minDistance < 10, // Within warning distance
        distances: distances
    };
}

/**
 * Generate random position within bounds
 * @param {Object} bounds - Boundary definition
 * @param {Object} config - Configuration {margin, exclusionZones}
 * @returns {Vector2D} - Random position within bounds
 */
export function generateRandomPositionInBounds(bounds, config = {}) {
    const {
        margin = 5,
        exclusionZones = [],
        maxAttempts = 50
    } = config;
    
    const availableBounds = {
        minX: bounds.minX + margin,
        maxX: bounds.maxX - margin,
        minZ: bounds.minZ + margin,
        maxZ: bounds.maxZ - margin
    };
    
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
        const x = availableBounds.minX + Math.random() * (availableBounds.maxX - availableBounds.minX);
        const z = availableBounds.minZ + Math.random() * (availableBounds.maxZ - availableBounds.minZ);
        const position = new Vector2D(x, z);
        
        // Check if position is in any exclusion zone
        let inExclusionZone = false;
        for (const zone of exclusionZones) {
            if (isWithinArea(position, zone)) {
                inExclusionZone = true;
                break;
            }
        }
        
        if (!inExclusionZone) {
            return position;
        }
    }
    
    // Fallback to center if no valid position found
    return new Vector2D(
        (availableBounds.minX + availableBounds.maxX) / 2,
        (availableBounds.minZ + availableBounds.maxZ) / 2
    );
}
```

## shared/FlockingAlgorithms.js

```javascript
import { Vector2D } from './Vector2D.js';

/**
 * Pure flocking algorithm functions
 * Stateless and deterministic - no external dependencies
 */

/**
 * Apply flocking behavior (separation, alignment, cohesion) to a boid
 * @param {Object} boid - The boid to apply flocking to (with position, velocity)
 * @param {Array} neighbors - Array of neighboring boids
 * @param {Object} config - Flocking configuration
 * @returns {Vector2D} - Combined flocking force
 */
export function calculateFlockingForce(boid, neighbors, config) {
    const {
        separationDistance = 2.0,
        separationWeight = 1.5,
        alignmentWeight = 1.0,
        cohesionWeight = 1.0,
        maxSpeed = 1.5,
        maxForce = 0.05
    } = config;
    
    if (neighbors.length === 0) {
        return new Vector2D(0, 0);
    }
    
    // Calculate individual forces
    const separation = calculateSeparation(boid, neighbors, separationDistance, maxSpeed, maxForce);
    const alignment = calculateAlignment(boid, neighbors, maxSpeed, maxForce);
    const cohesion = calculateCohesion(boid, neighbors, maxSpeed, maxForce);
    
    // Weight and combine forces
    separation.multiply(separationWeight);
    alignment.multiply(alignmentWeight);
    cohesion.multiply(cohesionWeight);
    
    const totalForce = new Vector2D(0, 0);
    totalForce.add(separation);
    totalForce.add(alignment);
    totalForce.add(cohesion);
    
    return totalForce;
}

/**
 * Separation: steer to avoid crowding local flockmates
 * @param {Object} boid - The boid
 * @param {Array} neighbors - Neighboring boids
 * @param {number} desiredSeparation - Desired separation distance
 * @param {number} maxSpeed - Maximum speed
 * @param {number} maxForce - Maximum force
 * @returns {Vector2D} - Separation force
 */
export function calculateSeparation(boid, neighbors, desiredSeparation, maxSpeed, maxForce) {
    const steer = new Vector2D(0, 0);
    let count = 0;

    for (let neighbor of neighbors) {
        const distance = boid.position.distanceTo(neighbor.position);
        
        if (distance > 0 && distance < desiredSeparation) {
            // Calculate vector pointing away from neighbor
            const diff = boid.position.clone().subtract(neighbor.position);
            diff.normalize();
            diff.divide(distance); // Weight by distance (closer = stronger)
            steer.add(diff);
            count++;
        }
    }

    if (count > 0) {
        steer.divide(count);
        steer.normalize();
        steer.multiply(maxSpeed);
        steer.subtract(boid.velocity);
        steer.limit(maxForce);
    }

    return steer;
}

/**
 * Alignment: steer towards the average heading of local flockmates
 * @param {Object} boid - The boid
 * @param {Array} neighbors - Neighboring boids
 * @param {number} maxSpeed - Maximum speed
 * @param {number} maxForce - Maximum force
 * @returns {Vector2D} - Alignment force
 */
export function calculateAlignment(boid, neighbors, maxSpeed, maxForce) {
    const sum = new Vector2D(0, 0);
    
    for (let neighbor of neighbors) {
        sum.add(neighbor.velocity);
    }
    
    sum.divide(neighbors.length);
    sum.normalize();
    sum.multiply(maxSpeed);
    
    const steer = sum.subtract(boid.velocity);
    steer.limit(maxForce);
    
    return steer;
}

/**
 * Cohesion: steer to move toward the average position of local flockmates
 * @param {Object} boid - The boid
 * @param {Array} neighbors - Neighboring boids
 * @param {number} maxSpeed - Maximum speed
 * @param {number} maxForce - Maximum force
 * @returns {Vector2D} - Cohesion force
 */
export function calculateCohesion(boid, neighbors, maxSpeed, maxForce) {
    const sum = new Vector2D(0, 0);
    
    for (let neighbor of neighbors) {
        sum.add(neighbor.position);
    }
    
    sum.divide(neighbors.length);
    return calculateSeek(boid, sum, maxSpeed, maxForce);
}

/**
 * Seek a target position
 * @param {Object} boid - The boid
 * @param {Vector2D} target - Target position
 * @param {number} maxSpeed - Maximum speed
 * @param {number} maxForce - Maximum force
 * @returns {Vector2D} - Seek force
 */
export function calculateSeek(boid, target, maxSpeed, maxForce) {
    const desired = target.clone().subtract(boid.position);
    desired.normalize();
    desired.multiply(maxSpeed);
    
    const steer = desired.subtract(boid.velocity);
    steer.limit(maxForce);
    
    return steer;
}

/**
 * Flee from a target position
 * @param {Object} boid - The boid
 * @param {Vector2D} target - Target position to flee from
 * @param {number} fleeRadius - Radius within which to flee
 * @param {number} maxSpeed - Maximum speed
 * @param {number} maxForce - Maximum force
 * @returns {Vector2D} - Flee force
 */
export function calculateFlee(boid, target, fleeRadius, maxSpeed, maxForce) {
    const distance = boid.position.distanceTo(target);
    
    if (distance < fleeRadius) {
        const desired = boid.position.clone().subtract(target);
        desired.normalize();
        desired.multiply(maxSpeed);
        
        const steer = desired.subtract(boid.velocity);
        steer.limit(maxForce * 2); // Stronger flee force
        
        return steer;
    }
    
    return new Vector2D(0, 0);
}

/**
 * Get neighboring boids within perception radius
 * @param {Object} boid - The boid
 * @param {Array} allBoids - All boids in the system
 * @param {number} perceptionRadius - Perception radius
 * @returns {Array} - Array of neighboring boids
 */
export function getNeighbors(boid, allBoids, perceptionRadius) {
    const neighbors = [];
    
    for (let otherBoid of allBoids) {
        if (otherBoid !== boid) {
            const distance = boid.position.distanceTo(otherBoid.position);
            if (distance < perceptionRadius) {
                neighbors.push(otherBoid);
            }
        }
    }
    
    return neighbors;
}
```

## shared/GameStateValidation.js

```javascript
import { Vector2D } from './Vector2D.js';
import { isWithinArea, checkGatePassage } from './BoundaryCollision.js';

/**
 * Pure game state validation functions
 * Stateless and deterministic - no external dependencies
 */

/**
 * Validate and update sheep retirement status
 * @param {Array} sheep - Array of sheep entities
 * @param {Object} gate - Gate configuration
 * @param {Object} pasture - Pasture configuration
 * @returns {Object} - Retirement status {newRetirements, totalRetired}
 */
export function updateSheepRetirements(sheep, gate, pasture) {
    let newRetirements = 0;
    let totalRetired = 0;
    
    for (let sheepEntity of sheep) {
        // Check if sheep just passed through the gate
        if (!sheepEntity.hasPassedGate && !sheepEntity.isRetiring) {
            if (checkGatePassage(sheepEntity.position, sheepEntity.velocity, gate.passageZone)) {
                sheepEntity.hasPassedGate = true;
                sheepEntity.isRetiring = true;
                
                // Set retirement target in pasture
                sheepEntity.retirementTarget = new Vector2D(
                    pasture.minX + Math.random() * (pasture.maxX - pasture.minX),
                    pasture.centerZ + Math.random() * 20
                );
                
                newRetirements++;
            }
        }
        
        // Check if sheep has reached retirement target
        if (sheepEntity.isRetiring && sheepEntity.retirementTarget) {
            const distanceToTarget = sheepEntity.position.distanceTo(sheepEntity.retirementTarget);
            if (distanceToTarget < 2) {
                sheepEntity.retirementTarget = null; // Clear target to enter grazing mode
                sheepEntity.state = 2; // Set to grazing state
            }
        }
        
        // Count all retired sheep
        if (sheepEntity.hasPassedGate || sheepEntity.isRetiring) {
            totalRetired++;
        }
    }
    
    return {
        newRetirements,
        totalRetired
    };
}

/**
 * Check if game completion conditions are met
 * @param {Array} sheep - Array of sheep entities
 * @param {number} totalSheep - Total number of sheep in game
 * @param {boolean} gameActive - Whether game is currently active
 * @returns {Object} - Completion status {isComplete, completionPercentage}
 */
export function checkGameCompletion(sheep, totalSheep, gameActive) {
    if (!gameActive) {
        return {
            isComplete: false,
            completionPercentage: 0
        };
    }
    
    const retiredCount = sheep.filter(s => s.hasPassedGate || s.isRetiring).length;
    const completionPercentage = (retiredCount / totalSheep) * 100;
    const isComplete = retiredCount === totalSheep;
    
    return {
        isComplete,
        completionPercentage
    };
}

/**
 * Validate game state consistency
 * @param {Object} gameState - Current game state
 * @returns {Object} - Validation results {isValid, issues}
 */
export function validateGameState(gameState) {
    const issues = [];
    
    // Check sheep array
    if (!Array.isArray(gameState.sheep)) {
        issues.push('sheep_not_array');
    } else {
        // Validate each sheep
        for (let i = 0; i < gameState.sheep.length; i++) {
            const sheep = gameState.sheep[i];
            
            if (!sheep.position || typeof sheep.position.x !== 'number' || typeof sheep.position.z !== 'number') {
                issues.push(`sheep_${i}_invalid_position`);
            }
            
            if (!sheep.velocity || typeof sheep.velocity.x !== 'number' || typeof sheep.velocity.z !== 'number') {
                issues.push(`sheep_${i}_invalid_velocity`);
            }
            
            if (typeof sheep.hasPassedGate !== 'boolean') {
                issues.push(`sheep_${i}_invalid_gate_status`);
            }
            
            if (typeof sheep.isRetiring !== 'boolean') {
                issues.push(`sheep_${i}_invalid_retirement_status`);
            }
        }
    }
    
    // Check sheepdog
    if (gameState.sheepdog) {
        if (!gameState.sheepdog.position || 
            typeof gameState.sheepdog.position.x !== 'number' || 
            typeof gameState.sheepdog.position.z !== 'number') {
            issues.push('sheepdog_invalid_position');
        }
        
        if (!gameState.sheepdog.velocity ||
            typeof gameState.sheepdog.velocity.x !== 'number' || 
            typeof gameState.sheepdog.velocity.z !== 'number') {
            issues.push('sheepdog_invalid_velocity');
        }
        
        if (typeof gameState.sheepdog.stamina !== 'number' || 
            gameState.sheepdog.stamina < 0 || 
            gameState.sheepdog.stamina > gameState.sheepdog.maxStamina) {
            issues.push('sheepdog_invalid_stamina');
        }
    }
    
    // Check boundaries
    if (!gameState.bounds || 
        typeof gameState.bounds.minX !== 'number' ||
        typeof gameState.bounds.maxX !== 'number' ||
        typeof gameState.bounds.minZ !== 'number' ||
        typeof gameState.bounds.maxZ !== 'number') {
        issues.push('invalid_bounds');
    }
    
    // Check gate
    if (!gameState.gate || 
        !gameState.gate.position ||
        typeof gameState.gate.width !== 'number') {
        issues.push('invalid_gate');
    }
    
    // Check numerical values
    if (typeof gameState.sheepRetired !== 'number' || gameState.sheepRetired < 0) {
        issues.push('invalid_sheep_retired_count');
    }
    
    if (typeof gameState.totalSheep !== 'number' || gameState.totalSheep <= 0) {
        issues.push('invalid_total_sheep_count');
    }
    
    return {
        isValid: issues.length === 0,
        issues
    };
}

/**
 * Calculate game progress metrics
 * @param {Array} sheep - Array of sheep entities
 * @param {number} totalSheep - Total number of sheep
 * @param {Object} pasture - Pasture configuration
 * @returns {Object} - Progress metrics
 */
export function calculateGameProgress(sheep, totalSheep, pasture) {
    let inField = 0;
    let passingGate = 0;
    let inPasture = 0;
    let grazing = 0;
    
    for (let sheepEntity of sheep) {
        if (sheepEntity.state === 2) { // Grazing state
            grazing++;
        } else if (sheepEntity.hasPassedGate || sheepEntity.isRetiring) {
            if (isWithinArea(sheepEntity.position, pasture)) {
                inPasture++;
            } else {
                passingGate++;
            }
        } else {
            inField++;
        }
    }
    
    return {
        inField,
        passingGate,
        inPasture,
        grazing,
        totalRetired: passingGate + inPasture + grazing,
        completionPercentage: ((passingGate + inPasture + grazing) / totalSheep) * 100
    };
}

/**
 * Generate initial sheep positions in a clustered formation
 * @param {number} sheepCount - Number of sheep to position
 * @param {Object} bounds - Field boundaries
 * @param {Object} config - Configuration options
 * @returns {Array} - Array of initial positions
 */
export function generateInitialSheepPositions(sheepCount, bounds, config = {}) {
    const {
        spreadRadius = 30,
        centerX = -30,
        centerZ = -30,
        avoidAreas = []
    } = config;
    
    const positions = [];
    
    for (let i = 0; i < sheepCount; i++) {
        let position;
        let attempts = 0;
        const maxAttempts = 50;
        
        do {
            // Random position in a cluster
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * spreadRadius;
            const x = centerX + Math.cos(angle) * distance;
            const z = centerZ + Math.sin(angle) * distance;
            
            position = new Vector2D(x, z);
            attempts++;
            
            // Check if position is valid (within bounds and not in avoid areas)
            const withinBounds = position.x >= bounds.minX + 5 && 
                                position.x <= bounds.maxX - 5 &&
                                position.z >= bounds.minZ + 5 && 
                                position.z <= bounds.maxZ - 5;
            
            let inAvoidArea = false;
            for (const area of avoidAreas) {
                if (isWithinArea(position, area)) {
                    inAvoidArea = true;
                    break;
                }
            }
            
            if (withinBounds && !inAvoidArea) {
                break;
            }
            
        } while (attempts < maxAttempts);
        
        positions.push(position);
    }
    
    return positions;
}

/**
 * Reset game state to initial conditions
 * @param {Object} gameState - Current game state
 * @param {Array} initialPositions - Initial sheep positions
 * @returns {Object} - Reset game state
 */
export function resetGameState(gameState, initialPositions) {
    // Reset sheep states
    for (let i = 0; i < gameState.sheep.length; i++) {
        const sheep = gameState.sheep[i];
        const initialPos = initialPositions[i] || new Vector2D(-30, -30);
        
        sheep.position = initialPos.clone();
        sheep.velocity = new Vector2D(0, 0);
        sheep.acceleration = new Vector2D(0, 0);
        sheep.hasPassedGate = false;
        sheep.isRetiring = false;
        sheep.retirementTarget = null;
        sheep.state = 0; // Active state
    }
    
    // Reset game counters
    gameState.sheepRetired = 0;
    gameState.gameCompleted = false;
    gameState.gameActive = false;
    
    return gameState;
}

/**
 * Calculate herding effectiveness metrics
 * @param {Object} sheepdog - Sheepdog entity
 * @param {Array} sheep - Array of sheep entities
 * @param {Object} gate - Gate configuration
 * @returns {Object} - Herding effectiveness metrics
 */
export function calculateHerdingEffectiveness(sheepdog, sheep, gate) {
    if (!sheepdog) {
        return {
            sheepInRange: 0,
            sheepFleeing: 0,
            averageDistanceToGate: 0,
            herdingPressure: 0
        };
    }
    
    let sheepInRange = 0;
    let sheepFleeing = 0;
    let totalDistanceToGate = 0;
    
    for (let sheepEntity of sheep) {
        const distanceToSheepdog = sheepEntity.position.distanceTo(sheepdog.position);
        const distanceToGate = sheepEntity.position.distanceTo(gate.position);
        
        if (distanceToSheepdog < 15) { // Within herding range
            sheepInRange++;
        }
        
        if (distanceToSheepdog < sheepEntity.fleeRadius) { // Within flee radius
            sheepFleeing++;
        }
        
        totalDistanceToGate += distanceToGate;
    }
    
    const averageDistanceToGate = totalDistanceToGate / sheep.length;
    const herdingPressure = (sheepFleeing / sheep.length) * 100;
    
    return {
        sheepInRange,
        sheepFleeing,
        averageDistanceToGate,
        herdingPressure
    };
}
```

## shared/index.js

```javascript
/**
 * Shared Simulation Logic
 * Pure functions with no dependencies on DOM/Three.js
 * 
 * This module exports all the core simulation algorithms that can be used
 * by both client-side and server-side code for consistent behavior.
 */

// Import Vector2D for use in utility functions
import { Vector2D } from './Vector2D.js';

// Core data structures
export { Vector2D } from './Vector2D.js';

// Flocking behavior algorithms
export {
    calculateFlockingForce,
    calculateSeparation,
    calculateAlignment,
    calculateCohesion,
    calculateSeek,
    calculateFlee,
    getNeighbors
} from './FlockingAlgorithms.js';

// Movement and physics calculations
export {
    updateMovement,
    applyAcceleration,
    updateStamina,
    interpolatePosition,
    interpolateRotation,
    validateEntityState
} from './MovementPhysics.js';

// Boundary and collision detection
export {
    calculateBoundaryAvoidance,
    calculateBoundaryAvoidanceWithGate,
    applyHardBoundaryConstraints,
    isWithinArea,
    checkGatePassage,
    getDistanceToNearestBoundary,
    generateRandomPositionInBounds
} from './BoundaryCollision.js';

// Game state validation and management
export {
    updateSheepRetirements,
    checkGameCompletion,
    validateGameState,
    calculateGameProgress,
    generateInitialSheepPositions,
    resetGameState,
    calculateHerdingEffectiveness
} from './GameStateValidation.js';

/**
 * Utility function to create a standard boid configuration
 * @param {Object} overrides - Configuration overrides
 * @returns {Object} - Boid configuration
 */
export function createBoidConfig(overrides = {}) {
    return {
        maxSpeed: 1.5,
        maxForce: 0.05,
        perceptionRadius: 5,
        separationDistance: 2.0,
        separationWeight: 1.5,
        alignmentWeight: 1.0,
        cohesionWeight: 1.0,
        ...overrides
    };
}

/**
 * Utility function to create a standard movement configuration
 * @param {Object} overrides - Configuration overrides
 * @returns {Object} - Movement configuration
 */
export function createMovementConfig(overrides = {}) {
    return {
        maxSpeed: 1.5,
        dampingFactor: 0.98,
        velocitySmoothing: 0.85,
        minMovementThreshold: 0.001,
        acceleration: 40,
        deceleration: 30,
        ...overrides
    };
}

/**
 * Utility function to create a standard boundary configuration
 * @param {Object} overrides - Configuration overrides
 * @returns {Object} - Boundary configuration
 */
export function createBoundaryConfig(overrides = {}) {
    return {
        margin: 10,
        maxSpeed: 1.5,
        maxForce: 0.05,
        forceMultiplier: 1.5,
        ...overrides
    };
}

/**
 * Utility function to create a standard game state structure
 * @param {Object} config - Game configuration
 * @returns {Object} - Initial game state
 */
export function createGameState(config = {}) {
    const {
        totalSheep = 200,
        bounds = { minX: -100, maxX: 100, minZ: -100, maxZ: 100 },
        gatePosition = { x: 0, z: 100 },
        gateWidth = 8,
        pastureConfig = { centerZ: 115, minX: -30, maxX: 30, minZ: 102, maxZ: 130 }
    } = config;

    return {
        bounds,
        gate: {
            position: new Vector2D(gatePosition.x, gatePosition.z),
            width: gateWidth,
            height: 4,
            passageZone: {
                minX: -gateWidth / 2,
                maxX: gateWidth / 2,
                minZ: gatePosition.z - 2,
                maxZ: gatePosition.z + 2
            }
        },
        pasture: pastureConfig,
        params: {
            speed: 0.1,
            cohesion: 1.0,
            separationDistance: 2.0
        },
        sheep: [],
        sheepdog: null,
        sheepRetired: 0,
        totalSheep,
        gameCompleted: false,
        gameActive: false
    };
}
```

## shared/MovementPhysics.js

```javascript
import { Vector2D } from './Vector2D.js';

/**
 * Pure movement and physics calculation functions
 * Stateless and deterministic - no external dependencies
 */

/**
 * Update entity position and velocity based on forces and constraints
 * @param {Object} entity - Entity with position, velocity, acceleration
 * @param {number} deltaTime - Time step
 * @param {Object} config - Movement configuration
 * @returns {Object} - Updated entity state
 */
export function updateMovement(entity, deltaTime = 0.016, config = {}) {
    const {
        maxSpeed = 1.5,
        dampingFactor = 0.98,
        velocitySmoothing = 0.85,
        minMovementThreshold = 0.001
    } = config;
    
    // Store previous velocity for smoothing
    const previousVelocity = entity.velocity.clone();
    
    // Update velocity with acceleration
    entity.velocity.add(entity.acceleration);
    entity.velocity.limit(maxSpeed);
    
    // Apply velocity damping to reduce oscillations
    entity.velocity.multiply(dampingFactor);
    
    // Smooth velocity with previous velocity to reduce jittering
    const smoothedVelocity = previousVelocity
        .multiply(velocitySmoothing)
        .add(entity.velocity.clone().multiply(1 - velocitySmoothing));
    
    // Only apply movement if above threshold to prevent micro-movements
    if (smoothedVelocity.magnitude() > minMovementThreshold) {
        entity.velocity = smoothedVelocity;
        entity.position.add(entity.velocity);
    } else {
        // Stop micro-movements
        entity.velocity.multiply(0);
    }
    
    // Reset acceleration for next frame
    entity.acceleration.multiply(0);
    
    return {
        position: entity.position.clone(),
        velocity: entity.velocity.clone(),
        speed: entity.velocity.magnitude(),
        facingDirection: entity.velocity.magnitude() > minMovementThreshold ? entity.velocity.angle() : null
    };
}

/**
 * Apply smooth acceleration/deceleration to an entity
 * @param {Object} entity - Entity with velocity
 * @param {Vector2D} targetVelocity - Desired velocity
 * @param {number} deltaTime - Time step
 * @param {Object} config - Acceleration configuration
 * @returns {Vector2D} - Updated velocity
 */
export function applyAcceleration(entity, targetVelocity, deltaTime, config = {}) {
    const {
        acceleration = 40,
        deceleration = 30,
        maxSpeed = 15
    } = config;
    
    // Determine if we're accelerating or decelerating
    const isAccelerating = targetVelocity.magnitude() > 0;
    const accelerationRate = isAccelerating ? acceleration : deceleration;
    
    // Calculate velocity change
    const velocityDiff = targetVelocity.clone().subtract(entity.velocity);
    const velocityChange = velocityDiff.clone().multiply(accelerationRate * deltaTime);
    
    // Apply velocity change
    entity.velocity.add(velocityChange);
    
    // Limit to max speed
    if (entity.velocity.magnitude() > maxSpeed) {
        entity.velocity.normalize().multiply(maxSpeed);
    }
    
    return entity.velocity.clone();
}

/**
 * Update stamina based on activity
 * @param {Object} entity - Entity with stamina properties
 * @param {boolean} isConsuming - Whether stamina is being consumed
 * @param {number} deltaTime - Time step
 * @param {Object} config - Stamina configuration
 * @returns {Object} - Updated stamina info
 */
export function updateStamina(entity, isConsuming, deltaTime, config = {}) {
    const {
        maxStamina = 100,
        drainRate = 30,
        regenRate = 20,
        minStaminaToConsume = 10
    } = config;
    
    const isMoving = entity.velocity && entity.velocity.magnitude() > 0.1;
    
    if (isConsuming && isMoving && entity.stamina >= minStaminaToConsume) {
        // Drain stamina
        entity.stamina = Math.max(0, entity.stamina - drainRate * deltaTime);
    } else {
        // Regenerate stamina - faster when idle
        const currentRegenRate = isMoving ? regenRate : regenRate * 2;
        entity.stamina = Math.min(maxStamina, entity.stamina + currentRegenRate * deltaTime);
    }
    
    // Force stop consuming if stamina is depleted
    const canConsume = entity.stamina >= minStaminaToConsume;
    
    return {
        current: entity.stamina,
        max: maxStamina,
        percentage: (entity.stamina / maxStamina) * 100,
        canConsume: canConsume,
        isConsuming: isConsuming && canConsume
    };
}

/**
 * Calculate interpolated position for smooth rendering
 * @param {Vector2D} currentPosition - Current physics position
 * @param {Vector2D} renderPosition - Current render position
 * @param {number} deltaTime - Time step
 * @param {number} interpolationSpeed - Speed of interpolation
 * @returns {Vector2D} - New interpolated render position
 */
export function interpolatePosition(currentPosition, renderPosition, deltaTime, interpolationSpeed = 8.0) {
    const positionDiff = currentPosition.clone().subtract(renderPosition);
    const interpolationAmount = Math.min(1.0, interpolationSpeed * deltaTime);
    
    return renderPosition.clone().add(positionDiff.multiply(interpolationAmount));
}

/**
 * Calculate interpolated rotation for smooth rendering
 * @param {number} targetRotation - Target rotation in radians
 * @param {number} currentRotation - Current render rotation
 * @param {number} deltaTime - Time step
 * @param {number} rotationSpeed - Speed of rotation interpolation
 * @returns {number} - New interpolated rotation
 */
export function interpolateRotation(targetRotation, currentRotation, deltaTime, rotationSpeed = 12.0) {
    // Handle angle wrapping for smooth rotation
    let angleDiff = targetRotation - currentRotation;
    
    // Normalize angle difference to [-π, π]
    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
    
    // Apply rotation interpolation
    const rotationInterpolationAmount = Math.min(1.0, rotationSpeed * deltaTime);
    let newRotation = currentRotation + angleDiff * rotationInterpolationAmount;
    
    // Normalize final angle
    while (newRotation > Math.PI) newRotation -= 2 * Math.PI;
    while (newRotation < -Math.PI) newRotation += 2 * Math.PI;
    
    return newRotation;
}

/**
 * Validate and clamp entity values to prevent NaN/Infinity
 * @param {Object} entity - Entity to validate
 * @param {Vector2D} fallbackPosition - Safe fallback position
 * @returns {Object} - Validation results
 */
export function validateEntityState(entity, fallbackPosition = new Vector2D(0, 0)) {
    const issues = [];
    
    // Check velocity
    if (isNaN(entity.velocity.x) || isNaN(entity.velocity.z) || 
        !isFinite(entity.velocity.x) || !isFinite(entity.velocity.z)) {
        entity.velocity.set(0, 0);
        issues.push('velocity_nan');
    }
    
    // Check position
    if (isNaN(entity.position.x) || isNaN(entity.position.z) ||
        !isFinite(entity.position.x) || !isFinite(entity.position.z)) {
        entity.position = fallbackPosition.clone();
        entity.velocity.set(0, 0);
        issues.push('position_nan');
    }
    
    // Check acceleration if present
    if (entity.acceleration) {
        if (isNaN(entity.acceleration.x) || isNaN(entity.acceleration.z) ||
            !isFinite(entity.acceleration.x) || !isFinite(entity.acceleration.z)) {
            entity.acceleration.set(0, 0);
            issues.push('acceleration_nan');
        }
    }
    
    return {
        isValid: issues.length === 0,
        issues: issues
    };
}
```

## shared/test.js

```javascript
/**
 * Simple test suite for shared simulation logic
 * Run with: node shared/test.js
 */

import { 
    Vector2D,
    calculateFlockingForce,
    updateMovement,
    calculateBoundaryAvoidance,
    validateGameState,
    createBoidConfig,
    createGameState 
} from './index.js';

console.log('🧪 Testing Shared Simulation Logic...\n');

// Test 1: Vector2D
console.log('1. Testing Vector2D...');
const v1 = new Vector2D(3, 4);
const v2 = new Vector2D(1, 1);
console.log(`   Original: (${v1.x}, ${v1.z})`);
console.log(`   Magnitude: ${v1.magnitude()}`); // Should be 5
console.log(`   After adding (1,1): (${v1.add(v2).x}, ${v1.z})`); // Should be (4, 5)
console.log('   ✅ Vector2D working\n');

// Test 2: Flocking algorithms
console.log('2. Testing Flocking Algorithms...');
const boid = {
    position: new Vector2D(0, 0),
    velocity: new Vector2D(1, 0)
};
const neighbors = [
    { position: new Vector2D(2, 0), velocity: new Vector2D(0, 1) },
    { position: new Vector2D(-1, 1), velocity: new Vector2D(1, 1) }
];
const flockingConfig = createBoidConfig();
const flockingForce = calculateFlockingForce(boid, neighbors, flockingConfig);
console.log(`   Flocking force: (${flockingForce.x.toFixed(3)}, ${flockingForce.z.toFixed(3)})`);
console.log('   ✅ Flocking algorithms working\n');

// Test 3: Movement physics
console.log('3. Testing Movement Physics...');
const entity = {
    position: new Vector2D(0, 0),
    velocity: new Vector2D(0.5, 0.5),
    acceleration: new Vector2D(0.1, 0.1)
};
const movementResult = updateMovement(entity, 0.016);
console.log(`   New position: (${movementResult.position.x.toFixed(3)}, ${movementResult.position.z.toFixed(3)})`);
console.log(`   Speed: ${movementResult.speed.toFixed(3)}`);
console.log('   ✅ Movement physics working\n');

// Test 4: Boundary collision
console.log('4. Testing Boundary Collision...');
const boundaryEntity = {
    position: new Vector2D(95, 0), // Near right boundary
    velocity: new Vector2D(1, 0)
};
const bounds = { minX: -100, maxX: 100, minZ: -100, maxZ: 100 };
const boundaryForce = calculateBoundaryAvoidance(boundaryEntity, bounds);
console.log(`   Boundary avoidance force: (${boundaryForce.x.toFixed(3)}, ${boundaryForce.z.toFixed(3)})`);
console.log('   ✅ Boundary collision working\n');

// Test 5: Game state validation
console.log('5. Testing Game State Validation...');
const gameState = createGameState();
gameState.sheep = [
    { position: new Vector2D(0, 0), velocity: new Vector2D(0, 0), hasPassedGate: false, isRetiring: false }
];
gameState.sheepdog = { 
    position: new Vector2D(10, 10), 
    velocity: new Vector2D(0, 0), 
    stamina: 50, 
    maxStamina: 100 
};
const validation = validateGameState(gameState);
console.log(`   Game state valid: ${validation.isValid}`);
console.log(`   Issues: ${validation.issues.length > 0 ? validation.issues.join(', ') : 'None'}`);
console.log('   ✅ Game state validation working\n');

console.log('🎉 All tests passed! Shared simulation logic is working correctly.\n');

console.log('📁 Shared modules created:');
console.log('   • Vector2D.js - Core 2D vector math');
console.log('   • FlockingAlgorithms.js - Separation, alignment, cohesion');
console.log('   • MovementPhysics.js - Movement, acceleration, stamina, interpolation');
console.log('   • BoundaryCollision.js - Boundary avoidance and collision detection');
console.log('   • GameStateValidation.js - Game state management and validation');
console.log('   • index.js - Main export module with utility functions\n');

console.log('✨ Ready for Phase 1.4: Build multiplayer server!');
```

## shared/Vector2D.js

```javascript
/**
 * Simple 2D Vector class for XZ plane calculations
 * Pure function implementation with no external dependencies
 */
export class Vector2D {
    constructor(x = 0, z = 0) {
        this.x = x;
        this.z = z;
    }

    // Set the x and z components
    set(x, z) {
        this.x = x;
        this.z = z;
        return this;
    }

    // Add another vector to this one
    add(vector) {
        this.x += vector.x;
        this.z += vector.z;
        return this;
    }

    // Subtract another vector from this one
    subtract(vector) {
        this.x -= vector.x;
        this.z -= vector.z;
        return this;
    }

    // Multiply by a scalar
    multiply(scalar) {
        this.x *= scalar;
        this.z *= scalar;
        return this;
    }

    // Divide by a scalar
    divide(scalar) {
        if (scalar !== 0) {
            this.x /= scalar;
            this.z /= scalar;
        }
        return this;
    }

    // Get the magnitude (length) of the vector
    magnitude() {
        return Math.sqrt(this.x * this.x + this.z * this.z);
    }

    // Normalize the vector (make it unit length)
    normalize() {
        const len = this.magnitude();
        if (len > 0.00001) { // Use a small epsilon to prevent division by zero/tiny number
            this.x /= len;
            this.z /= len;
        } else {
            this.x = 0;
            this.z = 0;
        }
        return this;
    }

    // Limit the magnitude of the vector
    limit(max) {
        const len = this.magnitude();
        if (len > max && len > 0.00001) { // Only normalize if magnitude is significant and over max
            this.normalize();
            this.multiply(max);
        }
        return this;
    }

    // Get distance to another vector
    distanceTo(vector) {
        const dx = this.x - vector.x;
        const dz = this.z - vector.z;
        return Math.sqrt(dx * dx + dz * dz);
    }

    // Get the angle of the vector in radians
    angle() {
        return Math.atan2(this.z, this.x);
    }

    // Set the magnitude of the vector
    setMagnitude(magnitude) {
        this.normalize();
        this.multiply(magnitude);
        return this;
    }

    // Create a copy of this vector
    clone() {
        return new Vector2D(this.x, this.z);
    }

    // Static method to create a vector from an angle
    static fromAngle(angle) {
        return new Vector2D(Math.cos(angle), Math.sin(angle));
    }

    // Static method to get a random unit vector
    static random() {
        const angle = Math.random() * Math.PI * 2;
        return Vector2D.fromAngle(angle);
    }
}
```

## start-client-server.ps1

```text
# Start Client HTTP Server
Write-Host "Starting HTTP server for client..." -ForegroundColor Cyan
Write-Host "Open http://localhost:8080 in your browser" -ForegroundColor White
Write-Host "Press Ctrl+C to stop" -ForegroundColor Yellow
Write-Host ""

python -m http.server 8080
```

## start-game-server.ps1

```text
# Start Game Server
Write-Host "Starting authoritative game server on port 9208..." -ForegroundColor Green
Write-Host "Server will be available at http://127.0.0.1:9208" -ForegroundColor White
Write-Host "Press Ctrl+C to stop" -ForegroundColor Yellow
Write-Host ""

cd server
$env:PORT=9208
$env:OPENSSL_CONF=''
$env:OPENSSL_ENGINES=''
node index.js
```

## start-multiplayer-servers.ps1

```text
# Start Multiplayer Sheepdog Servers
# Opens two terminals: one for the authoritative game server, one for client HTTP server

Write-Host "Starting Multiplayer Sheepdog Servers..." -ForegroundColor Green

# Terminal 1: Authoritative Game Server (port 9208)
Write-Host "Starting authoritative game server on port 9208..." -ForegroundColor Yellow
Start-Process powershell -ArgumentList "-NoExit", "-Command", "cd '$PSScriptRoot'; Write-Host 'Authoritative Game Server (Port 9208)' -ForegroundColor Green; cd server; `$env:PORT=9208; `$env:OPENSSL_CONF=''; `$env:OPENSSL_ENGINES=''; node index.js"

# Wait a moment for server to start
Start-Sleep -Seconds 2

# Terminal 2: HTTP Server for Client (port 8080)  
Write-Host "Starting HTTP server for client on port 8080..." -ForegroundColor Cyan
Start-Process powershell -ArgumentList "-NoExit", "-Command", "cd '$PSScriptRoot'; Write-Host 'Client HTTP Server (Port 8080)' -ForegroundColor Cyan; Write-Host 'Open http://localhost:8080 in your browser' -ForegroundColor White; python -m http.server 8080"

Write-Host ""
Write-Host "Both servers started!" -ForegroundColor Green
Write-Host "Game Server: http://127.0.0.1:9208" -ForegroundColor Yellow  
Write-Host "Client: http://localhost:8080" -ForegroundColor Cyan
Write-Host ""
Write-Host "Press any key to close all servers..." -ForegroundColor White
$null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")

# Kill all node and python processes when script ends
Write-Host "Stopping servers..." -ForegroundColor Red
Get-Process -Name "node" -ErrorAction SilentlyContinue | Stop-Process -Force
Get-Process -Name "python" -ErrorAction SilentlyContinue | Stop-Process -Force
Write-Host "Servers stopped!" -ForegroundColor Green
```

## task-list.md

```markdown
# 🐑 Hybrid Sheepdog Simulation - Task List

## Phase 1: Add Multiplayer Mode (Keep Single-Player) ⚙️

### 1.1 Project Structure Setup
- [ ] Create server/ directory for multiplayer server
- [ ] Create shared/ directory for common simulation logic
- [ ] Keep existing client code in root (maintain single-player)
- [ ] Set up package.json for server directory
- [ ] Install necessary dependencies (Geckos.io for server, minimal client deps)

### 1.2 Enhance Start Screen with Room-Based Multiplayer
- [x] Modify StartScreen.js to show mode options:
  - [x] "🐕 Play Solo" (existing single-player experience)
  - [x] "👥 Play Online" → leads to room options:
    - [x] "🏠 Create Room" (host with 6-digit code)
    - [x] "🔗 Join Room" (enter room code)
    - [x] "⚡ Quick Match" (join any public room)
- [x] Implement room creation flow:
  - [x] Generate 6-digit room codes (ABC123 format)
  - [x] Room settings (name, max players 2-4, private/public)
  - [x] Host lobby screen with player list and controls
- [x] Implement room joining flow:
  - [x] Room code input with validation
  - [x] Player lobby screen (no host controls)
- [x] Add lobby features:
  - [x] Real-time player list updates
  - [x] Room code sharing/copying
  - [x] Host start game control
  - [x] Leave room / back to menu options
- [x] Handle connection errors gracefully (fallback to solo)

### 1.3 Extract Shared Simulation Logic  
- [x] Create shared/ directory with pure functions:
  - [x] Extract core flocking algorithms (from Boid.js)
  - [x] Extract movement and physics calculations
  - [x] Extract boundary and collision detection
  - [x] Extract game state validation
- [x] Ensure shared code has zero dependencies on DOM/Three.js
- [x] Make functions stateless and deterministic

### 1.4 Build Multiplayer Server with Room Management
- [x] Create server entry point with Geckos.io
- [x] Implement room management system:
  - [x] Generate and validate 6-digit room codes
  - [x] Track room state (waiting, in-game, finished)
  - [x] Handle 2-4 players per room
  - [x] Host privileges and delegation
  - [x] Public room matchmaking for Quick Match
- [x] Set up per-room authoritative simulation (60 FPS tick per room)
- [x] Server-side state management per room:
  - [x] All sheep positions and behaviors
  - [x] Multiple dog positions and stamina (one per player)
  - [x] Game progress and completion
- [x] Handle player connections/disconnections:
  - [x] Join/leave room logic
  - [x] Host migration if host disconnects
  - [x] Game state cleanup for empty rooms
- [x] Process client inputs and apply to server state
- [x] Broadcast game state to all clients in room

### 1.5 Add Multiplayer Client Mode with Room Support
- [x] Create NetworkManager.js for room-based multiplayer communication
- [x] Implement dual-mode GameState (local vs networked)
- [x] Add room management on client:
  - [x] Room creation and joining logic
  - [x] Lobby state management
  - [x] Player list synchronization
  - [x] Host detection and UI changes
- [x] Add multiplayer input handling (send to server instead of local)
- [x] Create networked rendering mode:
  - [x] Receive server state updates
  - [x] Interpolate positions for smooth movement
  - [ ] Handle multiple dogs on screen (different colors/names) **(Future Enhancement)**
- [x] Add multiplayer UI elements:
  - [x] Lobby player list with ready states
  - [x] Room code display and sharing
  - [x] Connection status and latency
  - [x] In-game player indicators

### 1.6 Network Protocol & Synchronization
- [x] Define message protocols for client-server communication
- [x] Implement efficient state updates (client-side interpolation)
- [x] Add client-side interpolation for smooth gameplay
- [x] Handle network latency and packet loss (ping measurement & reconnection)
- [x] Add reconnection logic for dropped connections

## Phase 2: Local Testing & UX Polish 🧪

### 2.1 Single-Player Mode Verification
- [ ] Ensure existing single-player mode still works perfectly
- [ ] Verify all original features work (stamina, timer, completion)
- [ ] Test performance is unchanged in solo mode
- [ ] Confirm start screen transitions work

### 2.2 Local Multiplayer Testing
- [ ] Set up server to run on localhost:3000
- [ ] Test start screen mode selection
- [ ] Verify connection flow and error handling
- [ ] Test with 2+ browser tabs in multiplayer mode
- [ ] Verify input from one tab updates all tabs
- [ ] Test disconnect/reconnect scenarios
- [ ] Verify sheep state consistency across clients
- [ ] Test graceful fallback to single-player on connection issues

### 2.3 User Experience Testing
- [ ] Test mode switching (solo to multiplayer and back)
- [ ] Verify loading states and connection feedback
- [ ] Test error messages and recovery flows
- [ ] Measure and optimize multiplayer latency
- [ ] Test edge cases (rapid inputs, connection drops)

### 2.4 Performance Validation
- [ ] Monitor server CPU/memory usage with multiple clients
- [ ] Test with maximum player count per room
- [ ] Verify 60 FPS client performance in both modes
- [ ] Optimize network message frequency
- [ ] Ensure single-player performance is unaffected

## Phase 3: Deploy to Fly.io 🚀

### 3.1 Fly.io Setup
- [ ] Install flyctl CLI
- [ ] Authenticate with Fly.io
- [ ] Create Fly.io application for multiplayer server
- [ ] Configure fly.toml for UDP (Geckos.io requirement)

### 3.2 Server Deployment
- [ ] Prepare server for production environment
- [ ] Add environment variables and configuration
- [ ] Deploy multiplayer server to Fly.io
- [ ] Verify UDP connectivity works
- [ ] Test public multiplayer endpoint

### 3.3 Client Update & Deployment  
- [ ] Update client to use production server URL for multiplayer
- [ ] Ensure single-player mode works without server
- [ ] Build and deploy updated client
- [ ] Test full production setup with both modes

## Completion Checklist ✅

### Single-Player Mode (Preserved)
- [ ] Solo mode works exactly as before
- [ ] All original features intact (stamina, timer, sheep AI)
- [ ] Performance unchanged
- [ ] No network dependencies

### Multiplayer Mode (New)
- [ ] Start screen offers both solo and online options
- [ ] Multiplayer connection flow works smoothly  
- [ ] Multiple players can join and play together
- [ ] Server-authoritative simulation runs reliably
- [ ] Inputs and syncs are frame-consistent across clients
- [ ] Graceful handling of connection issues
- [ ] Sheep behave identically between clients

### Deployment
- [ ] Multiplayer server successfully deployed to Fly.io
- [ ] Client works with both local and production servers
- [ ] Public multiplayer testing successful

## Current Status
**Phase**: Phase 1 - COMPLETE ✅
**Next Task**: Begin Phase 2 - Local Testing & UX Polish

## Completed Features ✅
### User Interface & Experience
- ✅ Room-based multiplayer UI with full navigation flow
- ✅ 6-digit room code generation and validation
- ✅ Host lobby with player management and copy functionality
- ✅ Solo mode preserved exactly as before
- ✅ Graceful error handling and fallbacks
- ✅ Mobile-responsive design for all screens
- ✅ Keyboard shortcuts (Enter, Escape) for better UX
- ✅ In-game multiplayer HUD with player list and connection status
- ✅ Real-time ping/latency display with color coding
- ✅ Connection state indicators (connected/disconnected/reconnecting)

### Core Architecture
- ✅ Shared simulation logic extracted to pure functions
- ✅ Core flocking algorithms (separation, alignment, cohesion)
- ✅ Movement and physics calculations with interpolation
- ✅ Boundary and collision detection functions
- ✅ Game state validation and management utilities
- ✅ Dual-mode GameState (local vs networked)

### Multiplayer Server
- ✅ Multiplayer server with Geckos.io networking
- ✅ Room management system with host delegation and cleanup
- ✅ Authoritative 60 FPS game simulation per room
- ✅ Server-side sheep flocking and dog physics using shared logic
- ✅ Player input processing and state broadcasting
- ✅ Graceful connection handling and room maintenance
- ✅ Ping measurement and response system

### Multiplayer Client
- ✅ NetworkManager with comprehensive room-based networking
- ✅ Real-time room creation, joining, and quick match functionality
- ✅ Client-side interpolation for smooth multiplayer gameplay
- ✅ Player input synchronization with server authority
- ✅ Automatic reconnection with exponential backoff
- ✅ Game state synchronization and sheep position updates
- ✅ Multiplayer UI management with player status tracking
- ✅ Network error handling with graceful fallbacks to solo mode

## Notes & Context
- **Hybrid Approach**: Keep single-player intact, add multiplayer as option
- **UX Priority**: Seamless mode selection, graceful error handling
- **Server Authority**: Only multiplayer mode uses server simulation
- **Performance**: Single-player should have zero network overhead
- **Fallback**: Connection failures should redirect to single-player mode
```

## Statistics

- Total Files: 64
- Total Characters: 791831
- Total Tokens: 0
