This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-05-28 21:08:16

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
ARCHITECTURE.md
assets
  sounds
    SDS Start Music.wav
    SDS1.wav
    SDS2.wav
    SDS3.wav
    win.wav
index.html
js
  AudioManager.js
  Boid.js
  GameState.js
  GameTimer.js
  InputHandler.js
  main.js
  MobileControls.js
  OptimizedSheep.js
  PerformanceMonitor.js
  SceneManager.js
  Sheepdog.js
  StaminaUI.js
  StartScreen.js
  StructureBuilder.js
  TerrainBuilder.js
  Vector2D.js
MOBILE_CONTROLS.md
package.json
README.md
```

# Repository Files


## ARCHITECTURE.md

````markdown
# Sheep Dog Simulation - Technical Architecture

## Overview
A sophisticated real-time 3D sheep herding simulation built with Three.js, implementing advanced flocking behavior algorithms, immersive environmental rendering, competitive gameplay mechanics, and polished user experience features. The simulation features 200 autonomous sheep agents with emergent flocking behavior rendered using high-performance GPU-based instanced rendering, a player-controlled sheepdog with stamina and sprint mechanics, timer-based scoring, cinematic start screen, and an expansive 3D world with realistic environmental elements.

## Modular Architecture

The simulation uses a clean, modular architecture optimized for performance and maintainability. Each module has a single responsibility and clear interfaces, with the sheep system utilizing cutting-edge GPU-based rendering for maximum efficiency.

### Module Overview

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   SceneManager  │    │ TerrainBuilder  │    │StructureBuilder│
│                 │    │                 │    │                 │
│ • 3D Rendering  │    │ • Environment   │    │ • Fences/Gates  │
│ • Camera System │    │ • Grass/Trees   │    │ • Pastures      │
│ • Lighting      │    │ • Mountains     │    │ • Structures    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                    ┌─────────────────┐
                    │   main.js       │
                    │                 │
                    │ • Orchestration │
                    │ • Game Loop     │
                    │ • Module Coord  │
                    └─────────────────┘
                                 │
         ┌───────────────────────┼───────────────────────┐
         │                       │                       │
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   GameState     │    │   GameTimer     │    │  InputHandler   │
│                 │    │                 │    │                 │
│ • Game Logic    │    │ • Timing System │    │ • User Input    │
│ • Sheep Mgmt    │    │ • Best Scores   │    │ • WASD Control  │
│ • Completion    │    │ • Persistence   │    │ • Sprint/Pause  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
         ┌───────────────────────┼───────────────────────┐
         │                       │                       │
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   StartScreen   │    │   StaminaUI     │    │PerformanceMonitor│
│                 │    │                 │    │                 │
│ • Start Screen  │    │ • Stamina Bar   │    │ • FPS Tracking  │
│ • Cinematic Cam │    │ • UI Updates    │    │ • Stats Display │
│ • Game Launch   │    │ • Visual States │    │ • Metrics       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

## Core Modules

### 1. SceneManager.js (141 lines)
**3D Scene and Rendering Management**

**Responsibilities:**
- Three.js scene initialization and configuration
- Camera system with dynamic following and zoom
- Lighting setup (ambient + directional with shadows)
- Window resize handling and viewport management
- Mouse wheel zoom controls

**Key Features:**
- **Dynamic Camera**: Smooth interpolation following sheepdog with configurable zoom (20-150 units)
- **Advanced Lighting**: Multi-light setup with shadow mapping (2048x2048 resolution)
- **Fog System**: Atmospheric depth with extended range (200-600 units)
- **Performance Optimized**: Efficient render loop with minimal state changes

**API:**
```javascript
class SceneManager {
    updateCamera(sheepdog)     // Follow sheepdog with smooth interpolation
    setupMouseControls()       // Enable zoom controls
    render()                   // Render scene to canvas
    add(object)               // Add object to scene
    getScene()                // Access Three.js scene
    getCamera()               // Access camera for start screen
}
```

### 2. TerrainBuilder.js (397 lines)
**Environment and Terrain Generation**

**Responsibilities:**
- Flat terrain generation (1000x1000 units)
- Instanced grass system with wind animation
- Multi-layered mountain generation
- Realistic tree creation (deciduous and pine)
- Environmental details (rocks, atmospheric effects)

**Key Features:**
- **Massive Grass System**: 800,000 instanced grass blades with shader-based wind animation
- **Procedural Mountains**: Three-layer mountain system with geometric variation
- **Realistic Trees**: Separate trunks and multi-layer foliage (200 deciduous + 80 pine)
- **Distance Scaling**: Grass and details scale with distance for realistic perspective

**Grass Shader System:**
```glsl
// Vertex Shader Features:
- Wind displacement with multi-frequency sine waves
- Blade tip emphasis with cosine-based power curves
- Complex multi-directional wind patterns
- Instance matrix transformations for positioning

// Fragment Shader Features:
- Base-to-tip color gradients
- Positional color variation with noise
- Fog integration with depth-based blending
- Performance-optimized calculations
```

**API:**
```javascript
class TerrainBuilder {
    createTerrain()           // Generate base terrain
    createGrass()            // Create instanced grass system
    createMountains()        // Generate mountain layers
    createTrees()            // Create tree forests
    updateGrassAnimation()   // Update wind animation
    getGrassInstanceCount()  // Get grass count for performance monitoring
}
```

### 3. StructureBuilder.js (471 lines)
**Game Structures and Boundaries**

**Responsibilities:**
- Field boundary fence system with posts and rails
- Gate construction with detection zones
- Pasture area creation with custom textures
- Fence rail connection algorithms

**Key Features:**
- **Modular Fence System**: Procedural fence generation with configurable spacing
- **Gate Mechanics**: Golden threshold markers with passage detection
- **Custom Textures**: Canvas-generated pasture textures with gradient effects
- **Structural Integrity**: Proper rail connections and post placement

**API:**
```javascript
class StructureBuilder {
    createFieldBoundaryFence(bounds, gate)  // Generate perimeter fencing
    createGateAndPasture(gate, pasture)     // Create goal structures
    createFenceRail(x1, z1, x2, z2, ...)   // Connect fence segments
}
```

### 4. GameState.js (242 lines)
**Game Logic and State Management**

**Responsibilities:**
- Game configuration and boundaries
- Optimized sheep system coordination
- Completion detection and progress tracking
- UI updates and completion messaging
- Pause state management

**Key Features:**
- **Centralized Configuration**: All game parameters in one location
- **Optimized Sheep Management**: Always uses high-performance GPU rendering
- **Progress Monitoring**: Real-time sheep count and completion detection
- **UI Integration**: Automatic UI updates and completion messages
- **Pause Support**: Coordinated pause state across systems

**Configuration:**
```javascript
// Field boundaries and game areas
bounds: { minX: -100, maxX: 100, minZ: -100, maxZ: 100 }
gate: { position: Vector2D(0, 100), width: 8, height: 4 }
pasture: { minX: -30, maxX: 30, minZ: 102, maxZ: 130 }

// Simulation parameters
params: {
    speed: 0.1,              // Sheep movement speed
    cohesion: 1.0,           // Flock cohesion strength
    separationDistance: 2.0   // Minimum separation distance
}
```

### 5. GameTimer.js (181 lines)
**Timing System and Score Tracking**

**Responsibilities:**
- Precision timing with performance.now()
- Best time persistence in localStorage
- New record detection and celebration
- Timer display formatting and UI updates
- Pause state handling

**Key Features:**
- **High Precision**: Millisecond-accurate timing
- **Persistent Storage**: Best times saved across browser sessions
- **Visual Feedback**: New record animations and celebrations
- **Error Handling**: Graceful fallback for localStorage issues
- **Pause Integration**: Respects pause state for accurate timing

**API:**
```javascript
class GameTimer {
    start()                  // Begin timing
    stop()                   // End timing and check for records
    update()                 // Update display during gameplay
    reset()                  // Reset timer for new game
    setPaused(isPaused)      // Handle pause state
    formatTime(seconds)      // Format time for display
    getBestTime()           // Retrieve best time
}
```

### 6. OptimizedSheep.js (788 lines)
**High-Performance GPU-Based Sheep System**

**Responsibilities:**
- Single InstancedMesh for all 200 sheep (1 draw call!)
- GPU-based animation via vertex shaders
- Merged geometry with vertex colors
- Efficient per-instance data management

**Key Features:**
- **Instanced Rendering**: All sheep rendered in a single draw call
- **GPU Animation**: Vertex shader-based movement and behavior animation
- **Merged Geometry**: Body, head, and legs combined into single geometry
- **Vertex Colors**: Per-vertex coloring for material variation
- **Efficient Updates**: Minimal CPU-GPU data transfer

**Shader System:**
```glsl
// Vertex Shader Features:
- Per-instance animation data (phase, speed, state, direction)
- Leg animation with galloping motion
- Body bounce and head bob
- Facing direction and look-at behavior
- Instance matrix transformations

// Fragment Shader Features:
- Toon shading with stepped lighting
- Vertex color support for material variation
- Fog integration for atmospheric depth
- Performance-optimized lighting calculations
```

**Performance Metrics:**
```javascript
// Rendering Efficiency:
- 200 sheep: 1 draw call (vs 200+ in traditional approach)
- GPU animation: 0 CPU overhead for movement
- Memory usage: ~50MB for all sheep data
- Target: 60 FPS with full flock + environment
```

### 7. PerformanceMonitor.js (377 lines)
**Real-time Performance Tracking and Statistics**

**Responsibilities:**
- Stats.js integration for FPS and memory monitoring
- Custom simulation-specific performance metrics
- Real-time display of rendering statistics
- Performance data collection and analysis

**Key Features:**
- **Stats.js Integration**: Professional FPS/memory tracking with fallback support
- **Custom Metrics Panel**: Simulation-specific statistics (sheep count, grass instances, draw calls)
- **Frame Time Analysis**: Rolling average, min/max frame time tracking
- **Memory Monitoring**: JavaScript heap usage when available
- **Toggle Controls**: Show/hide performance displays with 'P' key

**Performance Metrics:**
```javascript
metrics: {
    sheepCount: 200,         // Total sheep in simulation
    activeSheepCount: 0,     // Currently active sheep
    grassInstances: 800000,  // Number of grass blade instances
    drawCalls: 0,            // WebGL draw calls per frame
    triangles: 0,            // Total triangles rendered
    avgFrameTime: 0,         // Rolling average frame time
    minFrameTime: Infinity,  // Minimum frame time recorded
    maxFrameTime: 0          // Maximum frame time recorded
}
```

### 8. StartScreen.js (136 lines)
**Start Screen and Pre-Game Experience**

**Responsibilities:**
- Start screen overlay management
- Cinematic camera system for pre-game showcase
- Game launch coordination
- UI transition management

**Key Features:**
- **Cinematic Camera**: Smooth orbital camera movement around the field
- **Interactive UI**: Start button and Enter key support
- **Smooth Transitions**: Fade animations between start screen and gameplay
- **Game Coordination**: Callback system for game initialization

**API:**
```javascript
class StartScreen {
    updateCinematicCamera()      // Update orbital camera movement
    startGame()                  // Initiate game start sequence
    setGameStartCallback(fn)     // Register game start handler
    isStartScreenActive()        // Check if start screen is active
    reset()                      // Reset to start screen state
}
```

### 9. StaminaUI.js (105 lines)
**Stamina System User Interface**

**Responsibilities:**
- Stamina bar display and updates
- Visual state management (normal, low, critical, sprinting)
- Performance-optimized UI updates
- Stamina percentage and status display

**Key Features:**
- **Visual States**: Color-coded stamina levels with animations
- **Performance Optimized**: Only updates DOM when values change
- **State Indicators**: Different colors and labels for various stamina states
- **Smooth Animations**: CSS transitions for visual feedback

**API:**
```javascript
class StaminaUI {
    update(staminaInfo)     // Update display based on sheepdog stamina
    show()                  // Show stamina bar when game starts
    hide()                  // Hide stamina bar
    reset()                 // Reset to full stamina display
}
```

### 10. Sheepdog.js (683 lines)
**Enhanced Player Controller with Stamina System**

**Responsibilities:**
- Player movement with acceleration and deceleration
- Stamina system with sprint mechanics
- Detailed 3D model with procedural animations
- Idle behavior system with multiple animation states

**Key Features:**
- **Stamina System**: Sprint mechanics with stamina drain and regeneration
- **Smooth Movement**: Acceleration-based movement with boundary constraints
- **Detailed Model**: Procedural dog mesh with realistic proportions and materials
- **Rich Animations**: Running, idle, breathing, looking around, ear twitching, stretching
- **Visual Feedback**: Tongue visibility when running, different animation speeds

**Stamina Mechanics:**
```javascript
// Stamina Configuration:
maxStamina: 100,
staminaDrainRate: 30,      // Per second when sprinting
staminaRegenRate: 20,      // Per second when not sprinting (40 when idle)
minStaminaToSprint: 10,    // Minimum stamina to start sprinting
maxSpeed: 15,              // Normal movement speed
sprintSpeed: 25            // Sprint movement speed
```

### 11. InputHandler.js (182 lines)
**Enhanced Input Management with Pause System**

**Responsibilities:**
- WASD movement input handling
- Sprint control (Shift key)
- Pause system (Escape key)
- Performance monitor toggle (P key)
- Focus and blur event handling

**Key Features:**
- **Pause System**: Escape key toggles pause with visual indicator
- **Sprint Control**: Shift key for stamina-based sprinting
- **State Management**: Proper key state clearing on pause/blur
- **Callback System**: Pause state notifications to other systems

**API:**
```javascript
class InputHandler {
    getMovementDirection()   // Get normalized movement vector
    isSprinting()           // Check if sprint key is pressed
    isPausedState()         // Check current pause state
    togglePause()           // Toggle pause state
    onPauseToggle(callback) // Register pause state change callback
}
```

### 12. main.js (192 lines)
**Enhanced Orchestration and Game Loop**

**Responsibilities:**
- Module initialization and coordination
- Start screen to game transition management
- Main game loop and update cycle
- Pause state coordination
- Performance monitoring integration

**Enhanced Structure:**
```javascript
class SheepDogSimulation {
    constructor() {
        // Initialize all modules including new ones
        this.startScreen = new StartScreen(this.sceneManager);
        this.staminaUI = new StaminaUI();
        // ... other modules
        
        // Set up pause handling across systems
        this.setupPauseHandling();
    }
    
    startGame() {
        // Transition from start screen to active game
        // Add sheepdog to scene, start timer, show stamina UI
    }
    
    update(deltaTime) {
        // Coordinate all systems with pause awareness
        // Handle start screen vs active game states
    }
}
```

## AI and Behavior Systems

### Boid System (js/Boid.js - 248 lines)
**Enhanced Flocking Algorithm**
- **Separation**: Exponential repulsion to avoid crowding
- **Alignment**: Weighted average heading calculation
- **Cohesion**: Center-of-mass attraction with distance weighting
- **Boundary Avoidance**: Soft and hard boundary systems
- **Performance**: Spatial optimization with perception radius limiting

### Optimized Sheep Agent (js/OptimizedSheep.js)
**GPU-Accelerated State Machine**
```javascript
States:
- Active (0): Normal flocking + dog avoidance + gate attraction
- Retiring (1): Seeking pasture position (50% speed reduction)
- Grazing (2): Gentle wandering in pasture with minimal movement

Behavioral Parameters:
- Flee radius: 8 units from sheepdog
- Gate attraction: 0.5 force multiplier when herded
- Boundary constraints: Hard stop at fence edges (except gate area)
- Grazing behavior: 0.2% chance per frame for gentle movement
```

### Enhanced Sheepdog Controller (js/Sheepdog.js)
**Advanced Player Input System**
- **Movement**: WASD input with smooth acceleration/deceleration
- **Sprint System**: Shift key with stamina management
- **Visual Model**: Detailed procedural dog mesh with realistic animations
- **Influence**: Affects sheep within 8-unit flee radius
- **Idle Behaviors**: Multiple idle animation states for immersion

## User Experience Systems

### Start Screen System
- **Cinematic Camera**: Orbital camera showcasing the field before gameplay
- **Interactive UI**: Professional start screen with instructions and branding
- **Smooth Transitions**: Fade animations between start screen and gameplay
- **Keyboard Support**: Enter key and click support for accessibility

### Stamina System
- **Visual Feedback**: Color-coded stamina bar with state indicators
- **Gameplay Impact**: Sprint speed vs stamina management decisions
- **Recovery Mechanics**: Faster regeneration when idle vs moving
- **UI Integration**: Real-time updates with performance optimization

### Pause System
- **Universal Pause**: Escape key pauses all game systems
- **Visual Indicator**: Clear pause overlay with resume instructions
- **State Preservation**: Proper pause/resume of timers and animations
- **Input Handling**: Prevents movement input during pause

## Rendering Pipeline

### Performance Optimizations

#### GPU-Based Rendering
- **Sheep System**: Single InstancedMesh for all 200 sheep (1 draw call)
- **Vertex Shader Animation**: All sheep movement calculated on GPU
- **Instanced Grass**: Single draw call for 800,000 grass instances
- **Shared Geometries**: Reused base geometries for environmental objects
- **Memory Efficiency**: ~150MB total for entire scene

#### Advanced Techniques
- **Merged Geometry**: Sheep body parts combined into single geometry
- **Vertex Colors**: Per-vertex material variation without texture switching
- **Instance Attributes**: Custom per-sheep data (animation, state, direction)
- **Frustum Culling**: Disabled for instanced meshes to prevent pop-in

#### Shadow System
- **Optimized Mapping**: 2048x2048 shadow maps with 240-unit coverage
- **Selective Casting**: Only essential objects cast shadows
- **PCF Soft Shadows**: Smooth shadow edges for visual quality

### Shader Systems

#### Optimized Sheep Shader
```glsl
// Vertex Shader Features:
- Instance data: animPhase, speed, state, uniqueId
- Animation data: walkCycle, bounce, direction, blinkTimer
- Leg animation with galloping motion (vertexId 100-139)
- Body bounce animation (vertexId 0-49)
- Head bob and look direction (vertexId 50-99)

// Fragment Shader Features:
- Toon shading with 3-step lighting
- Vertex color support for material variation
- Fog integration with depth-based blending
- Optimized lighting calculations
```

#### Grass Animation Shader
```glsl
// Wind simulation with multiple frequencies
float windX = sin(worldPos.z * 0.1 + time * 2.0) * cos(worldPos.x * 0.1 + time * 1.5);
float windZ = cos(worldPos.x * 0.15 + time * 2.5) * sin(worldPos.z * 0.15 + time * 2.0);

// Blade tip emphasis
float dispPower = 1.0 - cos(uv.y * PI / 2.0);
displacement = windX * (0.15 * dispPower);
```

## Game Logic Systems

### Gate Passage Detection
```javascript
// Multi-criteria validation:
1. Position within gate passage zone (4-unit width)
2. Positive Z velocity (moving toward pasture)
3. Not already passed (state tracking)
4. Velocity threshold for intentional movement
```

### Completion System
- **Progress Tracking**: Real-time count of retired sheep
- **State Validation**: Multiple checks for completion
- **Timer Integration**: Automatic timer stop on completion
- **UI Updates**: Dynamic progress display and completion messages

### Boundary System
```javascript
// Hierarchical boundary enforcement:
Hard Boundaries: -100 to +100 (x,z) - absolute limits (except for passed sheep)
Soft Boundaries: 3-unit margin with exponential repulsion
Gate Exception: 8-unit opening at (0, 100)
Pasture Area: (-30 to 30, 102 to 130) - goal zone with gentle containment
```

### Grazing System
```javascript
// Post-gate behavior:
- Gentle wandering: 0.2% chance per frame for movement
- Pasture containment: Soft forces to stay within bounds
- Reduced speed: 0.02 units for realistic grazing
- Continuous animation: Maintained visual activity
```

## Data Structures and Algorithms

### Vector2D Mathematics (js/Vector2D.js - 102 lines)
**Optimized 2D Vector Operations**
```javascript
class Vector2D {
    add(vector)              // Vector addition
    subtract(vector)         // Vector subtraction
    multiply(scalar)         // Scalar multiplication
    normalize()              // Unit vector conversion
    magnitude()              // Length calculation
    distance(vector)         // Distance between vectors
    limit(max)              // Magnitude limiting
    angle()                 // Calculate angle for rotation
}
```

### Spatial Optimization
- **Neighbor Detection**: Efficient radius-based queries
- **Perception Limiting**: Configurable awareness radius
- **Update Batching**: Grouped behavior calculations
- **GPU Offloading**: Animation calculations moved to vertex shaders

## Performance Characteristics

### Target Specifications
- **Frame Rate**: 60 FPS sustained
- **Sheep Count**: 200 autonomous agents (1 draw call)
- **Grass Instances**: 800,000 animated blades (1 draw call)
- **Total Draw Calls**: <10 for entire scene
- **Memory Usage**: ~150MB for full scene

### Bottleneck Analysis
- **Primary**: Grass rendering (800k instances)
- **Secondary**: Shadow calculations (2048² maps)
- **Tertiary**: JavaScript behavior updates (200 agents)
- **Eliminated**: Individual sheep rendering overhead

### Optimization Strategies
- **GPU-Based Animation**: Vertex shader calculations
- **Instanced Rendering**: Massive geometry reduction
- **Shared Resources**: Memory efficiency
- **Simplified Physics**: 2D calculations with 3D rendering
- **Culling Systems**: Visibility and distance-based optimizations

## Extension Architecture

### Adding New Features
```javascript
// 1. Create new module class
class WeatherSystem {
    constructor(scene) { this.scene = scene; }
    update() { /* weather logic */ }
}

// 2. Initialize in main.js
this.weatherSystem = new WeatherSystem(this.sceneManager.getScene());

// 3. Update in game loop
this.weatherSystem.update();
```

### Behavior Extensions
- **New Agent Types**: Extend Boid class
- **Environmental Effects**: Add to TerrainBuilder
- **Game Mechanics**: Extend GameState
- **Visual Effects**: Enhance SceneManager or create new shader systems

## Dependencies and Compatibility

### Core Dependencies
- **Three.js v0.176.0**: 3D rendering engine
- **Stats.js v0.17.0**: Performance monitoring
- **WebGL 1.0+**: Hardware acceleration requirement
- **ES6 Classes**: Modern JavaScript features

### Browser Support
- **Chrome 80+**: Full feature support
- **Firefox 75+**: Full feature support  
- **Safari 13+**: Full feature support
- **Edge 80+**: Full feature support

### Performance Requirements
- **GPU**: WebGL-capable graphics (integrated minimum)
- **RAM**: 4GB+ recommended for smooth operation
- **CPU**: Modern multi-core for 60 FPS target

## Development Workflow

### Module Development
1. **Single Responsibility**: Each module handles one aspect
2. **Clear Interfaces**: Well-defined public APIs
3. **Error Handling**: Graceful degradation
4. **Documentation**: Comprehensive inline comments

### Testing Strategy
- **Unit Testing**: Individual module validation
- **Integration Testing**: Module interaction verification
- **Performance Testing**: Frame rate and memory monitoring
- **Cross-Browser Testing**: Compatibility validation

### Code Quality
- **ES6 Standards**: Modern JavaScript practices
- **Consistent Naming**: Descriptive method and variable names
- **Modular Design**: Loose coupling, high cohesion
- **Performance Focus**: Optimization-aware development

## File Structure
```
sheep-dog/
├── index.html              # Main HTML container with enhanced UI
├── js/
│   ├── main.js             # SheepDogSimulation controller (192 lines)
│   ├── SceneManager.js     # 3D scene and rendering management (141 lines)
│   ├── TerrainBuilder.js   # Environment creation and grass system (397 lines)
│   ├── StructureBuilder.js # Game structures (fences, gates, pastures) (471 lines)
│   ├── GameState.js        # Game logic and state management (242 lines)
│   ├── GameTimer.js        # Timer system and best time tracking (181 lines)
│   ├── PerformanceMonitor.js # Real-time performance tracking (377 lines)
│   ├── StartScreen.js      # Start screen and cinematic camera (136 lines)
│   ├── StaminaUI.js        # Stamina bar UI management (105 lines)
│   ├── Boid.js             # Base flocking agent (248 lines)
│   ├── OptimizedSheep.js   # GPU-based sheep system (788 lines)
│   ├── Sheepdog.js         # Enhanced player controller with stamina (683 lines)
│   ├── InputHandler.js     # Keyboard input with pause system (182 lines)
│   └── Vector2D.js         # 2D math utilities (102 lines)
├── assets/
│   ├── images/
│   │   └── favicon.png     # Game favicon
│   └── sounds/             # Reserved for future audio assets
├── package.json            # Dependencies and scripts
├── README.md               # User documentation
└── ARCHITECTURE.md         # This document
```

## Dependencies
- **Three.js v0.176.0**: 3D rendering engine
- **Stats.js v0.17.0**: Performance monitoring (FPS, memory, custom metrics)
- **HTTP Server**: Development server (Python or Node.js, port 8000)

## Performance Characteristics
- **Target**: 60 FPS with 200 sheep + 800k grass instances
- **Bottlenecks**: Grass rendering, shadow calculations
- **Optimizations**: GPU-based sheep rendering, instanced rendering, shared resources

## Extension Points
- **New Behaviors**: Extend Boid class for different agent types
- **Environmental**: Add weather, day/night cycles via shader uniforms
- **Gameplay**: Multiple levels, different objectives, obstacles, power-ups
- **Rendering**: Enhanced materials, particle effects, post-processing
- **Audio**: Sound effects and ambient audio integration
- **UI**: Additional game modes, settings, achievements
````

## index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#00BFFF">
    <title>Sheep Dog Sim</title>
    <link rel="icon" type="image/png" href="assets/images/favicon.png">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            /* Prevent text selection on mobile */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Prevent touch callouts */
            -webkit-touch-callout: none;
            /* Prevent tap highlight */
            -webkit-tap-highlight-color: transparent;
        }
        
        #canvas-container {
            position: relative;
            width: 100%;
            height: 100vh;
            /* Prevent scrolling */
            touch-action: none;
            /* Prevent overscroll bounce on iOS */
            overscroll-behavior: none;
        }
        
        /* Prevent zoom on inputs and buttons */
        input, button, select, textarea {
            font-size: 16px;
            -webkit-appearance: none;
            border-radius: 0;
        }
        
        /* Start Screen Overlay */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
            /* Mobile safe area and scrolling */
            padding-top: max(20px, env(safe-area-inset-top));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
            padding-left: max(20px, env(safe-area-inset-left));
            padding-right: max(20px, env(safe-area-inset-right));
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        #game-title {
            font-size: 4.5rem;
            font-weight: 900;
            margin-bottom: 1rem;
            color: #00BFFF;
            font-family: 'Arial Black', Arial, sans-serif;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 3px 3px 0px #000;
        }
        
        /* Mobile responsive title */
        @media (max-width: 768px) {
            #start-screen {
                padding: 10px;
                justify-content: flex-start;
                padding-top: 5vh;
                padding-bottom: 5vh;
                min-height: 100vh;
                box-sizing: border-box;
                overflow-y: auto;
            }
            
            #game-title {
                font-size: 2.2rem;
                letter-spacing: 1px;
                margin-bottom: 0.5rem;
            }
            
            #game-subtitle {
                font-size: 0.9rem;
                margin-bottom: 1.5rem;
            }
            
            #start-instructions {
                max-width: 95%;
                padding: 1.2rem;
                margin-bottom: 1.5rem;
            }
            
            #start-instructions h3 {
                font-size: 1.1rem;
                margin-bottom: 0.8rem;
            }
            
            #start-instructions p {
                font-size: 0.85rem;
                margin: 0.6rem 0;
            }
            
            #start-button {
                padding: 15px 30px;
                font-size: 1.2rem;
                margin-top: 1rem;
                margin-bottom: 2rem;
            }
        }
        
        /* Mobile portrait adjustments */
        @media (max-width: 480px) and (orientation: portrait) {
            #start-screen {
                padding: 5px;
                justify-content: flex-start;
                padding-top: 2vh;
                padding-bottom: 3vh;
                min-height: 100vh;
                max-height: 100vh;
                overflow-y: auto;
                display: flex;
                flex-direction: column;
            }
            
            #game-title {
                font-size: 1.8rem;
                margin-bottom: 0.3rem;
            }
            
            #game-subtitle {
                font-size: 0.8rem;
                margin-bottom: 1rem;
            }
            
            #start-instructions {
                padding: 1rem;
                margin-bottom: 1rem;
                flex-shrink: 0;
            }
            
            #start-instructions h3 {
                font-size: 1rem;
            }
            
            #start-instructions p {
                font-size: 0.8rem;
                margin: 0.4rem 0;
            }
            
            #start-button {
                padding: 12px 25px;
                font-size: 1rem;
                margin-top: 1rem;
                margin-bottom: 2rem;
                flex-shrink: 0;
            }
        }
        
        /* Extra small screens - ensure everything fits */
        @media (max-width: 360px) and (max-height: 640px) {
            #start-screen {
                padding: 3px;
                padding-top: 1vh;
                padding-bottom: 2vh;
            }
            
            #game-title {
                font-size: 1.5rem;
                margin-bottom: 0.2rem;
            }
            
            #game-subtitle {
                font-size: 0.7rem;
                margin-bottom: 0.8rem;
            }
            
            #start-instructions {
                padding: 0.8rem;
                margin-bottom: 0.8rem;
            }
            
            #start-instructions h3 {
                font-size: 0.9rem;
                margin-bottom: 0.5rem;
            }
            
            #start-instructions p {
                font-size: 0.75rem;
                margin: 0.3rem 0;
            }
            
            #start-button {
                padding: 10px 20px;
                font-size: 0.9rem;
                margin-top: 0.8rem;
                margin-bottom: 1.5rem;
            }
        }
        
        /* Very short screens - ultra compact layout */
        @media (max-height: 600px) {
            #start-screen {
                padding: 2px;
                padding-top: 1vh;
                padding-bottom: 1vh;
                justify-content: space-between;
            }
            
            #game-title {
                font-size: 1.4rem;
                margin-bottom: 0.1rem;
            }
            
            #game-subtitle {
                font-size: 0.65rem;
                margin-bottom: 0.5rem;
            }
            
            #start-instructions {
                padding: 0.6rem;
                margin-bottom: 0.5rem;
            }
            
            #start-instructions h3 {
                font-size: 0.85rem;
                margin-bottom: 0.3rem;
            }
            
            #start-instructions p {
                font-size: 0.7rem;
                margin: 0.2rem 0;
                line-height: 1.2;
            }
            
            #start-button {
                padding: 8px 16px;
                font-size: 0.85rem;
                margin-top: 0.5rem;
                margin-bottom: 1rem;
            }
        }
        
        /* Landscape mobile - horizontal layout adjustments */
        @media (max-height: 500px) and (orientation: landscape) {
            #start-screen {
                flex-direction: row;
                align-items: center;
                justify-content: space-around;
                padding: 5px;
            }
            
            #start-screen > div:first-child {
                flex: 1;
                text-align: left;
            }
            
            #start-instructions {
                flex: 1;
                margin: 0 10px;
            }
            
            #start-button {
                flex-shrink: 0;
                margin: 0;
            }
        }
        
        #game-subtitle {
            font-size: 1.4rem;
            margin-bottom: 2rem;
            color: #FFF;
            font-family: Arial, sans-serif;
            font-weight: normal;
        }
        
        #start-instructions {
            background: rgba(255, 255, 255, 0.95);
            padding: 2rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            color: #333;
            border: 3px solid #00BFFF;
            max-width: 500px;
        }
        
        #start-instructions h3 {
            margin: 0 0 1rem 0;
            font-size: 1.5rem;
            color: #00BFFF;
            font-family: 'Arial Black', Arial, sans-serif;
            font-weight: 900;
        }
        
        #start-instructions p {
            margin: 0.8rem 0;
            font-size: 1rem;
            line-height: 1.4;
            font-family: Arial, sans-serif;
            color: #333;
        }
        
        #start-button {
            background: #00BFFF;
            border: 3px solid #FFF;
            color: #FFF;
            padding: 20px 40px;
            font-size: 1.5rem;
            font-weight: 900;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-family: 'Arial Black', Arial, sans-serif;
            text-shadow: 2px 2px 0px #000;
            /* Mobile touch improvements */
            min-height: 44px;
            min-width: 44px;
            /* Ensure button is always accessible */
            margin-bottom: max(20px, env(safe-area-inset-bottom, 20px));
            flex-shrink: 0;
        }
        
        #start-button:hover {
            background: #FFF;
            color: #00BFFF;
            border: 3px solid #00BFFF;
            text-shadow: none;
        }
        
        #start-button:active {
            transform: translateY(2px);
        }
        
        /* Mute Toggle in Controls */
        #mute-toggle {
            margin: 5px 0;
            font-size: 14px;
            color: #333;
            cursor: pointer;
            user-select: none;
            transition: color 0.2s ease;
        }
        
        #mute-toggle:hover {
            color: #00BFFF;
        }
        
        #mute-toggle.muted {
            color: #FF6B35;
        }
        
        /* Game UI Elements - Clean style */
        .game-ui {
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .game-ui.visible {
            opacity: 1;
        }
        
        /* Stats hidden by default */
        #stats {
            display: none;
        }
        
        #stats.visible {
            display: block;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00BFFF;
            font-family: Arial, sans-serif;
            /* Mobile adjustments */
            max-width: calc(100vw - 160px);
            z-index: 999;
        }
        
        /* Mobile responsive instructions */
        @media (max-width: 768px) {
            #instructions {
                bottom: 10px;
                left: 10px;
                right: 10px;
                max-width: none;
                padding: 10px;
                font-size: 12px;
            }
            
            #instructions h3 {
                font-size: 14px;
                margin-bottom: 8px;
            }
            
            #instructions p {
                margin: 3px 0;
                font-size: 11px;
            }
        }
        
        #instructions h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #00BFFF;
            font-weight: 900;
        }
        
        #instructions p {
            margin: 5px 0;
            font-size: 14px;
            color: #333;
        }
        
        #completion-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            color: #333;
            padding: 30px 50px;
            border-radius: 8px;
            font-size: 24px;
            font-weight: 900;
            display: none;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            text-align: center;
            line-height: 1.4;
            border: 4px solid #00BFFF;
            font-family: 'Arial Black', Arial, sans-serif;
            z-index: 1002;
            max-width: 90vw;
            box-sizing: border-box;
        }
        
        /* Mobile responsive completion message */
        @media (max-width: 768px) {
            #completion-message {
                padding: 20px 30px;
                font-size: 18px;
            }
        }
        
        #restart-button {
            background: #00BFFF;
            border: 2px solid #333;
            color: white;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 900;
            cursor: pointer;
            margin-top: 15px;
            transition: all 0.2s ease;
            font-family: 'Arial Black', Arial, sans-serif;
            text-transform: uppercase;
            /* Mobile touch improvements */
            min-height: 44px;
            min-width: 44px;
        }
        
        #restart-button:hover {
            background: #333;
            border: 2px solid #00BFFF;
        }
        
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            border: 2px solid #00BFFF;
            font-family: Arial, sans-serif;
            font-weight: bold;
            color: #333;
            z-index: 999;
        }
        
        #timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 900;
            text-align: center;
            border: 2px solid #00BFFF;
            font-family: 'Arial Black', Arial, sans-serif;
            z-index: 999;
        }
        
        /* Combined mobile UI for timer and sheep count */
        #mobile-combined-ui {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 900;
            text-align: center;
            border: 2px solid #00BFFF;
            font-family: 'Arial Black', Arial, sans-serif;
            z-index: 999;
            display: none;
            min-width: 200px;
        }
        
        #mobile-timer-display {
            color: #00BFFF;
            font-size: 16px;
            margin-bottom: 2px;
        }
        
        #mobile-sheep-count {
            font-size: 12px;
            color: #333;
            margin-bottom: 2px;
        }
        
        #mobile-best-time {
            font-size: 10px;
            color: #666;
            font-weight: normal;
            font-family: Arial, sans-serif;
        }
        
        /* Mobile responsive timer */
        @media (max-width: 768px) {
            #timer {
                display: none; /* Hide desktop timer on mobile */
            }
            
            #stats {
                display: none !important; /* Hide desktop stats on mobile */
            }
            
            #mobile-combined-ui {
                display: block; /* Show combined UI on mobile */
            }
            
            #timer.desktop-only {
                top: 10px;
                padding: 10px 15px;
                font-size: 14px;
            }
            
            #timer-display {
                font-size: 16px;
            }
            
            #best-time {
                font-size: 10px;
            }
        }
        
        #timer-display {
            color: #00BFFF;
            margin-bottom: 5px;
            font-size: 20px;
        }
        
        #best-time {
            font-size: 12px;
            color: #666;
            font-weight: normal;
            font-family: Arial, sans-serif;
        }
        
        .new-record {
            color: #FF6B35 !important;
            animation: recordFlash 1s ease-in-out infinite alternate;
        }
        
        @keyframes recordFlash {
            from { opacity: 1; }
            to { opacity: 0.7; }
        }
        
        /* Stamina Bar */
        #stamina-bar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #00BFFF;
            font-family: Arial, sans-serif;
            min-width: 200px;
            z-index: 999;
        }
        
        /* Mobile responsive stamina bar */
        @media (max-width: 768px) {
            #stamina-bar {
                bottom: 100px;
                left: 50%;
                transform: translateX(-50%);
                right: auto;
                min-width: 180px;
                padding: 8px 12px;
            }
            
            #stamina-label {
                font-size: 12px;
            }
            
            #stamina-container {
                height: 16px;
            }
            
            #stamina-text {
                font-size: 10px;
            }
        }
        
        /* Landscape mobile - ensure centered layout */
        @media (max-width: 768px) and (orientation: landscape) {
            #stamina-bar {
                bottom: 80px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                right: auto !important;
                min-width: 200px !important;
                padding: 8px 12px !important;
            }
            
            #mobile-combined-ui {
                display: block !important;
                top: 10px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                min-width: 280px !important;
                padding: 8px 20px !important;
                font-size: 12px !important;
            }
            
            /* Hide desktop timer and stats in landscape */
            #timer {
                display: none !important;
            }
            
            #stats {
                display: none !important;
            }
        }
        
        #stamina-label {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            text-align: center;
        }
        
        #stamina-container {
            width: 100%;
            height: 20px;
            background: #ddd;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #999;
            margin-bottom: 5px;
        }
        
        #stamina-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            border-radius: 10px;
            transition: width 0.2s ease, background 0.3s ease;
            width: 100%;
        }
        
        #stamina-fill.low {
            background: linear-gradient(90deg, #FF9800, #FFC107);
        }
        
        #stamina-fill.critical {
            background: linear-gradient(90deg, #F44336, #FF5722);
            animation: staminaPulse 0.5s ease-in-out infinite alternate;
        }
        
        #stamina-fill.sprinting {
            background: linear-gradient(90deg, #2196F3, #03A9F4);
            animation: staminaDrain 0.3s ease-in-out infinite alternate;
        }
        
        #stamina-text {
            font-size: 12px;
            color: #666;
            text-align: center;
            font-weight: bold;
        }
        
        @keyframes staminaPulse {
            from { opacity: 1; }
            to { opacity: 0.6; }
        }
        
        @keyframes staminaDrain {
            from { transform: scaleX(1); }
            to { transform: scaleX(0.98); }
        }
        
        /* Mobile Controls Styles */
        #mobile-joystick {
            pointer-events: auto !important;
        }
        
        #mobile-zoom {
            pointer-events: auto !important;
        }
        
        #mobile-sprint {
            pointer-events: auto !important;
        }
        
        /* Mobile Fullscreen Button */
        #mobile-fullscreen {
            position: fixed !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            width: 160px !important;
            height: 80px !important;
            border-radius: 12px !important;
            background: rgba(0, 191, 255, 0.95) !important;
            border: 3px solid white !important;
            color: white !important;
            font-size: 24px !important;
            font-weight: bold !important;
            z-index: 2000 !important;
            display: block !important;
            pointer-events: auto !important;
            box-shadow: 0 6px 12px rgba(0,0,0,0.4) !important;
            transition: all 0.3s ease !important;
            user-select: none !important;
            -webkit-user-select: none !important;
            -webkit-touch-callout: none !important;
            font-family: Arial, sans-serif !important;
            text-align: center !important;
            line-height: 1.2 !important;
            cursor: pointer !important;
            /* Ensure it's above everything */
            position: fixed !important;
        }
        
        #mobile-fullscreen:active {
            transform: translate(-50%, -50%) scale(0.95) !important;
            background: rgba(0, 150, 200, 0.95) !important;
        }
        
        /* Ensure mobile controls are above other UI elements */
        #mobile-joystick,
        #mobile-zoom,
        #mobile-sprint {
            z-index: 1001 !important;
        }
        
        /* Hide desktop-only UI elements on mobile */
        @media (max-width: 768px) and (pointer: coarse) {
            #instructions p:contains("Mouse Wheel"),
            #instructions p:contains("P") {
                display: none;
            }
            
            /* Ensure stats are completely hidden on mobile */
            #stats,
            #stats.visible,
            #stats.game-ui {
                display: none !important;
            }
        }
        
        /* Additional fullscreen mobile adjustments */
        @media (max-width: 768px) {
            /* Ensure proper spacing between UI elements in fullscreen */
            body:fullscreen #mobile-combined-ui,
            body:-webkit-full-screen #mobile-combined-ui,
            body:-moz-full-screen #mobile-combined-ui,
            body:-ms-fullscreen #mobile-combined-ui {
                z-index: 1002;
            }
            
            body:fullscreen #stamina-bar,
            body:-webkit-full-screen #stamina-bar,
            body:-moz-full-screen #stamina-bar,
            body:-ms-fullscreen #stamina-bar {
                z-index: 1002;
            }
            
            /* Ensure mobile controls don't overlap with centered UI */
            body:fullscreen #mobile-joystick,
            body:-webkit-full-screen #mobile-joystick,
            body:-moz-full-screen #mobile-joystick,
            body:-ms-fullscreen #mobile-joystick {
                z-index: 1001;
            }
            
            body:fullscreen #mobile-zoom,
            body:-webkit-full-screen #mobile-zoom,
            body:-moz-full-screen #mobile-zoom,
            body:-ms-fullscreen #mobile-zoom {
                z-index: 1001;
            }
            
            body:fullscreen #mobile-sprint,
            body:-webkit-full-screen #mobile-sprint,
            body:-moz-full-screen #mobile-sprint,
            body:-ms-fullscreen #mobile-sprint {
                z-index: 1001;
            }
        }
        
        /* Portrait fullscreen specific adjustments */
        @media (max-width: 768px) and (orientation: portrait) {
            body:fullscreen #stamina-bar,
            body:-webkit-full-screen #stamina-bar,
            body:-moz-full-screen #stamina-bar,
            body:-ms-fullscreen #stamina-bar {
                bottom: 140px;
                min-width: 200px;
            }
            
            body:fullscreen #mobile-combined-ui,
            body:-webkit-full-screen #mobile-combined-ui,
            body:-moz-full-screen #mobile-combined-ui,
            body:-ms-fullscreen #mobile-combined-ui {
                top: 20px;
                min-width: 260px;
                padding: 15px 30px;
            }
        }
        
        /* Fullscreen landscape specific */
        @media (max-width: 768px) and (orientation: landscape) {
            body:fullscreen #stamina-bar,
            body:-webkit-full-screen #stamina-bar,
            body:-moz-full-screen #stamina-bar,
            body:-ms-fullscreen #stamina-bar {
                bottom: 80px !important;
                top: auto !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                right: auto !important;
                min-width: 200px !important;
                padding: 8px 12px !important;
            }
            
            body:fullscreen #mobile-combined-ui,
            body:-webkit-full-screen #mobile-combined-ui,
            body:-moz-full-screen #mobile-combined-ui,
            body:-ms-fullscreen #mobile-combined-ui {
                display: block !important;
                top: 10px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                padding: 8px 20px !important;
                min-width: 280px !important;
                font-size: 12px !important;
            }
            
            body:fullscreen #timer,
            body:-webkit-full-screen #timer,
            body:-moz-full-screen #timer,
            body:-ms-fullscreen #timer,
            body:fullscreen #stats,
            body:-webkit-full-screen #stats,
            body:-moz-full-screen #stats,
            body:-ms-fullscreen #stats {
                display: none !important;
            }
        }
        
        /* Alternative fullscreen targeting using class */
        @media (max-width: 768px) { /* General rules for .mobile-fullscreen */
            body.mobile-fullscreen #stamina-bar {
                left: 50% !important;
                transform: translateX(-50%) !important;
                right: auto !important;
                /* top/bottom will be set by orientation-specific .mobile-fullscreen rules */
                min-width: 200px !important; 
                padding: 10px 15px !important; 
                z-index: 1002 !important;
            }
            
            body.mobile-fullscreen #mobile-combined-ui {
                display: block !important; /* Crucial for visibility */
                left: 50% !important;
                transform: translateX(-50%) !important;
                /* top will be set by orientation-specific .mobile-fullscreen rules */
                min-width: 250px !important; 
                padding: 12px 25px !important; 
                z-index: 1002 !important;
            }
            
            body.mobile-fullscreen #timer,
            body.mobile-fullscreen #stats {
                display: none !important; /* Hide desktop elements */
            }
        }
        
        /* Landscape fullscreen with class - specific positioning */
        @media (max-width: 768px) and (orientation: landscape) {
            body.mobile-fullscreen #stamina-bar {
                bottom: 80px !important;
                min-width: 200px !important; 
                padding: 8px 12px !important; 
            }
            
            body.mobile-fullscreen #mobile-combined-ui {
                top: 10px !important;
                min-width: 280px !important; 
                padding: 8px 20px !important;
                font-size: 12px !important;
            }
        }
        
        /* Portrait fullscreen with class - specific positioning */
        @media (max-width: 768px) and (orientation: portrait) {
            body.mobile-fullscreen #stamina-bar {
                bottom: 140px !important;
            }
            
            body.mobile-fullscreen #mobile-combined-ui {
                top: 20px !important;
                min-width: 260px !important;
                padding: 15px 30px !important;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <!-- Start Screen Overlay -->
        <div id="start-screen">
            <h1 id="game-title">Sheep Dog Simulator</h1>
            <p id="game-subtitle">Guide 200 sheep to safety in this immersive 3D herding experience</p>
            
            <div id="start-instructions">
                <h3>How to Play</h3>
                <p>🐕 Use <strong>WASD</strong> or <strong>touch controls</strong> to move your sheepdog</p>
                <p>🏃 Hold <strong>Shift</strong> or <strong>sprint button</strong> to run faster</p>
                <p>🐑 Herd all 200 sheep through the golden gate into the pasture</p>
                <p>⏱️ Complete the challenge as quickly as possible</p>
                <p>🎯 Sheep will flee from you and flock together naturally</p>
                <p id="music-note" style="font-style: italic; color: #666; margin-top: 1rem;">🎵 Click anywhere to enable music</p>
            </div>
            
            <button id="start-button">Start Herding</button>
        </div>
        
        <!-- Game UI Elements -->
        <div id="instructions" class="game-ui">
            <h3>Controls</h3>
            <p><strong>W</strong> - Move Forward</p>
            <p><strong>A</strong> - Move Left</p>
            <p><strong>S</strong> - Move Backward</p>
            <p><strong>D</strong> - Move Right</p>
            <p><strong>Shift</strong> - Sprint (uses stamina)</p>
            <p><strong>Mouse Wheel</strong> - Zoom In/Out</p>
            <p><strong>P</strong> - Toggle Performance Stats</p>
            <p id="mute-toggle">🔊 <strong>Click</strong> - Toggle Sound</p>
        </div>
        
        <div id="timer" class="game-ui">
            <div id="timer-display">00:00</div>
            <div id="best-time">Best: --:--</div>
        </div>
        
        <!-- Combined Mobile UI for timer and sheep count -->
        <div id="mobile-combined-ui" class="game-ui">
            <div id="mobile-timer-display">00:00</div>
            <div id="mobile-sheep-count">Sheep: 0 / 200</div>
            <div id="mobile-best-time">Best: --:--</div>
        </div>
        
        <div id="stats" class="game-ui">
            <p>Sheep Secured: <span id="sheep-count">0</span> / 200</p>
        </div>
        
        <div id="stamina-bar" class="game-ui">
            <div id="stamina-label">Stamina</div>
            <div id="stamina-container">
                <div id="stamina-fill"></div>
            </div>
            <div id="stamina-text">100%</div>
        </div>
        
        <div id="completion-message">
            All sheep successfully herded!
        </div>
    </div>
    
    <!-- Import map for Three.js r176 -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/",
            "stats.js": "https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"
        }
    }
    </script>
    
    <!-- Main application entry point -->
    <script type="module" src="js/main.js"></script>
</body>
</html>
```

## js/AudioManager.js

```javascript
import * as THREE from 'three';

/**
 * AudioManager - Handles all game audio with Three.js audio system
 * Provides simple interface for playing sounds with proper 3D audio support
 */
export class AudioManager {
    constructor(camera) {
        // Create audio listener and attach to camera
        this.listener = new THREE.AudioListener();
        camera.add(this.listener);
        
        // Audio loader
        this.loader = new THREE.AudioLoader();
        
        // Audio objects for each sound
        this.sounds = {
            uiClick: null,
            rewardingChime: null,
            sheepBleat: null,
            sheepdogBark: null
        };
        
        // Music tracks
        this.music = {
            startMusic: null,
            gameplay1: null,
            gameplay2: null,
            gameplay3: null,
            winMusic: null
        };
        
        // Track loading state
        this.isLoaded = false;
        this.musicLoaded = false;
        this.loadingPromises = [];
        this.musicLoadingPromises = [];
        
        // Volume settings
        this.masterVolume = 0.7;
        this.sfxVolume = 0.8;
        this.musicVolume = 0.5;
        
        // Mute state
        this.isMuted = false;
        this.currentMusic = null; // Track currently playing music
        
        // Cooldown tracking to prevent sound spam
        this.lastPlayTimes = {
            sheepBleat: 0,
            sheepdogBark: 0
        };
        this.cooldowns = {
            sheepBleat: 500, // 500ms cooldown
            sheepdogBark: 300 // 300ms cooldown
        };
        
        // Load mute preference from localStorage
        this.loadMutePreference();
        
        this.loadSounds();
        this.loadMusic();
    }
    
    /**
     * Load all sound files
     */
    loadSounds() {
        const soundFiles = {
            uiClick: 'assets/sounds/11L-clean_UI_click,_wood-1748393658157.mp3',
            rewardingChime: 'assets/sounds/11L-short_rewarding_chim-1748393597911.mp3',
            sheepBleat: 'assets/sounds/11L-agitated_sheep_bleat-1748393501154.mp3',
            sheepdogBark: 'assets/sounds/11L-short_sharp_sheep_do-1748393459422.mp3'
        };
        
        // Load each sound
        Object.keys(soundFiles).forEach(soundKey => {
            const promise = new Promise((resolve, reject) => {
                this.loader.load(
                    soundFiles[soundKey],
                    (buffer) => {
                        // Create Audio object
                        this.sounds[soundKey] = new THREE.Audio(this.listener);
                        this.sounds[soundKey].setBuffer(buffer);
                        this.sounds[soundKey].setVolume(this.masterVolume * this.sfxVolume);
                        
                        console.log(`Loaded sound: ${soundKey}`);
                        resolve();
                    },
                    (progress) => {
                        // Loading progress
                    },
                    (error) => {
                        console.warn(`Failed to load sound ${soundKey}:`, error);
                        // Create a dummy audio object to prevent errors
                        this.sounds[soundKey] = { 
                            play: () => {}, 
                            stop: () => {}, 
                            isPlaying: false 
                        };
                        resolve(); // Resolve anyway to not block other sounds
                    }
                );
            });
            
            this.loadingPromises.push(promise);
        });
        
        // Wait for all sounds to load
        Promise.all(this.loadingPromises).then(() => {
            this.isLoaded = true;
            console.log('All sounds loaded successfully');
        }).catch((error) => {
            console.warn('Some sounds failed to load:', error);
            this.isLoaded = true; // Still mark as loaded to allow game to continue
        });
    }
    
    /**
     * Load all music files
     */
    loadMusic() {
        const musicFiles = {
            startMusic: 'assets/sounds/SDS Start Music.wav',
            gameplay1: 'assets/sounds/SDS1.wav',
            gameplay2: 'assets/sounds/SDS2.wav',
            gameplay3: 'assets/sounds/SDS3.wav',
            winMusic: 'assets/sounds/win.wav'
        };
        
        // Load each music track
        Object.keys(musicFiles).forEach(musicKey => {
            const promise = new Promise((resolve, reject) => {
                this.loader.load(
                    musicFiles[musicKey],
                    (buffer) => {
                        // Create Audio object
                        this.music[musicKey] = new THREE.Audio(this.listener);
                        this.music[musicKey].setBuffer(buffer);
                        this.music[musicKey].setVolume(this.masterVolume * this.musicVolume);
                        this.music[musicKey].setLoop(true); // Most music should loop
                        
                        console.log(`Loaded music: ${musicKey}`);
                        resolve();
                    },
                    (progress) => {
                        // Loading progress
                        console.log(`Loading music ${musicKey}: ${Math.round(progress.loaded / progress.total * 100)}%`);
                    },
                    (error) => {
                        console.warn(`Failed to load music ${musicKey}:`, error);
                        // Create a dummy audio object to prevent errors
                        this.music[musicKey] = { 
                            play: () => {}, 
                            stop: () => {}, 
                            pause: () => {},
                            setLoop: () => {},
                            setVolume: () => {},
                            isPlaying: false 
                        };
                        resolve(); // Resolve anyway to not block other music
                    }
                );
            });
            
            this.musicLoadingPromises.push(promise);
        });
        
        // Wait for all music to load
        Promise.all(this.musicLoadingPromises).then(() => {
            this.musicLoaded = true;
            console.log('All music loaded successfully');
            
            // Apply mute state to music
            this.updateAllVolumes();
            
            // Set up user interaction listener to start audio context
            this.setupAudioContextActivation();
        }).catch((error) => {
            console.warn('Some music failed to load:', error);
            this.musicLoaded = true; // Still mark as loaded to allow game to continue
        });
    }
    
    /**
     * Play UI click sound
     */
    playUIClick() {
        if (this.sounds.uiClick && !this.sounds.uiClick.isPlaying) {
            this.sounds.uiClick.play();
        }
    }
    
    /**
     * Play rewarding chime sound (for sheep passing gate or game completion)
     */
    playRewardingChime() {
        if (this.sounds.rewardingChime && !this.sounds.rewardingChime.isPlaying) {
            this.sounds.rewardingChime.play();
        }
    }
    
    /**
     * Play sheep bleat sound with cooldown to prevent spam
     */
    playSheepBleat() {
        const now = Date.now();
        if (now - this.lastPlayTimes.sheepBleat < this.cooldowns.sheepBleat) {
            return; // Still in cooldown
        }
        
        if (this.sounds.sheepBleat && !this.sounds.sheepBleat.isPlaying) {
            this.sounds.sheepBleat.play();
            this.lastPlayTimes.sheepBleat = now;
        }
    }
    
    /**
     * Play multiple layered sheep bleats for group herding
     * @param {number} sheepCount - Number of sheep being chased (1-5 max for audio clarity)
     */
    playGroupSheepBleats(sheepCount) {
        const now = Date.now();
        if (now - this.lastPlayTimes.sheepBleat < this.cooldowns.sheepBleat) {
            return; // Still in cooldown
        }
        
        // Limit to 5 simultaneous bleats for audio clarity
        const maxBleats = Math.min(sheepCount, 5);
        
        // Play first bleat immediately
        if (this.sounds.sheepBleat) {
            this.sounds.sheepBleat.play();
        }
        
        // Schedule additional bleats with staggered timing
        for (let i = 1; i < maxBleats; i++) {
            setTimeout(() => {
                if (this.sounds.sheepBleat) {
                    // Create a new audio instance for overlapping sounds
                    const additionalBleat = new THREE.Audio(this.listener);
                    additionalBleat.setBuffer(this.sounds.sheepBleat.buffer);
                    additionalBleat.setVolume(this.masterVolume * this.sfxVolume * (0.7 + Math.random() * 0.3)); // Slight volume variation
                    additionalBleat.play();
                }
            }, i * (100 + Math.random() * 150)); // 100-250ms staggered delays
        }
        
        this.lastPlayTimes.sheepBleat = now;
    }
    
    /**
     * Play sheepdog bark sound with cooldown
     */
    playSheepdogBark() {
        const now = Date.now();
        if (now - this.lastPlayTimes.sheepdogBark < this.cooldowns.sheepdogBark) {
            return; // Still in cooldown
        }
        
        if (this.sounds.sheepdogBark && !this.sounds.sheepdogBark.isPlaying) {
            this.sounds.sheepdogBark.play();
            this.lastPlayTimes.sheepdogBark = now;
        }
    }
    
    /**
     * Play start screen music
     */
    playStartMusic() {
        if (this.music.startMusic && !this.music.startMusic.isPlaying) {
            this.stopAllMusic();
            this.currentMusic = this.music.startMusic;
            this.music.startMusic.play();
        }
    }
    
    /**
     * Play random gameplay background music
     */
    playGameplayMusic() {
        const gameplayTracks = [this.music.gameplay1, this.music.gameplay2, this.music.gameplay3];
        const randomTrack = gameplayTracks[Math.floor(Math.random() * gameplayTracks.length)];
        
        if (randomTrack && !randomTrack.isPlaying) {
            this.stopAllMusic();
            this.currentMusic = randomTrack;
            randomTrack.play();
        }
    }
    
    /**
     * Play win music (doesn't loop)
     */
    playWinMusic() {
        if (this.music.winMusic) {
            this.stopAllMusic();
            this.currentMusic = this.music.winMusic;
            this.music.winMusic.setLoop(false); // Win music plays once
            this.music.winMusic.play();
        }
    }
    
    /**
     * Stop all music
     */
    stopAllMusic() {
        Object.values(this.music).forEach(track => {
            if (track && track.isPlaying) {
                track.stop();
            }
        });
        this.currentMusic = null;
    }
    
    /**
     * Fade out current music (smooth transition)
     */
    fadeOutCurrentMusic(duration = 1000) {
        if (!this.currentMusic || !this.currentMusic.isPlaying) return;
        
        const startVolume = this.currentMusic.getVolume();
        const fadeSteps = 20;
        const stepDuration = duration / fadeSteps;
        const volumeStep = startVolume / fadeSteps;
        
        let currentStep = 0;
        const fadeInterval = setInterval(() => {
            currentStep++;
            const newVolume = startVolume - (volumeStep * currentStep);
            
            if (currentStep >= fadeSteps || newVolume <= 0) {
                this.currentMusic.stop();
                this.currentMusic.setVolume(startVolume); // Reset volume for next play
                this.currentMusic = null;
                clearInterval(fadeInterval);
            } else {
                this.currentMusic.setVolume(newVolume);
            }
        }, stepDuration);
    }
    
    /**
     * Set master volume (0.0 to 1.0)
     */
    setMasterVolume(volume) {
        this.masterVolume = Math.max(0, Math.min(1, volume));
        this.updateAllVolumes();
    }
    
    /**
     * Set SFX volume (0.0 to 1.0)
     */
    setSFXVolume(volume) {
        this.sfxVolume = Math.max(0, Math.min(1, volume));
        this.updateAllVolumes();
    }
    
    /**
     * Set music volume (0.0 to 1.0)
     */
    setMusicVolume(volume) {
        this.musicVolume = Math.max(0, Math.min(1, volume));
        this.updateAllVolumes();
    }
    
    /**
     * Toggle mute state
     */
    toggleMute() {
        this.isMuted = !this.isMuted;
        this.updateAllVolumes();
        this.saveMutePreference();
        return this.isMuted;
    }
    
    /**
     * Set mute state
     */
    setMuted(muted) {
        this.isMuted = muted;
        this.updateAllVolumes();
        this.saveMutePreference();
    }
    
    /**
     * Get current mute state
     */
    isMutedState() {
        return this.isMuted;
    }
    
    /**
     * Load mute preference from localStorage
     */
    loadMutePreference() {
        try {
            const saved = localStorage.getItem('sheepdog-muted');
            if (saved !== null) {
                this.isMuted = JSON.parse(saved);
            }
        } catch (error) {
            console.warn('Failed to load mute preference:', error);
            this.isMuted = false;
        }
    }
    
    /**
     * Save mute preference to localStorage
     */
    saveMutePreference() {
        try {
            localStorage.setItem('sheepdog-muted', JSON.stringify(this.isMuted));
        } catch (error) {
            console.warn('Failed to save mute preference:', error);
        }
    }
    
    /**
     * Update volume for all loaded sounds and music
     */
    updateAllVolumes() {
        const effectiveVolume = this.isMuted ? 0 : this.masterVolume;
        const finalSFXVolume = effectiveVolume * this.sfxVolume;
        const finalMusicVolume = effectiveVolume * this.musicVolume;
        
        // Update sound effects
        Object.values(this.sounds).forEach(sound => {
            if (sound && sound.setVolume) {
                sound.setVolume(finalSFXVolume);
            }
        });
        
        // Update music
        Object.values(this.music).forEach(track => {
            if (track && track.setVolume) {
                track.setVolume(finalMusicVolume);
            }
        });
    }
    
    /**
     * Stop all currently playing sounds
     */
    stopAllSounds() {
        Object.values(this.sounds).forEach(sound => {
            if (sound && sound.isPlaying) {
                sound.stop();
            }
        });
    }
    
    /**
     * Check if audio system is ready
     */
    isReady() {
        return this.isLoaded;
    }
    
    /**
     * Check if music system is ready
     */
    isMusicReady() {
        return this.musicLoaded;
    }
    
    /**
     * Set up audio context activation on user interaction
     */
    setupAudioContextActivation() {
        this.audioContextActivated = false;
        
        const activateAudio = (event) => {
            if (this.listener.context.state === 'suspended') {
                this.listener.context.resume().then(() => {
                    console.log('Audio context activated');
                    this.audioContextActivated = true;
                    
                    // Only start music if this wasn't the start button click
                    const isStartButton = event.target && (
                        event.target.id === 'start-button' || 
                        event.target.closest('#start-button')
                    );
                    
                    if (this.musicLoaded && !this.currentMusic && !isStartButton) {
                        this.playStartMusic();
                    }
                });
            } else {
                this.audioContextActivated = true;
            }
            
            // Remove listeners after first activation
            document.removeEventListener('click', activateAudio);
            document.removeEventListener('keydown', activateAudio);
        };
        
        // Listen for any user interaction
        document.addEventListener('click', activateAudio);
        document.addEventListener('keydown', activateAudio);
    }
    
    /**
     * Manually trigger start music (for delayed start)
     */
    triggerStartMusic() {
        if (this.musicLoaded && !this.currentMusic && this.audioContextActivated) {
            this.playStartMusic();
        }
    }
    
    /**
     * Get audio context state (for debugging)
     */
    getAudioContextState() {
        return this.listener.context.state;
    }
}
```

## js/Boid.js

```javascript
import { Vector2D } from './Vector2D.js';

/**
 * Base Boid class implementing flocking behavior
 */
export class Boid {
    constructor(x, z, config = {}) {
        this.position = new Vector2D(x, z);
        this.velocity = Vector2D.random();
        this.acceleration = new Vector2D(0, 0);
        
        // Configuration
        this.maxSpeed = config.maxSpeed || 1.5;
        this.maxForce = config.maxForce || 0.05;
        this.perceptionRadius = config.perceptionRadius || 5;
        
        // Behavior weights
        this.separationWeight = config.separationWeight || 1.5;
        this.alignmentWeight = config.alignmentWeight || 1.0;
        this.cohesionWeight = config.cohesionWeight || 1.0;
        
        // Anti-jittering properties
        this.previousVelocity = this.velocity.clone();
        this.velocitySmoothing = 0.85; // Higher = more smoothing
        this.minMovementThreshold = 0.001; // Minimum velocity to prevent micro-movements
        this.forceAccumulator = new Vector2D(0, 0);
        this.dampingFactor = 0.98; // Velocity damping to reduce oscillations
        
        // Visual representation
        this.mesh = null;
    }

    // Apply a force to the boid with smoothing
    applyForce(force) {
        // Accumulate forces instead of applying directly
        this.forceAccumulator.add(force);
    }

    // Main flocking behavior
    flock(boids, separationDistance) {
        const neighbors = this.getNeighbors(boids);
        
        if (neighbors.length > 0) {
            // Calculate flocking forces
            const separation = this.separate(neighbors, separationDistance);
            const alignment = this.align(neighbors);
            const cohesion = this.cohere(neighbors);
            
            // Weight and apply forces
            separation.multiply(this.separationWeight);
            alignment.multiply(this.alignmentWeight);
            cohesion.multiply(this.cohesionWeight);
            
            this.applyForce(separation);
            this.applyForce(alignment);
            this.applyForce(cohesion);
        }
    }

    // Separation: steer to avoid crowding local flockmates
    separate(neighbors, desiredSeparation) {
        const steer = new Vector2D(0, 0);
        let count = 0;

        for (let neighbor of neighbors) {
            const distance = this.position.distanceTo(neighbor.position);
            
            if (distance > 0 && distance < desiredSeparation) {
                // Calculate vector pointing away from neighbor
                const diff = this.position.clone().subtract(neighbor.position);
                diff.normalize();
                diff.divide(distance); // Weight by distance (closer = stronger)
                steer.add(diff);
                count++;
            }
        }

        if (count > 0) {
            steer.divide(count);
            steer.normalize();
            steer.multiply(this.maxSpeed);
            steer.subtract(this.velocity);
            steer.limit(this.maxForce);
        }

        return steer;
    }

    // Alignment: steer towards the average heading of local flockmates
    align(neighbors) {
        const sum = new Vector2D(0, 0);
        
        for (let neighbor of neighbors) {
            sum.add(neighbor.velocity);
        }
        
        sum.divide(neighbors.length);
        sum.normalize();
        sum.multiply(this.maxSpeed);
        
        const steer = sum.subtract(this.velocity);
        steer.limit(this.maxForce);
        
        return steer;
    }

    // Cohesion: steer to move toward the average position of local flockmates
    cohere(neighbors) {
        const sum = new Vector2D(0, 0);
        
        for (let neighbor of neighbors) {
            sum.add(neighbor.position);
        }
        
        sum.divide(neighbors.length);
        return this.seek(sum);
    }

    // Seek a target position
    seek(target) {
        const desired = target.clone().subtract(this.position);
        desired.normalize();
        desired.multiply(this.maxSpeed);
        
        const steer = desired.subtract(this.velocity);
        steer.limit(this.maxForce);
        
        return steer;
    }

    // Flee from a target position
    flee(target, fleeRadius = 10) {
        const distance = this.position.distanceTo(target);
        
        if (distance < fleeRadius) {
            const desired = this.position.clone().subtract(target);
            desired.normalize();
            desired.multiply(this.maxSpeed);
            
            const steer = desired.subtract(this.velocity);
            steer.limit(this.maxForce * 2); // Stronger flee force
            
            return steer;
        }
        
        return new Vector2D(0, 0);
    }

    // Boundary avoidance
    avoidBoundaries(bounds) {
        const margin = 10; // Increased margin for earlier activation
        const steer = new Vector2D(0, 0);
        const position = this.position;
        
        // Calculate distances to boundaries
        const distToMinX = position.x - bounds.minX;
        const distToMaxX = bounds.maxX - position.x;
        const distToMinZ = position.z - bounds.minZ;
        const distToMaxZ = bounds.maxZ - position.z;
        
        // Apply repulsion force based on proximity to boundary (reduced multipliers)
        if (distToMinX < margin) {
            const force = (margin - distToMinX) / margin;
            steer.x = this.maxSpeed * force * 1.2; // Reduced from 2
        } else if (distToMaxX < margin) {
            const force = (margin - distToMaxX) / margin;
            steer.x = -this.maxSpeed * force * 1.2;
        }
        
        if (distToMinZ < margin) {
            const force = (margin - distToMinZ) / margin;
            steer.z = this.maxSpeed * force * 1.2;
        } else if (distToMaxZ < margin) {
            const force = (margin - distToMaxZ) / margin;
            steer.z = -this.maxSpeed * force * 1.2;
        }
        
        if (steer.magnitude() > 0) {
            steer.normalize();
            steer.multiply(this.maxSpeed * 1.5); // Reduced from 2
            steer.subtract(this.velocity);
            steer.limit(this.maxForce * 2.5); // Reduced from 5
        }
        
        return steer;
    }

    // Get neighboring boids within perception radius
    getNeighbors(boids) {
        const neighbors = [];
        
        for (let boid of boids) {
            if (boid !== this) {
                const distance = this.position.distanceTo(boid.position);
                if (distance < this.perceptionRadius) {
                    neighbors.push(boid);
                }
            }
        }
        
        return neighbors;
    }

    // Update position based on velocity and acceleration
    update(deltaTime = 0.016) {
        // Apply accumulated forces to acceleration with damping
        this.acceleration.add(this.forceAccumulator);
        this.forceAccumulator.multiply(0); // Reset force accumulator
        
        // Store previous velocity for smoothing
        this.previousVelocity = this.velocity.clone();
        
        // Update velocity
        this.velocity.add(this.acceleration);
        this.velocity.limit(this.maxSpeed);
        
        // Apply velocity damping to reduce oscillations
        this.velocity.multiply(this.dampingFactor);
        
        // Smooth velocity with previous velocity to reduce jittering
        const smoothedVelocity = this.previousVelocity.clone()
            .multiply(this.velocitySmoothing)
            .add(this.velocity.clone().multiply(1 - this.velocitySmoothing));
        
        // Only apply movement if above threshold to prevent micro-movements
        if (smoothedVelocity.magnitude() > this.minMovementThreshold) {
            this.velocity = smoothedVelocity;
            this.position.add(this.velocity);
        } else {
            // Stop micro-movements
            this.velocity.multiply(0);
        }
        
        // Reset acceleration
        this.acceleration.multiply(0);
        
        // Update mesh position if it exists
        if (this.mesh) {
            this.mesh.position.x = this.position.x;
            this.mesh.position.z = this.position.z;
            
            // Rotate mesh to face movement direction (only if moving significantly)
            if (this.velocity.magnitude() > this.minMovementThreshold * 10) {
                this.mesh.rotation.y = -this.velocity.angle() + Math.PI / 2;
            }
        }
    }
}
```

## js/GameState.js

```javascript
import { Vector2D } from './Vector2D.js';
import { OptimizedSheepSystem } from './OptimizedSheep.js';

/**
 * GameState - Handles game configuration, boundaries, and state management
 */
export class GameState {
    constructor() {
        // Field boundaries
        this.bounds = {
            minX: -100,
            maxX: 100,
            minZ: -100,
            maxZ: 100
        };
        
        // Gate and pasture configuration
        this.gate = {
            position: new Vector2D(0, 100), // At the fence border
            width: 8,
            height: 4,
            // Gate passage zone (invisible box for detection)
            passageZone: {
                minX: -4,
                maxX: 4,
                minZ: 98,
                maxZ: 102
            }
        };
        
        // Sleeping pasture area (beyond the gate)
        this.pasture = {
            centerZ: 115, // Beyond the gate
            minX: -30,
            maxX: 30,
            minZ: 102,
            maxZ: 130
        };
        
        // Simulation parameters
        this.params = {
            speed: 0.1,  // Sheep movement speed
            cohesion: 1.0,
            separationDistance: 2.0
        };
        
        // Game state
        this.sheep = [];
        this.sheepdog = null;
        this.sheepRetired = 0;
        this.gameCompleted = false;
        this.totalSheep = 200;
        this.gameActive = false; // New: tracks if game is actively being played
        this.isPaused = false; // New: tracks if game is paused
        this.audioManager = null;
        
        // Always use optimized sheep system
        this.optimizedSheepSystem = null;
    }
    
    createSheepFlock(scene) {
        // Create optimized sheep system
        this.optimizedSheepSystem = new OptimizedSheepSystem(scene, this.totalSheep);
        this.sheep = this.optimizedSheepSystem.getSheep();
        
        // Set bounds for each sheep instance
        this.sheep.forEach(sheep => sheep.setBounds(this.bounds));
        
        // Set audio manager if available
        if (this.audioManager) {
            this.optimizedSheepSystem.setAudioManager(this.audioManager);
        }
        
        return null; // No individual meshes to return
    }
    
    setPaused(paused) {
        this.isPaused = paused;
    }
    
    isPausedState() {
        return this.isPaused;
    }
    
    updateSheepBehaviors(deltaTime = 0.016) {
        // Don't update sheep behaviors if paused
        if (this.isPaused) {
            return this.sheepRetired;
        }
        
        // Always update sheep behaviors for visual effect
        this.optimizedSheepSystem.update(
            deltaTime,
            this.gameActive ? this.sheepdog : null, // Only pass sheepdog if game is active
            this.gameActive ? this.gate : null,     // Only enable gate mechanics if game is active
            this.gameActive ? this.pasture : null,  // Only enable pasture mechanics if game is active
            this.bounds,  // Always pass bounds so sheep stay in field
            this.params   // Always pass params so sheep can flock
        );
        
        // Only count retired sheep if game is active
        if (this.gameActive) {
            this.sheepRetired = 0;
            
            // Count retired sheep
            for (let sheep of this.sheep) {
                // Check if sheep has passed gate
                if (!sheep.hasPassedGate && !sheep.isRetiring) {
                    if (sheep.checkGatePassageAndRetire(this.gate.passageZone, this.pasture)) {
                        // Sheep just passed through the gate
                        this.sheepRetired++;
                        
                        // Play rewarding chime sound
                        if (this.audioManager) {
                            this.audioManager.playRewardingChime();
                        }
                    }
                }
                
                // Count all sheep that have passed or are retiring
                if (sheep.hasPassedGate || sheep.isRetiring) {
                    this.sheepRetired++;
                }
            }
        }
        
        return this.sheepRetired;
    }
    
    checkCompletion() {
        // Only check completion if game is active and not paused
        if (!this.gameActive || this.isPaused) return false;
        
        if (this.sheepRetired === this.sheep.length && !this.gameCompleted) {
            this.gameCompleted = true;
            
            // Play completion sound and win music
            if (this.audioManager) {
                this.audioManager.playRewardingChime();
                
                // Stop gameplay music and start win music
                setTimeout(() => {
                    this.audioManager.stopAllMusic();
                    this.audioManager.playWinMusic();
                }, 500); // Small delay for the chime to play
            }
            
            return true;
        }
        return false;
    }
    
    updateUI() {
        // Only update UI if game is active and not paused
        if (!this.gameActive || this.isPaused) return;
        
        // Update desktop sheep count
        const sheepCountElement = document.getElementById('sheep-count');
        if (sheepCountElement) {
            sheepCountElement.textContent = this.sheepRetired;
        }
        
        // Update mobile sheep count
        const mobileSheepCountElement = document.getElementById('mobile-sheep-count');
        if (mobileSheepCountElement) {
            mobileSheepCountElement.textContent = `Sheep: ${this.sheepRetired} / ${this.totalSheep}`;
        }
    }
    
    showCompletionMessage(finalTime, isNewRecord) {
        let message = 'All sheep have been guided to the pasture!';
        
        if (finalTime !== null) {
            const timeStr = this.formatTime(finalTime);
            message += `\nTime: ${timeStr}`;
            
            if (isNewRecord) {
                message += '\n🎉 NEW BEST TIME! 🎉';
            }
        }
        
        const completionElement = document.getElementById('completion-message');
        if (completionElement) {
            completionElement.innerHTML = 
                message.replace(/\n/g, '<br>') + '<br><button id="restart-button">Play Again</button>';
            completionElement.style.display = 'block';
            
            // Add event listener for restart button
            const restartButton = document.getElementById('restart-button');
            if (restartButton) {
                restartButton.addEventListener('click', () => {
                    // Trigger a full restart to start screen
                    location.reload();
                });
            }
        }
    }
    
    formatTime(timeInSeconds) {
        const minutes = Math.floor(timeInSeconds / 60);
        const seconds = Math.floor(timeInSeconds % 60);
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    
    // Getters
    getBounds() {
        return this.bounds;
    }
    
    getGate() {
        return this.gate;
    }
    
    getPasture() {
        return this.pasture;
    }
    
    getParams() {
        return this.params;
    }
    
    getSheep() {
        return this.sheep;
    }
    
    getSheepdog() {
        return this.sheepdog;
    }
    
    setSheepdog(sheepdog) {
        this.sheepdog = sheepdog;
    }
    
    getSheepRetired() {
        return this.sheepRetired;
    }
    
    getTotalSheep() {
        return this.totalSheep;
    }
    
    isGameCompleted() {
        return this.gameCompleted;
    }
    
    startGame() {
        this.gameActive = true;
        this.gameCompleted = false;
        this.sheepRetired = 0;
        this.isPaused = false; // Ensure game starts unpaused
        
        // Reset all sheep to their starting positions and states
        if (this.optimizedSheepSystem) {
            this.optimizedSheepSystem.resetAllSheep();
        }
    }
    
    isGameActive() {
        return this.gameActive;
    }
    
    setAudioManager(audioManager) {
        this.audioManager = audioManager;
        
        // If sheep system already exists, pass audio manager to it
        if (this.optimizedSheepSystem) {
            this.optimizedSheepSystem.setAudioManager(audioManager);
        }
    }
    
    reset() {
        this.sheep = [];
        this.sheepdog = null;
        this.sheepRetired = 0;
        this.gameCompleted = false;
        this.gameActive = false;
        this.isPaused = false;
        this.optimizedSheepSystem = null;
    }
}
```

## js/GameTimer.js

```javascript
/**
 * GameTimer - Handles timer functionality and best time tracking
 */
export class GameTimer {
    constructor() {
        this.startTime = null;
        this.currentTime = 0;
        this.timerRunning = false;
        this.isPaused = false;
        this.pausedTime = 0; // Total time spent paused
        this.pauseStartTime = null;
        this.bestTime = this.loadBestTime();
        
        this.initializeTimer();
    }
    
    initializeTimer() {
        this.updateTimerDisplay();
        this.updateBestTimeDisplay();
    }
    
    start() {
        if (!this.timerRunning) {
            this.startTime = performance.now();
            this.timerRunning = true;
            this.pausedTime = 0; // Reset paused time when starting
        }
    }
    
    stop() {
        if (this.timerRunning) {
            this.timerRunning = false;
            this.isPaused = false; // Clear pause state when stopping
            this.pauseStartTime = null;
            
            const finalTime = this.currentTime;
            
            // Check if this is a new best time
            if (this.bestTime === null || finalTime < this.bestTime) {
                this.bestTime = finalTime;
                this.saveBestTime(this.bestTime);
                this.updateBestTimeDisplay();
                this.showNewRecordAnimation();
            }
            
            return finalTime;
        }
        return null;
    }
    
    pause() {
        if (this.timerRunning && !this.isPaused) {
            this.isPaused = true;
            this.pauseStartTime = performance.now();
        }
    }
    
    resume() {
        if (this.timerRunning && this.isPaused) {
            this.isPaused = false;
            if (this.pauseStartTime !== null) {
                this.pausedTime += performance.now() - this.pauseStartTime;
                this.pauseStartTime = null;
            }
        }
    }
    
    setPaused(paused) {
        if (paused) {
            this.pause();
        } else {
            this.resume();
        }
    }
    
    update() {
        if (this.timerRunning && this.startTime !== null && !this.isPaused) {
            const currentPausedTime = this.pauseStartTime !== null ? 
                this.pausedTime + (performance.now() - this.pauseStartTime) : 
                this.pausedTime;
            
            this.currentTime = (performance.now() - this.startTime - currentPausedTime) / 1000; // Convert to seconds
            this.updateTimerDisplay();
        }
    }
    
    updateTimerDisplay() {
        const timeToDisplay = this.timerRunning ? this.currentTime : 0;
        const minutes = Math.floor(timeToDisplay / 60);
        const seconds = Math.floor(timeToDisplay % 60);
        const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        // Update desktop timer
        const timerElement = document.getElementById('timer-display');
        if (timerElement) {
            timerElement.textContent = formattedTime;
            
            // Add visual indication when paused
            if (this.isPaused && this.timerRunning) {
                timerElement.style.opacity = '0.6';
                timerElement.style.color = '#ffaa00';
            } else {
                timerElement.style.opacity = '1';
                timerElement.style.color = '';
            }
        }
        
        // Update mobile timer
        const mobileTimerElement = document.getElementById('mobile-timer-display');
        if (mobileTimerElement) {
            mobileTimerElement.textContent = formattedTime;
            
            // Add visual indication when paused
            if (this.isPaused && this.timerRunning) {
                mobileTimerElement.style.opacity = '0.6';
                mobileTimerElement.style.color = '#ffaa00';
            } else {
                mobileTimerElement.style.opacity = '1';
                mobileTimerElement.style.color = '';
            }
        }
    }
    
    updateBestTimeDisplay() {
        const bestTimeText = this.bestTime !== null ? 
            `Best: ${this.formatTime(this.bestTime)}` : 
            'Best: --:--';
        
        // Update desktop best time
        const bestTimeElement = document.getElementById('best-time');
        if (bestTimeElement) {
            bestTimeElement.textContent = bestTimeText;
        }
        
        // Update mobile best time
        const mobileBestTimeElement = document.getElementById('mobile-best-time');
        if (mobileBestTimeElement) {
            mobileBestTimeElement.textContent = bestTimeText;
        }
    }
    
    showNewRecordAnimation() {
        // Animate desktop element
        const bestTimeElement = document.getElementById('best-time');
        if (bestTimeElement) {
            bestTimeElement.classList.add('new-record');
            setTimeout(() => {
                bestTimeElement.classList.remove('new-record');
            }, 3000);
        }
        
        // Animate mobile element
        const mobileBestTimeElement = document.getElementById('mobile-best-time');
        if (mobileBestTimeElement) {
            mobileBestTimeElement.classList.add('new-record');
            setTimeout(() => {
                mobileBestTimeElement.classList.remove('new-record');
            }, 3000);
        }
    }
    
    loadBestTime() {
        try {
            const saved = localStorage.getItem('sheepdog-best-time');
            return saved ? parseFloat(saved) : null;
        } catch (error) {
            console.warn('Could not load best time from localStorage:', error);
            return null;
        }
    }
    
    saveBestTime(time) {
        try {
            localStorage.setItem('sheepdog-best-time', time.toString());
        } catch (error) {
            console.warn('Could not save best time to localStorage:', error);
        }
    }
    
    formatTime(timeInSeconds) {
        const minutes = Math.floor(timeInSeconds / 60);
        const seconds = Math.floor(timeInSeconds % 60);
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    
    getCurrentTime() {
        return this.currentTime;
    }
    
    getBestTime() {
        return this.bestTime;
    }
    
    isRunning() {
        return this.timerRunning;
    }
    
    isPausedState() {
        return this.isPaused;
    }
    
    reset() {
        this.startTime = null;
        this.currentTime = 0;
        this.timerRunning = false;
        this.isPaused = false;
        this.pausedTime = 0;
        this.pauseStartTime = null;
        this.updateTimerDisplay();
    }
}
```

## js/InputHandler.js

```javascript
import { Vector2D } from './Vector2D.js';

/**
 * Enhanced input handler for both keyboard and mobile touch controls
 */
export class InputHandler {
    constructor() {
        this.keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            shift: false
        };
        
        this.performanceMonitor = null;
        this.isPaused = false;
        this.pauseCallbacks = [];
        this.mobileControls = null;
        this.setupEventListeners();
    }

    setupEventListeners() {
        // Keydown event
        window.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            
            // Handle pause toggle with Escape key
            if (event.key === 'Escape') {
                this.togglePause();
                event.preventDefault();
                return;
            }
            
            // Only process other keys if not paused
            if (this.isPaused) {
                event.preventDefault();
                return;
            }
            
            if (key in this.keys) {
                this.keys[key] = true;
                event.preventDefault();
            } else if (event.key === 'Shift') {
                this.keys.shift = true;
                event.preventDefault();
            } else if (key === 'p' && this.performanceMonitor) {
                // Toggle performance monitor with 'P' key
                this.performanceMonitor.toggle();
                event.preventDefault();
            }
        });

        // Keyup event
        window.addEventListener('keyup', (event) => {
            const key = event.key.toLowerCase();
            
            // Don't process movement key releases if paused
            if (this.isPaused && key in this.keys) {
                event.preventDefault();
                return;
            }
            
            if (key in this.keys) {
                this.keys[key] = false;
                event.preventDefault();
            } else if (event.key === 'Shift') {
                this.keys.shift = false;
                event.preventDefault();
            }
        });

        // Reset keys when window loses focus
        window.addEventListener('blur', () => {
            for (let key in this.keys) {
                this.keys[key] = false;
            }
        });
    }

    // Set mobile controls reference
    setMobileControls(mobileControls) {
        this.mobileControls = mobileControls;
    }

    // Toggle pause state
    togglePause() {
        this.isPaused = !this.isPaused;
        
        // Clear all movement keys when pausing
        if (this.isPaused) {
            for (let key in this.keys) {
                this.keys[key] = false;
            }
        }
        
        // Notify all registered callbacks about pause state change
        this.pauseCallbacks.forEach(callback => callback(this.isPaused));
        
        // Show/hide pause indicator
        this.updatePauseUI();
    }

    // Register a callback to be called when pause state changes
    onPauseToggle(callback) {
        this.pauseCallbacks.push(callback);
    }

    // Update pause UI indicator
    updatePauseUI() {
        let pauseIndicator = document.getElementById('pause-indicator');
        
        if (this.isPaused) {
            if (!pauseIndicator) {
                pauseIndicator = document.createElement('div');
                pauseIndicator.id = 'pause-indicator';
                
                // Different pause message for mobile vs desktop
                const isMobile = this.mobileControls && this.mobileControls.getIsTouchDevice();
                const pauseMessage = isMobile ? 
                    '⏸️ PAUSED<br><small>Tap to resume</small>' : 
                    '⏸️ PAUSED<br><small>Press ESC to resume</small>';
                
                pauseIndicator.innerHTML = pauseMessage;
                pauseIndicator.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    font-size: 24px;
                    text-align: center;
                    z-index: 1000;
                    font-family: Arial, sans-serif;
                `;
                
                // Add touch event for mobile resume
                if (isMobile) {
                    pauseIndicator.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.togglePause();
                    });
                }
                
                document.body.appendChild(pauseIndicator);
            }
            pauseIndicator.style.display = 'block';
        } else {
            if (pauseIndicator) {
                pauseIndicator.style.display = 'none';
            }
        }
    }

    // Get movement direction based on current input state (keyboard + mobile)
    getMovementDirection() {
        // Return zero movement if paused
        if (this.isPaused) {
            return new Vector2D(0, 0);
        }
        
        // Start with keyboard input
        const direction = new Vector2D(0, 0);
        
        if (this.keys.w) direction.z += 1;
        if (this.keys.s) direction.z -= 1;
        if (this.keys.a) direction.x += 1;
        if (this.keys.d) direction.x -= 1;
        
        // Add mobile input if available and no keyboard input
        if (this.mobileControls && this.mobileControls.getIsTouchDevice()) {
            const mobileDirection = this.mobileControls.getMovementDirection();
            
            // If no keyboard input, use mobile input
            if (direction.magnitude() === 0) {
                direction.x = mobileDirection.x;
                direction.z = mobileDirection.z;
            }
        }
        
        return direction;
    }

    // Check if any movement input is active
    isMoving() {
        // Return false if paused
        if (this.isPaused) {
            return false;
        }
        
        // Check keyboard input
        const keyboardMoving = this.keys.w || this.keys.a || this.keys.s || this.keys.d;
        
        // Check mobile input
        const mobileMoving = this.mobileControls && 
                            this.mobileControls.getIsTouchDevice() && 
                            this.mobileControls.getIsMoving();
        
        return keyboardMoving || mobileMoving;
    }
    
    // Check if sprint input is active (keyboard shift or mobile sprint button)
    isSprinting() {
        // Return false if paused
        if (this.isPaused) {
            return false;
        }
        
        // Check keyboard sprint
        const keyboardSprinting = this.keys.shift;
        
        // Check mobile sprint
        const mobileSprinting = this.mobileControls && 
                               this.mobileControls.getIsTouchDevice() && 
                               this.mobileControls.getIsSprinting();
        
        return keyboardSprinting || mobileSprinting;
    }
    
    // Check if game is paused
    isPausedState() {
        return this.isPaused;
    }
    
    // Set performance monitor reference for toggle functionality
    setPerformanceMonitor(performanceMonitor) {
        this.performanceMonitor = performanceMonitor;
    }
}
```

## js/main.js

```javascript
import * as THREE from 'three';
import { SceneManager } from './SceneManager.js';
import { GameState } from './GameState.js';
import { GameTimer } from './GameTimer.js';
import { TerrainBuilder } from './TerrainBuilder.js';
import { StructureBuilder } from './StructureBuilder.js';
import { InputHandler } from './InputHandler.js';
import { MobileControls } from './MobileControls.js';
import { Sheepdog } from './Sheepdog.js';
import { PerformanceMonitor } from './PerformanceMonitor.js';
import { StartScreen } from './StartScreen.js';
import { StaminaUI } from './StaminaUI.js';
import { AudioManager } from './AudioManager.js';

/**
 * Main simulation controller - Enhanced with mobile controls support
 * Uses separate modules for different responsibilities
 */
class SheepDogSimulation {
    constructor() {
        // Initialize all modules
        this.sceneManager = new SceneManager();
        this.gameState = new GameState();
        this.gameTimer = new GameTimer();
        this.terrainBuilder = new TerrainBuilder(this.sceneManager.getScene());
        this.structureBuilder = new StructureBuilder(this.sceneManager.getScene());
        this.inputHandler = new InputHandler();
        this.mobileControls = new MobileControls();
        this.performanceMonitor = new PerformanceMonitor();
        this.startScreen = new StartScreen(this.sceneManager);
        this.staminaUI = new StaminaUI();
        this.audioManager = new AudioManager(this.sceneManager.getCamera());
        
        // Connect mobile controls to input handler and scene manager
        this.inputHandler.setMobileControls(this.mobileControls);
        this.sceneManager.setMobileControls(this.mobileControls);
        
        // Connect performance monitor and game state to input handler
        this.inputHandler.setPerformanceMonitor(this.performanceMonitor);
        
        // Set up pause functionality
        this.setupPauseHandling();
        
        // Set up start screen callback
        this.startScreen.setGameStartCallback(() => {
            this.startGame();
        });
        
        // Pass audio manager to modules that need it
        this.gameState.setAudioManager(this.audioManager);
        this.startScreen.setAudioManager(this.audioManager);
        
        // Animation timing
        this.lastTime = performance.now();
        
        // Initialize the simulation
        this.init();
        this.animate();
    }
    
    setupPauseHandling() {
        // Register pause callback with input handler
        this.inputHandler.onPauseToggle((isPaused) => {
            // Propagate pause state to timer
            this.gameTimer.setPaused(isPaused);
            
            // Propagate pause state to game state
            this.gameState.setPaused(isPaused);
        });
    }
    
    init() {
        // Create terrain and environment
        this.terrainBuilder.createTerrain();
        this.terrainBuilder.createGrass();
        this.terrainBuilder.createTrees();
        this.terrainBuilder.addEnvironmentDetails();
        
        // Create structures
        this.structureBuilder.createFieldBoundaryFence(
            this.gameState.getBounds(), 
            this.gameState.getGate()
        );
        this.structureBuilder.createGateAndPasture(
            this.gameState.getGate(), 
            this.gameState.getPasture()
        );
        
        // Create sheepdog (but don't add to scene yet in pre-game state)
        const sheepdog = new Sheepdog(0, -30);
        this.sheepdog = sheepdog;
        this.sheepdogMesh = sheepdog.createMesh();
        this.gameState.setSheepdog(sheepdog);
        
        // Connect audio manager to sheepdog
        sheepdog.setAudioManager(this.audioManager);
        
        // Create optimized sheep flock (visible during start screen)
        this.gameState.createSheepFlock(this.sceneManager.getScene());
        
        // Setup controls
        this.sceneManager.setupMouseControls();
        
        // Set grass instance count for performance monitoring
        this.performanceMonitor.setGrassInstanceCount(this.terrainBuilder.getGrassInstanceCount());
    }
    
    startGame() {
        // Add sheepdog to scene when game starts
        this.sceneManager.add(this.sheepdogMesh);
        
        // Enable mobile controls if on touch device
        if (this.mobileControls.getIsTouchDevice()) {
            this.mobileControls.enable();
        }
        
        // Start the game state
        this.gameState.startGame();
        
        // Reset timer and stamina
        this.gameTimer.reset();
        this.staminaUI.reset();
        this.staminaUI.show();
    }
    
    update(deltaTime) {
        // Check if game is paused
        const isPaused = this.inputHandler.isPausedState();
        
        // Update start screen camera if active
        if (this.startScreen.isStartScreenActive()) {
            this.startScreen.updateCinematicCamera();
        } else if (!isPaused) {
            // Handle input only when game is active and not paused
            const movementDirection = this.inputHandler.getMovementDirection();
            const wantsSprint = this.inputHandler.isSprinting();
            const sheepdog = this.gameState.getSheepdog();
            
            // Update sheepdog's awareness of nearby sheep for barking
            sheepdog.updateNearSheepStatus(this.gameState.getSheep());
            
            // Always call move to update position, stamina, and animations
            sheepdog.move(movementDirection, this.gameState.getBounds(), deltaTime, wantsSprint);
            
            // Start timer on first actual movement
            if (movementDirection.magnitude() > 0 && !this.gameTimer.isRunning()) {
                this.gameTimer.start();
            }
            
            // Update camera to follow sheepdog
            this.sceneManager.updateCamera(sheepdog);
        }
        
        // Update timer (respects pause state internally)
        this.gameTimer.update();
        
        // Update sheep behaviors (only if not paused)
        if (!isPaused) {
            this.gameState.updateSheepBehaviors(deltaTime);
        }
        
        // Update UI (only when game is active and not paused)
        if (!isPaused) {
            this.gameState.updateUI();
            
            // Update stamina UI if game is active
            if (!this.startScreen.isStartScreenActive()) {
                const sheepdog = this.gameState.getSheepdog();
                if (sheepdog) {
                    this.staminaUI.update(sheepdog.getStaminaInfo());
                }
            }
        }
        
        // Check for game completion (only when game is active and not paused)
        if (!isPaused && this.gameState.checkCompletion()) {
            const finalTime = this.gameTimer.stop();
            const isNewRecord = this.gameTimer.getBestTime() !== null && 
                               finalTime <= this.gameTimer.getBestTime();
            
            this.gameState.showCompletionMessage(finalTime, isNewRecord);
            
            // Disable mobile controls when game completes
            this.mobileControls.disable();
        }
    }
    
    animate() {
        requestAnimationFrame(() => this.animate());
        
        // Calculate delta time
        const currentTime = performance.now();
        const deltaTime = (currentTime - this.lastTime) / 1000; // Convert to seconds
        this.lastTime = currentTime;
        
        // Check if game is paused
        const isPaused = this.inputHandler.isPausedState();
        
        // Update grass animation (only if not paused)
        if (!isPaused) {
            this.terrainBuilder.updateGrassAnimation();
        }
        
        // Update game logic with deltaTime
        this.update(deltaTime);
        
        // Update performance monitoring (always update for monitoring purposes)
        this.performanceMonitor.updateMetrics(this.gameState, this.sceneManager.getRenderer());
        
        // Render the scene (always render to show pause indicator)
        this.sceneManager.render();
    }
}

// Start simulation when page loads
window.addEventListener('DOMContentLoaded', () => {
    new SheepDogSimulation();
});
```

## js/MobileControls.js

```javascript
import { Vector2D } from './Vector2D.js';

/**
 * MobileControls - Handles touch-based input controls for mobile devices
 * Includes virtual joystick for movement and zoom slider for camera control
 */
export class MobileControls {
    constructor() {
        this.isTouchDevice = this.detectTouchDevice();
        this.isEnabled = false;
        this.joystick = null;
        this.zoomSlider = null;
        this.movementVector = new Vector2D(0, 0);
        this.isMoving = false;
        this.isSprinting = false;
        this.zoomLevel = 80; // Default camera distance
        this.onZoomChange = null;
        
        // UI elements
        this.joystickContainer = null;
        this.zoomContainer = null;
        this.sprintButton = null;
        this.fullscreenButton = null;
        
        if (this.isTouchDevice) {
            this.createFullscreenButton();
            this.setupFullscreenListeners();
            this.loadNippleJS().then(() => {
                this.createMobileUI();
                this.setupTouchPrevention();
            });
        }
    }
    
    /**
     * Detect if device supports touch input
     * @returns {boolean} True if touch device detected
     */
    detectTouchDevice() {
        // Multiple detection methods for better accuracy
        const hasTouch = 'ontouchstart' in window || 
                        navigator.maxTouchPoints > 0 || 
                        navigator.msMaxTouchPoints > 0;
        
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        const hasCoarsePointer = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
        
        const isSmallScreen = window.innerWidth <= 768 || window.innerHeight <= 768;
        
        // Device is considered touch-capable if it has touch AND (is mobile OR has coarse pointer OR small screen)
        return hasTouch && (isMobile || hasCoarsePointer || isSmallScreen);
    }
    
    /**
     * Load nipple.js library dynamically
     */
    async loadNippleJS() {
        return new Promise((resolve, reject) => {
            if (window.nipplejs) {
                resolve();
                return;
            }
            
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.2/nipplejs.js';
            script.onload = () => resolve();
            script.onerror = () => reject(new Error('Failed to load nipple.js'));
            document.head.appendChild(script);
        });
    }
    
    /**
     * Create mobile UI elements
     */
    createMobileUI() {
        this.createJoystick();
        this.createZoomSlider();
        this.createSprintButton();
        this.updateMobileInstructions();
    }
    
    /**
     * Create virtual joystick for movement
     */
    createJoystick() {
        // Create joystick container
        this.joystickContainer = document.createElement('div');
        this.joystickContainer.id = 'mobile-joystick';
        this.joystickContainer.style.cssText = `
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            z-index: 1001;
            display: none;
            pointer-events: auto;
        `;
        document.body.appendChild(this.joystickContainer);
        
        // Initialize nipple.js joystick
        if (window.nipplejs) {
            this.joystick = window.nipplejs.create({
                zone: this.joystickContainer,
                mode: 'static',
                position: { left: '50%', top: '50%' },
                color: '#00BFFF',
                size: 120,
                threshold: 0.1,
                fadeTime: 250,
                restOpacity: 0.7
            });
            
            // Handle joystick events
            this.joystick.on('start', () => {
                this.isMoving = true;
            });
            
            this.joystick.on('move', (evt, data) => {
                if (data.vector) {
                    // Convert joystick vector to movement vector
                    // Nipple.js uses screen coordinates, we need game coordinates
                    this.movementVector.x = -data.vector.x; // Invert X for correct direction
                    this.movementVector.z = data.vector.y;  // Y becomes Z in 3D space
                    this.isMoving = true;
                }
            });
            
            this.joystick.on('end', () => {
                this.movementVector.x = 0;
                this.movementVector.z = 0;
                this.isMoving = false;
            });
        }
    }
    
    /**
     * Create zoom slider for camera control
     */
    createZoomSlider() {
        this.zoomContainer = document.createElement('div');
        this.zoomContainer.id = 'mobile-zoom';
        this.zoomContainer.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 200px;
            z-index: 1001;
            display: none;
            pointer-events: auto;
        `;
        
        // Create slider
        this.zoomSlider = document.createElement('input');
        this.zoomSlider.type = 'range';
        this.zoomSlider.min = '20';
        this.zoomSlider.max = '150';
        this.zoomSlider.value = '80';
        this.zoomSlider.orient = 'vertical';
        this.zoomSlider.style.cssText = `
            width: 200px;
            height: 40px;
            transform: rotate(-90deg) translateX(-80px);
            transform-origin: 20px 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        `;
        
        // Style the slider track and thumb
        const style = document.createElement('style');
        style.textContent = `
            #mobile-zoom input[type="range"]::-webkit-slider-track {
                height: 8px;
                background: #ddd;
                border-radius: 4px;
                border: 1px solid #00BFFF;
            }
            
            #mobile-zoom input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                height: 20px;
                width: 20px;
                border-radius: 50%;
                background: #00BFFF;
                cursor: pointer;
                border: 2px solid white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
            
            #mobile-zoom input[type="range"]::-moz-range-track {
                height: 8px;
                background: #ddd;
                border-radius: 4px;
                border: 1px solid #00BFFF;
            }
            
            #mobile-zoom input[type="range"]::-moz-range-thumb {
                height: 20px;
                width: 20px;
                border-radius: 50%;
                background: #00BFFF;
                cursor: pointer;
                border: 2px solid white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        `;
        document.head.appendChild(style);
        
        // Add zoom labels
        const zoomLabel = document.createElement('div');
        zoomLabel.textContent = 'Zoom';
        zoomLabel.style.cssText = `
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: Arial, sans-serif;
            font-weight: bold;
        `;
        
        this.zoomContainer.appendChild(zoomLabel);
        this.zoomContainer.appendChild(this.zoomSlider);
        document.body.appendChild(this.zoomContainer);
        
        // Handle zoom changes
        this.zoomSlider.addEventListener('input', (e) => {
            this.zoomLevel = parseInt(e.target.value);
            if (this.onZoomChange) {
                this.onZoomChange(this.zoomLevel);
            }
        });
    }
    
    /**
     * Create sprint button
     */
    createSprintButton() {
        this.sprintButton = document.createElement('button');
        this.sprintButton.id = 'mobile-sprint';
        this.sprintButton.textContent = '🏃';
        this.sprintButton.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 80px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 191, 255, 0.8);
            border: 3px solid white;
            color: white;
            font-size: 24px;
            z-index: 1001;
            display: none;
            pointer-events: auto;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        `;
        
        // Handle sprint button events
        this.sprintButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.isSprinting = true;
            this.sprintButton.style.background = 'rgba(255, 107, 53, 0.9)';
            this.sprintButton.style.transform = 'scale(0.95)';
        });
        
        this.sprintButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.isSprinting = false;
            this.sprintButton.style.background = 'rgba(0, 191, 255, 0.8)';
            this.sprintButton.style.transform = 'scale(1)';
        });
        
        // Prevent context menu
        this.sprintButton.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        document.body.appendChild(this.sprintButton);
    }
    
    /**
     * Update instructions for mobile devices
     */
    updateMobileInstructions() {
        const instructions = document.getElementById('instructions');
        if (instructions && this.isTouchDevice) {
            // Hide the instructions completely on mobile
            instructions.style.display = 'none';
        }
    }
    
    /**
     * Setup touch event prevention for game canvas
     */
    setupTouchPrevention() {
        const canvas = document.querySelector('canvas');
        if (canvas) {
            // Prevent default touch behaviors on canvas
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
            }, { passive: false });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });
            
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
            }, { passive: false });
        }
        
        // Prevent zoom on double tap
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // Prevent zoom on pinch
        document.addEventListener('gesturestart', (e) => {
            e.preventDefault();
        });
    }
    
    /**
     * Enable mobile controls
     */
    enable() {
        if (!this.isTouchDevice) return;
        
        this.isEnabled = true;
        if (this.joystickContainer) this.joystickContainer.style.display = 'block';
        if (this.zoomContainer) this.zoomContainer.style.display = 'block';
        if (this.sprintButton) this.sprintButton.style.display = 'block';
    }
    
    /**
     * Disable mobile controls
     */
    disable() {
        this.isEnabled = false;
        if (this.joystickContainer) this.joystickContainer.style.display = 'none';
        if (this.zoomContainer) this.zoomContainer.style.display = 'none';
        if (this.sprintButton) this.sprintButton.style.display = 'none';
        
        // Reset movement state
        this.movementVector.x = 0;
        this.movementVector.z = 0;
        this.isMoving = false;
        this.isSprinting = false;
    }
    
    /**
     * Get current movement direction
     */
    getMovementDirection() {
        if (!this.isEnabled) return new Vector2D(0, 0);
        return this.movementVector.clone();
    }
    
    /**
     * Check if currently moving
     */
    getIsMoving() {
        return this.isEnabled && this.isMoving;
    }
    
    /**
     * Check if currently sprinting
     */
    getIsSprinting() {
        return this.isEnabled && this.isSprinting;
    }
    
    /**
     * Set zoom change callback
     */
    setZoomChangeCallback(callback) {
        this.onZoomChange = callback;
    }
    
    /**
     * Get current zoom level
     */
    getZoomLevel() {
        return this.zoomLevel;
    }
    
    /**
     * Check if this is a touch device
     */
    getIsTouchDevice() {
        return this.isTouchDevice;
    }
    
    /**
     * Cleanup mobile controls
     */
    destroy() {
        if (this.joystick) {
            this.joystick.destroy();
        }
        
        if (this.joystickContainer) {
            this.joystickContainer.remove();
        }
        
        if (this.zoomContainer) {
            this.zoomContainer.remove();
        }
        
        if (this.sprintButton) {
            this.sprintButton.remove();
        }
    }
    
    /**
     * Check if fullscreen API is supported
     */
    isFullscreenSupported() {
        const element = document.documentElement;
        return !!(
            element.requestFullscreen ||
            element.webkitRequestFullscreen ||
            element.webkitRequestFullScreen ||
            element.mozRequestFullScreen ||
            element.msRequestFullscreen
        );
    }
    
    /**
     * Create fullscreen button for mobile devices
     */
    createFullscreenButton() {
        // Only show on mobile devices that support fullscreen
        if (!this.isTouchDevice || !this.isFullscreenSupported()) return;
        
        // Don't create if already exists or if already in fullscreen
        if (this.fullscreenButton || this.isFullscreen()) return;
        
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.id = 'mobile-fullscreen';
        this.fullscreenButton.innerHTML = '📱<br><span style="font-size: 14px;">Play Fullscreen</span>';
        this.fullscreenButton.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 160px;
            height: 80px;
            border-radius: 12px;
            background: rgba(0, 191, 255, 0.95);
            border: 3px solid white;
            color: white;
            font-size: 24px;
            font-weight: bold;
            z-index: 2000;
            display: block;
            pointer-events: auto;
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
            transition: all 0.3s ease;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            font-family: Arial, sans-serif;
            text-align: center;
            line-height: 1.2;
            cursor: pointer;
        `;
        
        // Add hover/active effects
        this.fullscreenButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.fullscreenButton.style.transform = 'translate(-50%, -50%) scale(0.95)';
            this.fullscreenButton.style.background = 'rgba(0, 150, 200, 0.95)';
        });
        
        this.fullscreenButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.fullscreenButton.style.transform = 'translate(-50%, -50%) scale(1)';
            this.fullscreenButton.style.background = 'rgba(0, 191, 255, 0.95)';
            
            // Request fullscreen
            this.requestFullscreen();
        });
        
        // Fallback click event for devices that might not support touch events properly
        this.fullscreenButton.addEventListener('click', (e) => {
            e.preventDefault();
            this.requestFullscreen();
        });
        
        // Prevent context menu
        this.fullscreenButton.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        document.body.appendChild(this.fullscreenButton);
    }
    
    /**
     * Request fullscreen with cross-browser compatibility
     */
    requestFullscreen() {
        const element = document.documentElement;
        
        try {
            // Check for different fullscreen API methods
            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.webkitRequestFullscreen) {
                // Safari
                element.webkitRequestFullscreen();
            } else if (element.webkitRequestFullScreen) {
                // Older Safari
                element.webkitRequestFullScreen();
            } else if (element.mozRequestFullScreen) {
                // Firefox
                element.mozRequestFullScreen();
            } else if (element.msRequestFullscreen) {
                // IE/Edge
                element.msRequestFullscreen();
            } else {
                console.warn('Fullscreen API not supported on this device');
                // Hide button anyway since user tried to use it
                this.hideFullscreenButton();
                return;
            }
            
            // Hide the fullscreen button after requesting fullscreen
            this.hideFullscreenButton();
            
        } catch (error) {
            console.warn('Failed to request fullscreen:', error);
            // Hide button if fullscreen fails
            this.hideFullscreenButton();
        }
    }
    
    /**
     * Hide the fullscreen button
     */
    hideFullscreenButton() {
        if (this.fullscreenButton) {
            this.fullscreenButton.style.opacity = '0';
            this.fullscreenButton.style.pointerEvents = 'none';
            setTimeout(() => {
                if (this.fullscreenButton) {
                    this.fullscreenButton.remove();
                    this.fullscreenButton = null;
                }
            }, 300);
        }
    }
    
    /**
     * Check if device is in fullscreen mode
     */
    isFullscreen() {
        return !!(
            document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement
        );
    }
    
    /**
     * Setup fullscreen change event listeners
     */
    setupFullscreenListeners() {
        // Handle fullscreen change events across different browsers
        const handleFullscreenChange = () => {
            if (!this.isFullscreen() && this.isTouchDevice) {
                // User exited fullscreen, show button again
                setTimeout(() => {
                    this.createFullscreenButton();
                }, 500); // Small delay to avoid flickering
            }
            
            // Update mobile UI positioning for fullscreen
            this.updateFullscreenLayout();
        };
        
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('msfullscreenchange', handleFullscreenChange);
    }
    
    /**
     * Update mobile UI layout for fullscreen mode
     */
    updateFullscreenLayout() {
        if (!this.isTouchDevice) return;
        
        const isFullscreen = this.isFullscreen();
        const body = document.body;
        
        if (isFullscreen) {
            // Add fullscreen class for CSS targeting
            body.classList.add('mobile-fullscreen');
            
            // Adjust mobile controls positioning for fullscreen
            if (this.joystickContainer) {
                this.joystickContainer.style.bottom = '30px';
                this.joystickContainer.style.left = '30px';
            }
            
            if (this.zoomContainer) {
                this.zoomContainer.style.bottom = '30px';
                this.zoomContainer.style.right = '30px';
            }
            
            if (this.sprintButton) {
                this.sprintButton.style.bottom = '30px';
                this.sprintButton.style.right = '100px';
            }
        } else {
            // Remove fullscreen class
            body.classList.remove('mobile-fullscreen');
            
            // Reset to normal positioning
            if (this.joystickContainer) {
                this.joystickContainer.style.bottom = '20px';
                this.joystickContainer.style.left = '20px';
            }
            
            if (this.zoomContainer) {
                this.zoomContainer.style.bottom = '20px';
                this.zoomContainer.style.right = '20px';
            }
            
            if (this.sprintButton) {
                this.sprintButton.style.bottom = '20px';
                this.sprintButton.style.right = '80px';
            }
        }
    }
}
```

## js/OptimizedSheep.js

```javascript
import * as THREE from 'three';
import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
import { Vector2D } from './Vector2D.js';
import { Boid } from './Boid.js';

/**
 * OptimizedSheep - High-performance sheep system using modern GPU techniques
 * 
 * Features:
 * - Single InstancedMesh for all sheep (1 draw call!)
 * - Merged geometry with vertex colors
 * - GPU-based animation via vertex shader
 * - Efficient per-instance data management
 */

export class OptimizedSheepSystem {
    constructor(scene, sheepCount = 200) {
        this.scene = scene;
        this.sheepCount = sheepCount;
        this.sheep = [];
        this.audioManager = null;
        
        // Create geometry and materials
        this.createMergedGeometry();
        this.createOptimizedMaterial();
        
        // Create instanced mesh
        this.createInstancedMesh();
        
        // Initialize sheep data
        this.initializeSheepData();
    }
    
    /**
     * Create merged sheep geometry with vertex colors
     */
    createMergedGeometry() {
        const geometries = [];
        const colors = [];
        
        // Body - simplified ellipsoid
        const bodyGeometry = new THREE.SphereGeometry(0.8, 12, 8);
        bodyGeometry.scale(1, 0.9, 1.1);
        bodyGeometry.translate(0, 0.7, 0);
        
        // Add white color for body vertices
        const bodyColors = new Float32Array(bodyGeometry.attributes.position.count * 3);
        for (let i = 0; i < bodyColors.length; i += 3) {
            bodyColors[i] = 1;     // R
            bodyColors[i + 1] = 1; // G
            bodyColors[i + 2] = 1; // B
        }
        bodyGeometry.setAttribute('color', new THREE.BufferAttribute(bodyColors, 3));
        
        // Add vertex IDs for body
        const bodyVertexIds = new Float32Array(bodyGeometry.attributes.position.count);
        for (let i = 0; i < bodyVertexIds.length; i++) {
            bodyVertexIds[i] = Math.min(i, 49); // Body vertices: 0-49
        }
        bodyGeometry.setAttribute('vertexId', new THREE.BufferAttribute(bodyVertexIds, 1));
        geometries.push(bodyGeometry);
        
        // Head - smaller sphere merged with body
        const headGeometry = new THREE.SphereGeometry(0.35, 10, 6);
        headGeometry.scale(0.8, 0.9, 1.2);
        headGeometry.translate(0, 0.65, 0.65);
        
        // Add black color for head vertices
        const headColors = new Float32Array(headGeometry.attributes.position.count * 3);
        for (let i = 0; i < headColors.length; i += 3) {
            headColors[i] = 0.16;     // R
            headColors[i + 1] = 0.16; // G
            headColors[i + 2] = 0.16; // B
        }
        headGeometry.setAttribute('color', new THREE.BufferAttribute(headColors, 3));
        
        // Add vertex IDs for head
        const headVertexIds = new Float32Array(headGeometry.attributes.position.count);
        for (let i = 0; i < headVertexIds.length; i++) {
            headVertexIds[i] = 50 + Math.min(i, 49); // Head vertices: 50-99
        }
        headGeometry.setAttribute('vertexId', new THREE.BufferAttribute(headVertexIds, 1));
        geometries.push(headGeometry);
        
        // Create 4 legs as simple cylinders
        const legGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.5, 6);
        const legPositions = [
            { x: -0.25, z: 0.3 },  // front left
            { x: 0.25, z: 0.3 },   // front right
            { x: -0.25, z: -0.3 }, // back left
            { x: 0.25, z: -0.3 }   // back right
        ];
        
        legPositions.forEach((pos, index) => {
            const leg = legGeometry.clone();
            leg.translate(pos.x, 0.25, pos.z);
            
            // Add vertex IDs for animation in shader
            const vertexIds = new Float32Array(leg.attributes.position.count);
            for (let i = 0; i < vertexIds.length; i++) {
                vertexIds[i] = 100 + index * 10; // Leg ID encoding
            }
            leg.setAttribute('vertexId', new THREE.BufferAttribute(vertexIds, 1));
            
            // Black color for legs
            const legColors = new Float32Array(leg.attributes.position.count * 3);
            for (let i = 0; i < legColors.length; i += 3) {
                legColors[i] = 0.16;     // R
                legColors[i + 1] = 0.16; // G
                legColors[i + 2] = 0.16; // B
            }
            leg.setAttribute('color', new THREE.BufferAttribute(legColors, 3));
            
            geometries.push(leg);
        });
        
        // Merge all geometries
        this.mergedGeometry = BufferGeometryUtils.mergeGeometries(geometries);
        
        // Compute bounds for frustum culling
        this.mergedGeometry.computeBoundingBox();
        this.mergedGeometry.computeBoundingSphere();
    }
    
    /**
     * Create optimized material with custom shaders
     */
    createOptimizedMaterial() {
        // Vertex shader with GPU animation
        const vertexShader = `
            // Use built-in color attribute from Three.js
            attribute float vertexId;
            
            // Per-instance attributes
            attribute vec4 instanceData; // x: animPhase, y: speed, z: state, w: uniqueId
            attribute vec4 instanceAnimation; // x: walkCycle, y: bounce, z: direction, w: blinkTimer
            
            uniform float time;
            uniform float globalAnimSpeed;
            
            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            
            // Animation functions
            vec3 animateVertex(vec3 position, float vId) {
                vec3 animated = position;
                
                float animPhase = instanceData.x;
                float speed = instanceData.y;
                float walkCycle = instanceAnimation.x;
                float bounce = instanceAnimation.y;
                
                // Leg animation (vertexId 100-139)
                if (vId >= 100.0 && vId < 140.0) {
                    float legIndex = floor((vId - 100.0) / 10.0); // 0-3
                    float legPhase = legIndex < 2.0 ? 0.0 : 3.14159; // Front/back offset
                    float sidePhase = mod(legIndex, 2.0) * 1.57; // Left/right offset
                    
                    float legTime = time * globalAnimSpeed + animPhase + walkCycle;
                    float legLift = max(0.0, sin(legTime * 3.0 + legPhase + sidePhase)) * bounce * 2.0;
                    
                    animated.y += legLift * speed;
                    
                    // Slight forward/back motion
                    animated.z += sin(legTime * 3.0 + legPhase + sidePhase) * bounce * 0.3 * speed;
                }
                
                // Body bounce (vertexId 0-49)
                if (vId < 50.0) {
                    float bodyTime = time * globalAnimSpeed + animPhase;
                    animated.y += sin(bodyTime * 2.0) * bounce * 0.5 * speed;
                    
                    // Slight wobble
                    animated.x += sin(bodyTime * 2.5) * bounce * 0.1 * speed;
                }
                
                // Head bob (vertexId 50-99)
                if (vId >= 50.0 && vId < 100.0) {
                    float headTime = time * globalAnimSpeed + animPhase + 0.5;
                    animated.y += sin(headTime * 2.0) * bounce * 0.3 * speed;
                    
                    // Look direction
                    float lookAngle = instanceAnimation.z;
                    animated.x += sin(lookAngle) * 0.1;
                    animated.z += cos(lookAngle) * 0.1;
                }
                
                return animated;
            }
            
            void main() {
                // Access vertex color using built-in Three.js attribute
                #ifdef USE_COLOR
                    vColor = color;
                #else
                    vColor = vec3(1.0); // Default to white if no vertex colors
                #endif
                
                vNormal = normalMatrix * normal;
                
                // Animate vertex position
                vec3 animatedPosition = animateVertex(position, vertexId);
                
                // Apply instance transformation with proper matrix multiplication
                vec4 instancePosition = instanceMatrix * vec4(animatedPosition, 1.0);
                
                vec4 mvPosition = modelViewMatrix * instancePosition;
                vViewPosition = -mvPosition.xyz;
                
                gl_Position = projectionMatrix * mvPosition;
            }
        `;
        
        // Fragment shader with simple toon shading
        const fragmentShader = `
            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            
            uniform vec3 fogColor;
            uniform float fogNear;
            uniform float fogFar;
            
            void main() {
                // Simple toon shading
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(vViewPosition);
                
                // Basic lighting
                vec3 lightDir = normalize(vec3(0.3, 1.0, 0.5));
                float NdotL = dot(normal, lightDir);
                
                // Toon shading steps
                float toon = smoothstep(0.0, 0.01, NdotL) * 0.5 + 0.5;
                toon = floor(toon * 3.0) / 3.0;
                
                // Apply vertex color with toon shading
                vec3 finalColor = vColor * toon;
                
                // Apply fog
                float depth = length(vViewPosition);
                float fogFactor = smoothstep(fogNear, fogFar, depth);
                finalColor = mix(finalColor, fogColor, fogFactor);
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;
        
        this.material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms: {
                time: { value: 0 },
                globalAnimSpeed: { value: 1.0 },
                fogColor: { value: new THREE.Color(0x87CEEB) },
                fogNear: { value: 200 },
                fogFar: { value: 600 }
            },
            vertexColors: true,
            fog: false // We handle fog manually in shader
        });
    }
    
    /**
     * Create the instanced mesh with all sheep
     */
    createInstancedMesh() {
        this.instancedMesh = new THREE.InstancedMesh(
            this.mergedGeometry,
            this.material,
            this.sheepCount
        );
        
        // Enable shadows
        this.instancedMesh.castShadow = true;
        this.instancedMesh.receiveShadow = true;
        
        // Create instance attributes for animation data
        const instanceData = new THREE.InstancedBufferAttribute(
            new Float32Array(this.sheepCount * 4), 4
        );
        const instanceAnimation = new THREE.InstancedBufferAttribute(
            new Float32Array(this.sheepCount * 4), 4
        );
        
        this.mergedGeometry.setAttribute('instanceData', instanceData);
        this.mergedGeometry.setAttribute('instanceAnimation', instanceAnimation);
        
        // Add to scene
        this.scene.add(this.instancedMesh);
        
        // Disable frustum culling so sheep never disappear due to bounding sphere issues
        this.instancedMesh.frustumCulled = false;
    }
    
    /**
     * Initialize individual sheep instances
     */
    initializeSheepData() {
        const dummy = new THREE.Object3D();
        const spreadRadius = 30;
        
        for (let i = 0; i < this.sheepCount; i++) {
            // Random position in a cluster
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * spreadRadius;
            const x = -30 + Math.cos(angle) * distance;
            const z = -30 + Math.sin(angle) * distance;
            
            // Create sheep instance data
            const sheep = new OptimizedSheepInstance(i, x, z);
            this.sheep.push(sheep);
            
            // Set initial transform
            dummy.position.set(x, 0, z);
            dummy.rotation.y = Math.random() * Math.PI * 2;
            dummy.updateMatrix();
            this.instancedMesh.setMatrixAt(i, dummy.matrix);
            
            // Set initial animation data
            this.updateInstanceAttributes(i, sheep);
        }
        
        this.instancedMesh.instanceMatrix.needsUpdate = true;
    }
    
    /**
     * Update instance attributes for a specific sheep
     */
    updateInstanceAttributes(index, sheep) {
        const instanceData = this.mergedGeometry.attributes.instanceData;
        const instanceAnimation = this.mergedGeometry.attributes.instanceAnimation;
        
        if (!instanceData || !instanceAnimation) return;
        
        // Instance data: animPhase, speed, state, uniqueId
        instanceData.setXYZW(
            index,
            sheep.animationPhase,
            sheep.currentSpeed,
            sheep.state, // 0: active, 1: retiring, 2: retired
            index
        );
        
        // Animation data: walkCycle, bounce, direction, blinkTimer
        instanceAnimation.setXYZW(
            index,
            sheep.walkCycle,
            sheep.bounceAmount,
            sheep.facingDirection,
            sheep.blinkTimer
        );
        
        instanceData.needsUpdate = true;
        instanceAnimation.needsUpdate = true;
    }
    
    /**
     * Update all sheep behaviors and animations
     */
    update(deltaTime, sheepdog, gate, pasture, bounds, params) {
        const dummy = new THREE.Object3D();
        
        // Update time uniform
        this.material.uniforms.time.value += deltaTime;
        
        // Ensure instance matrix is available
        if (!this.instancedMesh.instanceMatrix) {
            console.warn('Instance matrix not available');
            return;
        }
        
        // Track sheep being chased for group audio
        let sheepBeingChased = 0;
        let shouldPlayGroupBleat = false;
        
        // Update each sheep
        for (let i = 0; i < this.sheepCount; i++) {
            const sheep = this.sheep[i];
            
            // Check if this sheep is being chased (before updating behavior)
            if (sheepdog && sheep.position) {
                const distanceToSheepdog = sheep.position.distanceTo(sheepdog.position);
                const isBeingChased = distanceToSheepdog < sheep.fleeRadius;
                
                if (isBeingChased && !sheep.wasBeingChased) {
                    sheepBeingChased++;
                    shouldPlayGroupBleat = true;
                }
            }
            
            // Update behavior (flocking, movement, etc.)
            sheep.updateBehavior(this.sheep, sheepdog, gate, pasture, bounds, params, false); // Pass false to disable individual bleating
            sheep.updatePosition(deltaTime);
            
            // Update transform matrix using interpolated render position for smooth movement
            dummy.position.set(sheep.renderPosition.x, 0, sheep.renderPosition.z);
            dummy.rotation.y = -sheep.renderFacingDirection + Math.PI / 2;
            
            // Keep all sheep visible - no hiding for grazing sheep
            dummy.scale.set(1, 1, 1);
            
            dummy.updateMatrix();

            // Defensive check for NaN/Infinity in the dummy matrix before setting instanceMatrix
            let matrixIsValid = true;
            for (let j = 0; j < 16; j++) {
                if (isNaN(dummy.matrix.elements[j]) || !isFinite(dummy.matrix.elements[j])) {
                    matrixIsValid = false;
                    break;
                }
            }

            if (matrixIsValid) {
                this.instancedMesh.setMatrixAt(i, dummy.matrix);
            } else {
                console.warn(`Sheep ${sheep.id} produced invalid matrix. Skipping update for this instance.`);
                // Optionally, set to an identity matrix or last known good matrix for this instance
                // For now, we just skip, which means it won't update its visual position/rotation
                // which might make it appear stuck, but it's better than a crash or full invisibility.
            }
            
            // Update animation attributes
            this.updateInstanceAttributes(i, sheep);
        }
        
        // Play group bleat if multiple sheep started being chased this frame
        if (shouldPlayGroupBleat && sheepBeingChased > 0 && this.audioManager) {
            if (sheepBeingChased === 1) {
                this.audioManager.playSheepBleat(); // Single bleat for one sheep
            } else {
                this.audioManager.playGroupSheepBleats(sheepBeingChased); // Layered bleats for multiple sheep
            }
        }
        
        this.instancedMesh.instanceMatrix.needsUpdate = true;
    }
    
    /**
     * Get all sheep instances
     */
    getSheep() {
        return this.sheep;
    }
    
    /**
     * Set audio manager for sound effects
     */
    setAudioManager(audioManager) {
        this.audioManager = audioManager;
        // Pass audio manager to all sheep instances
        this.sheep.forEach(sheep => {
            sheep.setAudioManager(audioManager);
        });
    }
    
    /**
     * Reset all sheep to their starting positions and states
     */
    resetAllSheep() {
        const dummy = new THREE.Object3D();
        const spreadRadius = 30;
        
        for (let i = 0; i < this.sheepCount; i++) {
            const sheep = this.sheep[i];
            
            // Reset position to starting area
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * spreadRadius;
            const x = -30 + Math.cos(angle) * distance;
            const z = -30 + Math.sin(angle) * distance;
            
            // Reset sheep state - now using the set method
            sheep.position.set(x, z);
            sheep.velocity.set(0, 0);
            sheep.acceleration.set(0, 0);
            sheep.hasPassedGate = false;
            sheep.isRetiring = false;
            sheep.retirementTarget = null;
            sheep.state = 0; // Active state
            sheep.maxSpeed = 0.1;
            sheep.maxForce = 0.02;
            
            // Reset animation properties
            sheep.animationPhase = Math.random() * Math.PI * 2;
            sheep.walkCycle = 0;
            sheep.bounceAmount = 0;
            sheep.currentSpeed = 0;
            sheep.facingDirection = Math.random() * Math.PI * 2;
            sheep.blinkTimer = Math.random() * 5;
            
            // Reset interpolated render position to match physics position
            sheep.renderPosition.set(x, z);
            sheep.renderFacingDirection = sheep.facingDirection;
            
            // Update transform matrix
            dummy.position.set(x, 0, z);
            dummy.rotation.y = sheep.facingDirection;
            dummy.scale.set(1, 1, 1);
            dummy.updateMatrix();
            this.instancedMesh.setMatrixAt(i, dummy.matrix);
            
            // Update animation attributes
            this.updateInstanceAttributes(i, sheep);
        }
        
        this.instancedMesh.instanceMatrix.needsUpdate = true;
    }
}

/**
 * Individual sheep instance data
 */
export class OptimizedSheepInstance extends Boid {
    constructor(id, x, z) {
        super(x, z, {
            maxSpeed: 0.1,
            maxForce: 0.02,
            perceptionRadius: 5
        });
        
        this.id = id;
        this.state = 0; // 0: active, 1: retiring, 2: retired
        
        // Animation properties
        this.animationPhase = Math.random() * Math.PI * 2;
        this.walkCycle = 0;
        this.bounceAmount = 0;
        this.currentSpeed = 0;
        this.facingDirection = 0;
        this.blinkTimer = Math.random() * 5;
        
        // Interpolation properties for smooth visual movement
        this.renderPosition = new Vector2D(x, z); // Smoothed position for rendering
        this.renderFacingDirection = 0; // Smoothed facing direction for rendering
        this.interpolationSpeed = 8.0; // How fast to interpolate (higher = faster catch-up)
        this.rotationInterpolationSpeed = 12.0; // Faster rotation interpolation
        
        // Behavior properties
        this.hasPassedGate = false;
        this.isRetiring = false;
        this.retirementTarget = null;
        this.fleeRadius = 8;
        this.gateAttraction = 0.5;
        this.audioManager = null;
        
        // Audio tracking
        this.wasBeingChased = false;
    }
    
    updateBehavior(allSheep, sheepdog, gate, pasture, bounds, params, enableIndividualBleating = true) {
        // If retiring, seek retirement target or graze
        if (this.isRetiring) {
            if (this.retirementTarget) {
                const distanceToTarget = this.position.distanceTo(this.retirementTarget);
                
                if (distanceToTarget < 2) {
                    // Sheep has reached its retirement spot - enter grazing mode
                    this.retirementTarget = null; // Clear target to enter grazing mode
                    this.maxSpeed = 0.02; // Very slow grazing speed
                    this.maxForce = 0.005; // Gentle forces
                    this.state = 2; // Set to grazing state
                } else {
                    // Still moving to retirement spot
                    const seekForce = this.seek(this.retirementTarget);
                    this.applyForce(seekForce);
                }
            } else {
                // Grazing behavior - gentle wandering
                this.animationPhase += 0.016;
                
                // Occasional gentle movement
                if (Math.random() < 0.002) { // 0.2% chance per frame to start moving
                    const wanderDirection = Vector2D.random();
                    wanderDirection.multiply(0.5); // Gentle movement
                    this.applyForce(wanderDirection);
                }
                
                // Stay within pasture bounds with gentle forces
                if (pasture) {
                    const pastureMargin = 2;
                    const steer = new Vector2D(0, 0);
                    
                    if (this.position.x < pasture.minX + pastureMargin) {
                        steer.x = 0.01;
                    } else if (this.position.x > pasture.maxX - pastureMargin) {
                        steer.x = -0.01;
                    }
                    
                    if (this.position.z < pasture.minZ + pastureMargin) {
                        steer.z = 0.01;
                    } else if (this.position.z > pasture.maxZ - pastureMargin) {
                        steer.z = -0.01;
                    }
                    
                    if (steer.magnitude() > 0) {
                        this.applyForce(steer);
                    }
                }
            }
            return;
        }
        
        // Only check gate passage if gate and pasture are available (game is active)
        if (gate && pasture && this.hasPassedGate && !this.isRetiring) {
            this.isRetiring = true;
            this.state = 1; // retiring
            this.retirementTarget = new Vector2D(
                pasture.minX + Math.random() * (pasture.maxX - pasture.minX),
                pasture.centerZ + Math.random() * 20
            );
            this.maxSpeed *= 0.5;
            this.maxForce *= 0.5;
            return;
        }
        
        // Normal flocking behavior (always active)
        this.flock(allSheep, params.separationDistance);
        
        // Add gentle wandering during pre-game state (when no sheepdog)
        if (!sheepdog) {
            // Gentle wandering to make the start screen more lively
            if (Math.random() < 0.01) { // 1% chance per frame for gentle movement
                const wanderDirection = Vector2D.random();
                wanderDirection.multiply(0.3); // Gentle wandering force
                this.applyForce(wanderDirection);
            }
        }
        
        // Flee from sheepdog (only if sheepdog exists - game is active)
        if (sheepdog) {
            const distanceToSheepdog = this.position.distanceTo(sheepdog.position);
            const isBeingChased = distanceToSheepdog < this.fleeRadius;
            
            const fleeForce = this.flee(sheepdog.position, this.fleeRadius);
            if (fleeForce.magnitude() > 0) {
                fleeForce.multiply(1.2);
                this.applyForce(fleeForce);
                
                // Play bleat sound when sheep starts being chased (only if individual bleating is enabled)
                if (isBeingChased && !this.wasBeingChased && this.audioManager && enableIndividualBleating) {
                    this.audioManager.playSheepBleat();
                }
            }
            
            this.wasBeingChased = isBeingChased;
        } else {
            this.wasBeingChased = false;
        }
        
        // Gate attraction logic (only if sheepdog and gate exist - game is active)
        if (sheepdog && gate) {
            const distanceToGate = this.position.distanceTo(gate.position);
            const distanceToDog = this.position.distanceTo(sheepdog.position);
            
            if (distanceToDog < this.fleeRadius * 1.5 && distanceToGate < 30) {
                const toGate = gate.position.clone().subtract(this.position);
                const toDog = sheepdog.position.clone().subtract(this.position);
                
                const dotProduct = toGate.x * toDog.x + toGate.z * toDog.z;
                if (dotProduct < 0) {
                    const gateForce = this.seek(gate.position);
                    gateForce.multiply(this.gateAttraction);
                    this.applyForce(gateForce);
                }
            }
        }
        
        // Boundary avoidance (always active)
        const boundaryForce = this.avoidBoundariesWithGate(bounds, gate);
        this.applyForce(boundaryForce);
        
        this.maxSpeed = params.speed;
        this.cohesionWeight = params.cohesion;
    }
    
    updatePosition(deltaTime) {
        // Standard Boid update
        super.update(deltaTime); // This updates this.position and this.velocity
        
        // HARD BOUNDARY CONSTRAINT - Apply only to sheep that haven't passed the gate
        if (this.bounds && !this.hasPassedGate) {
            const margin = 0.2; // Small margin from edge
            
            // Check if sheep is in the gate area (allow passage through gate)
            const inGateArea = Math.abs(this.position.x) <= 4 && this.position.z >= 98 && this.position.z <= 102;
            
            // Apply hard constraints unless in gate area
            if (!inGateArea) {
                this.position.x = Math.max(this.bounds.minX + margin, Math.min(this.bounds.maxX - margin, this.position.x));
                this.position.z = Math.max(this.bounds.minZ + margin, Math.min(this.bounds.maxZ - margin, this.position.z));
            } else {
                // In gate area - only constrain X to gate width, allow Z movement
                this.position.x = Math.max(-4, Math.min(4, this.position.x));
                // Don't constrain Z in gate area to allow passage
            }
        }
        
        // NaN/Infinity checks for velocity and position
        if (isNaN(this.velocity.x) || isNaN(this.velocity.z) || !isFinite(this.velocity.x) || !isFinite(this.velocity.z)) {
            console.warn(`Sheep ${this.id} velocity became NaN/Infinity:`, this.velocity.x, this.velocity.z);
            this.velocity.set(0, 0); // Reset velocity
        }
        if (isNaN(this.position.x) || isNaN(this.position.z) || !isFinite(this.position.x) || !isFinite(this.position.z)) {
            console.warn(`Sheep ${this.id} position became NaN/Infinity:`, this.position.x, this.position.z);
            // Attempt to reset to a safe position, e.g., center of field, or last known good position
            this.position.set(0, -30); // Reset to initial-like position
            this.velocity.set(0, 0); // Also reset velocity
        }
        
        // Update animation parameters based on movement
        const speed = this.velocity.magnitude();
        
        if (isNaN(speed) || !isFinite(speed)) {
            console.warn(`Sheep ${this.id} speed became NaN/Infinity.`);
            this.currentSpeed = 0;
            this.bounceAmount = 0;
        } else {
            this.currentSpeed = speed / (this.maxSpeed > 0.00001 ? this.maxSpeed : 0.1); // Avoid division by zero for maxSpeed
            this.bounceAmount = Math.min(speed * 15, 0.15);
        }
        
        this.walkCycle += this.currentSpeed * deltaTime * 10; // Use currentSpeed which is now NaN-checked
        
        if (this.currentSpeed > 0.001) {
            this.facingDirection = Math.atan2(this.velocity.z, this.velocity.x);
            if (isNaN(this.facingDirection) || !isFinite(this.facingDirection)) {
                console.warn(`Sheep ${this.id} facingDirection became NaN/Infinity.`);
                this.facingDirection = 0;
            }
        } else {
             // Keep last facing direction if not moving, or default to 0
            // this.facingDirection = this.facingDirection || 0;
        }
        
        // Update blink timer
        this.blinkTimer += deltaTime;
        if (this.blinkTimer > 3 + Math.random() * 4) {
            this.blinkTimer = 0;
        }
        
        // Interpolate render position for smooth visual movement
        this.updateRenderPosition(deltaTime);
    }
    
    /**
     * Update interpolated render position for smooth visual movement
     */
    updateRenderPosition(deltaTime) {
        // Interpolate position smoothly towards actual physics position
        const positionDiff = this.position.clone().subtract(this.renderPosition);
        const interpolationAmount = Math.min(1.0, this.interpolationSpeed * deltaTime);
        
        // Apply position interpolation
        this.renderPosition.add(positionDiff.multiply(interpolationAmount));
        
        // Interpolate facing direction smoothly
        if (this.currentSpeed > 0.001) {
            // Calculate target facing direction from velocity
            const targetFacing = Math.atan2(this.velocity.z, this.velocity.x);
            
            // Handle angle wrapping for smooth rotation
            let angleDiff = targetFacing - this.renderFacingDirection;
            
            // Normalize angle difference to [-π, π]
            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
            
            // Apply rotation interpolation
            const rotationInterpolationAmount = Math.min(1.0, this.rotationInterpolationSpeed * deltaTime);
            this.renderFacingDirection += angleDiff * rotationInterpolationAmount;
            
            // Normalize final angle
            while (this.renderFacingDirection > Math.PI) this.renderFacingDirection -= 2 * Math.PI;
            while (this.renderFacingDirection < -Math.PI) this.renderFacingDirection += 2 * Math.PI;
        }
    }
    
    // Boundary avoidance that excludes gate area
    avoidBoundariesWithGate(bounds, gate) {
        const margin = 3;
        const steer = new Vector2D(0, 0);
        const position = this.position;
        
        const distToMinX = position.x - bounds.minX;
        const distToMaxX = bounds.maxX - position.x;
        const distToMinZ = position.z - bounds.minZ;
        const distToMaxZ = bounds.maxZ - position.z;
        
        if (distToMinX < margin) {
            const force = (margin - distToMinX) / margin;
            steer.x = this.maxSpeed * force * 1.2;
        } else if (distToMaxX < margin) {
            const force = (margin - distToMaxX) / margin;
            steer.x = -this.maxSpeed * force * 1.2;
        }
        
        if (distToMinZ < margin) {
            const force = (margin - distToMinZ) / margin;
            steer.z = this.maxSpeed * force * 1.2;
        } else if (distToMaxZ < margin) {
            // Only check for gate if gate exists (game is active)
            const nearGateX = gate ? Math.abs(position.x - gate.position.x) < gate.width / 2 + 2 : false;
            if (!nearGateX) {
                const force = (margin - distToMaxZ) / margin;
                steer.z = -this.maxSpeed * force * 1.2;
            }
        }
        
        if (steer.magnitude() > 0) {
            steer.normalize();
            steer.multiply(this.maxSpeed * 1.5);
            steer.subtract(this.velocity);
            steer.limit(this.maxForce * 2.5);
        }
        
        return steer;
    }
    
    checkGatePassageAndRetire(gatePassageZone, pastureBounds) {
        if (this.hasPassedGate) return false;
        
        const inGateX = this.position.x >= gatePassageZone.minX && 
                       this.position.x <= gatePassageZone.maxX;
        const inGateZ = this.position.z >= gatePassageZone.minZ && 
                       this.position.z <= gatePassageZone.maxZ;
        
        if (inGateX && inGateZ && this.velocity.z > 0) {
            this.hasPassedGate = true;
            return true;
        }
        
        return false;
    }
    
    setBounds(bounds) {
        this.bounds = bounds;
    }
    
    setAudioManager(audioManager) {
        this.audioManager = audioManager;
    }
}
```

## js/PerformanceMonitor.js

```javascript
/**
 * PerformanceMonitor.js
 * 
 * Comprehensive performance monitoring system for the sheep dog simulation.
 * Integrates Stats.js for real-time FPS/memory tracking and provides
 * custom metrics for simulation-specific performance analysis.
 */

/**
 * Performance monitoring and statistics display
 * Provides real-time FPS, memory usage, and simulation-specific metrics
 */
export class PerformanceMonitor {
    constructor() {
        this.stats = null;
        this.customStats = null;
        this.isEnabled = false;
        this.frameCount = 0;
        this.lastFrameTime = performance.now();
        this.frameTimeHistory = [];
        this.maxHistoryLength = 60; // Keep 1 second of frame times at 60fps
        
        // Performance metrics
        this.metrics = {
            sheepCount: 0,
            activeSheepCount: 0,
            grassInstances: 0,
            drawCalls: 0,
            triangles: 0,
            avgFrameTime: 0,
            minFrameTime: Infinity,
            maxFrameTime: 0,
            geometries: 0,
            textures: 0,
            programs: 0
        };
        
        this.init();
    }
    
    /**
     * Initialize Stats.js and custom performance displays
     */
    async init() {
        try {
            // Try to load Stats.js from CDN using a script tag
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js';
            
            await new Promise((resolve, reject) => {
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
            
            // Wait a bit for Stats to be available globally
            await new Promise(resolve => setTimeout(resolve, 100));
            
            if (typeof Stats !== 'undefined') {
                // Create main Stats.js instance for FPS
                this.stats = new Stats();
                this.stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
                this.stats.dom.style.position = 'absolute';
                this.stats.dom.style.left = '20px';
                this.stats.dom.style.top = '120px';
                this.stats.dom.style.zIndex = '100';
                
                // Create custom stats panel for simulation metrics
                this.createCustomStatsPanel();
                
                // Add to DOM but hide by default
                document.body.appendChild(this.stats.dom);
                document.body.appendChild(this.customStats);
                
                // Hide stats by default
                this.stats.dom.style.display = 'none';
                this.customStats.style.display = 'none';
                
                this.isEnabled = true;
                console.log('PerformanceMonitor: Stats.js integration successful');
            } else {
                throw new Error('Stats.js not available');
            }
            
        } catch (error) {
            console.warn('PerformanceMonitor: Failed to load Stats.js, using fallback metrics', error);
            this.createFallbackDisplay();
        }
    }
    
    /**
     * Create custom statistics panel for simulation-specific metrics
     */
    createCustomStatsPanel() {
        this.customStats = document.createElement('div');
        this.customStats.style.cssText = `
            position: absolute;
            left: 20px;
            top: 200px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 8px;
            border-radius: 4px;
            z-index: 100;
            min-width: 180px;
            line-height: 1.4;
        `;
        
        this.updateCustomStats();
    }
    
    /**
     * Create fallback display when Stats.js fails to load
     */
    createFallbackDisplay() {
        this.customStats = document.createElement('div');
        this.customStats.style.cssText = `
            position: absolute;
            left: 20px;
            top: 120px;
            background: rgba(0, 0, 0, 0.8);
            color: #ffff00;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 8px;
            border-radius: 4px;
            z-index: 100;
            min-width: 200px;
            line-height: 1.4;
        `;
        
        document.body.appendChild(this.customStats);
        
        // Hide stats by default
        this.customStats.style.display = 'none';
        
        this.isEnabled = true;
    }
    
    /**
     * Update performance metrics
     * @param {Object} gameState - Current game state
     * @param {Object} renderer - Three.js renderer
     */
    updateMetrics(gameState, renderer) {
        if (!this.isEnabled) return;
        
        const currentTime = performance.now();
        const frameTime = currentTime - this.lastFrameTime;
        this.lastFrameTime = currentTime;
        
        // Update frame time statistics
        this.frameTimeHistory.push(frameTime);
        if (this.frameTimeHistory.length > this.maxHistoryLength) {
            this.frameTimeHistory.shift();
        }
        
        // Calculate frame time metrics
        this.metrics.avgFrameTime = this.frameTimeHistory.reduce((a, b) => a + b, 0) / this.frameTimeHistory.length;
        this.metrics.minFrameTime = Math.min(this.metrics.minFrameTime, frameTime);
        this.metrics.maxFrameTime = Math.max(this.metrics.maxFrameTime, frameTime);
        
        // Update simulation metrics
        if (gameState) {
            const sheep = gameState.getSheep();
            this.metrics.sheepCount = sheep ? sheep.length : 0;
            // Count sheep that haven't passed the gate and aren't retiring (active sheep)
            this.metrics.activeSheepCount = sheep ? sheep.filter(s => !s.hasPassedGate && !s.isRetiring).length : 0;
        }
        
        // Update renderer metrics
        if (renderer && renderer.info) {
            this.metrics.drawCalls = renderer.info.render.calls;
            this.metrics.triangles = renderer.info.render.triangles;
            this.metrics.geometries = renderer.info.memory.geometries;
            this.metrics.textures = renderer.info.memory.textures;
            this.metrics.programs = renderer.info.programs ? renderer.info.programs.length : 0;
        }
        
        this.frameCount++;
        
        // Update displays
        if (this.stats) {
            this.stats.update();
        }
        
        // Update custom stats every 10 frames to reduce overhead
        if (this.frameCount % 10 === 0) {
            this.updateCustomStats();
        }
    }
    
    /**
     * Update custom statistics display
     */
    updateCustomStats() {
        if (!this.customStats) return;
        
        const fps = this.frameTimeHistory.length > 0 ? 
            (1000 / this.metrics.avgFrameTime).toFixed(1) : '0';
        
        const memoryInfo = this.getMemoryInfo();
        
        // Color-code FPS for performance indication
        const fpsColor = parseFloat(fps) >= 58 ? '#00ff00' : parseFloat(fps) >= 45 ? '#ffff00' : '#ff4444';
        
        this.customStats.innerHTML = `
            <div style="color: #00ff00; font-weight: bold; margin-bottom: 4px;">SIMULATION STATS</div>
            <div>Sheep Total: ${this.metrics.sheepCount}</div>
            <div>Sheep Active: ${this.metrics.activeSheepCount}</div>
            <div>Grass Instances: ${this.metrics.grassInstances.toLocaleString()}</div>
            <div style="margin-top: 4px; color: #ffff00;">RENDER STATS</div>
            <div>Draw Calls: ${this.metrics.drawCalls}</div>
            <div>Triangles: ${this.metrics.triangles.toLocaleString()}</div>
            <div>Geometries: ${this.metrics.geometries}</div>
            <div>Textures: ${this.metrics.textures}</div>
            <div>Programs: ${this.metrics.programs}</div>
            <div style="margin-top: 4px; color: #ff8800;">FRAME STATS</div>
            <div style="color: ${fpsColor};">Avg FPS: ${fps}</div>
            <div>Frame Time: ${this.metrics.avgFrameTime.toFixed(2)}ms</div>
            <div>Min/Max: ${this.metrics.minFrameTime.toFixed(1)}/${this.metrics.maxFrameTime.toFixed(1)}ms</div>
            ${memoryInfo}
        `;
    }
    
    /**
     * Get memory information if available
     */
    getMemoryInfo() {
        if (performance.memory) {
            const used = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
            const total = (performance.memory.totalJSHeapSize / 1048576).toFixed(1);
            return `
                <div style="margin-top: 4px; color: #ff4444;">MEMORY</div>
                <div>Used: ${used} MB</div>
                <div>Total: ${total} MB</div>
            `;
        }
        return '';
    }
    
    /**
     * Set grass instance count for display
     * @param {number} count - Number of grass instances
     */
    setGrassInstanceCount(count) {
        this.metrics.grassInstances = count;
    }
    
    /**
     * Toggle performance monitor visibility
     */
    toggle() {
        if (!this.isEnabled) return;
        
        const isVisible = this.stats ? this.stats.dom.style.display !== 'none' : 
                         this.customStats.style.display !== 'none';
        
        if (this.stats) {
            this.stats.dom.style.display = isVisible ? 'none' : 'block';
        }
        if (this.customStats) {
            this.customStats.style.display = isVisible ? 'none' : 'block';
        }
    }
    
    /**
     * Show performance monitor
     */
    show() {
        if (!this.isEnabled) return;
        
        if (this.stats) {
            this.stats.dom.style.display = 'block';
        }
        if (this.customStats) {
            this.customStats.style.display = 'block';
        }
    }
    
    /**
     * Hide performance monitor
     */
    hide() {
        if (!this.isEnabled) return;
        
        if (this.stats) {
            this.stats.dom.style.display = 'none';
        }
        if (this.customStats) {
            this.customStats.style.display = 'none';
        }
    }
    
    /**
     * Reset performance statistics
     */
    reset() {
        this.frameTimeHistory = [];
        this.metrics.minFrameTime = Infinity;
        this.metrics.maxFrameTime = 0;
        this.frameCount = 0;
    }
    
    /**
     * Get current performance metrics
     * @returns {Object} Current metrics object
     */
    getMetrics() {
        return { ...this.metrics };
    }
    
    /**
     * Check if performance monitor is enabled
     * @returns {boolean} True if enabled
     */
    isActive() {
        return this.isEnabled;
    }
    
    /**
     * Get performance recommendations based on current metrics
     * @returns {Array} Array of performance recommendations
     */
    getPerformanceRecommendations() {
        const recommendations = [];
        const avgFps = this.frameTimeHistory.length > 0 ? 
            (1000 / this.metrics.avgFrameTime) : 0;
        
        if (avgFps < 45) {
            recommendations.push("Low FPS detected. Consider reducing grass instances or shadow quality.");
        }
        
        if (this.metrics.drawCalls > 50) {
            recommendations.push("High draw call count. Consider using more instanced rendering.");
        }
        
        if (this.metrics.triangles > 2000000) {
            recommendations.push("High triangle count. Consider using LOD (Level of Detail) systems.");
        }
        
        if (this.metrics.grassInstances > 500000 && avgFps < 60) {
            recommendations.push("Grass instance count may be too high for current hardware.");
        }
        
        return recommendations;
    }
    
    /**
     * Log performance summary to console
     */
    logPerformanceSummary() {
        if (!this.isEnabled) return;
        
        const avgFps = this.frameTimeHistory.length > 0 ? 
            (1000 / this.metrics.avgFrameTime).toFixed(1) : '0';
        
        console.group('🔍 Performance Summary');
        console.log(`📊 Average FPS: ${avgFps}`);
        console.log(`🐑 Active Sheep: ${this.metrics.activeSheepCount}/${this.metrics.sheepCount}`);
        console.log(`🌱 Grass Instances: ${this.metrics.grassInstances.toLocaleString()}`);
        console.log(`🎨 Draw Calls: ${this.metrics.drawCalls}`);
        console.log(`📐 Triangles: ${this.metrics.triangles.toLocaleString()}`);
        console.log(`⏱️ Frame Time: ${this.metrics.avgFrameTime.toFixed(2)}ms`);
        
        const recommendations = this.getPerformanceRecommendations();
        if (recommendations.length > 0) {
            console.group('💡 Recommendations');
            recommendations.forEach(rec => console.log(`• ${rec}`));
            console.groupEnd();
        }
        
        console.groupEnd();
    }
}
```

## js/SceneManager.js

```javascript
import * as THREE from 'three';

/**
 * SceneManager - Handles Three.js scene setup, lighting, and camera management
 * Enhanced with mobile zoom control support
 */
export class SceneManager {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(
            75, 
            window.innerWidth / window.innerHeight, 
            0.1, 
            1000
        );
        
        this.renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance", // Use discrete GPU if available
            stencil: false // Disable stencil buffer if not needed
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        // Performance optimizations
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        
        // Enable frustum culling and other optimizations
        this.renderer.sortObjects = true;
        this.renderer.autoClear = true;
        
        document.getElementById('canvas-container').appendChild(this.renderer.domElement);
        
        // Camera control
        this.cameraDistance = 80;
        this.minCameraDistance = 20;
        this.maxCameraDistance = 150;
        this.mobileControls = null;
        
        this.init();
    }
    
    init() {
        // Set scene background
        this.scene.background = new THREE.Color(0x87CEEB); // Sky blue
        this.scene.fog = new THREE.Fog(0x87CEEB, 200, 600); // Extended fog for larger world
        
        // Setup camera - adjusted for larger field
        this.camera.position.set(0, 60, -60);
        this.camera.lookAt(0, 0, 0);
        
        // Add lighting
        this.setupLighting();
        
        // Handle window resize
        window.addEventListener('resize', () => this.onWindowResize());
    }
    
    setupLighting() {
        // Ambient light - adjusted for new lighting model (multiply by PI for similar appearance)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7 * Math.PI);
        this.scene.add(ambientLight);
        
        // Directional light (sun) - adjusted for new lighting model
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8 * Math.PI);
        directionalLight.position.set(30, 70, 30);
        directionalLight.castShadow = true;
        
        // Shadow configuration - adjusted for larger field
        directionalLight.shadow.camera.left = -120;
        directionalLight.shadow.camera.right = 120;
        directionalLight.shadow.camera.top = 120;
        directionalLight.shadow.camera.bottom = -120;
        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 150;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        
        this.scene.add(directionalLight);
        
        // Add a subtle secondary light for better depth - adjusted for new lighting model
        const secondaryLight = new THREE.DirectionalLight(0xffd4a3, 0.3 * Math.PI);
        secondaryLight.position.set(-50, 40, -50);
        this.scene.add(secondaryLight);
    }
    
    updateCamera(sheepdog) {
        // Update camera to follow sheepdog - adjusted for dynamic zoom
        const cameraOffset = new THREE.Vector3(0, this.cameraDistance, -this.cameraDistance);
        const targetPosition = new THREE.Vector3(
            sheepdog.position.x,
            0,
            sheepdog.position.z
        );
        
        this.camera.position.lerp(targetPosition.clone().add(cameraOffset), 0.05);
        this.camera.lookAt(targetPosition);
    }
    
    // Set mobile controls reference for zoom integration
    setMobileControls(mobileControls) {
        this.mobileControls = mobileControls;
        
        // Set up zoom change callback for mobile controls
        if (mobileControls) {
            mobileControls.setZoomChangeCallback((zoomLevel) => {
                this.cameraDistance = zoomLevel;
            });
        }
    }
    
    setupMouseControls() {
        // Mouse wheel for zoom (desktop only)
        this.renderer.domElement.addEventListener('wheel', (event) => {
            event.preventDefault();
            
            // Only handle mouse wheel if not on mobile device
            if (this.mobileControls && this.mobileControls.getIsTouchDevice()) {
                return;
            }
            
            const zoomSpeed = 5;
            
            if (event.deltaY > 0) {
                // Zoom out
                this.cameraDistance = Math.min(this.maxCameraDistance, this.cameraDistance + zoomSpeed);
            } else {
                // Zoom in
                this.cameraDistance = Math.max(this.minCameraDistance, this.cameraDistance - zoomSpeed);
            }
            
            // Update mobile zoom slider if available
            if (this.mobileControls && this.mobileControls.zoomSlider) {
                this.mobileControls.zoomSlider.value = this.cameraDistance;
                this.mobileControls.zoomLevel = this.cameraDistance;
            }
        });
    }
    
    // Get current camera distance for mobile controls synchronization
    getCameraDistance() {
        return this.cameraDistance;
    }
    
    // Set camera distance (used by mobile controls)
    setCameraDistance(distance) {
        this.cameraDistance = Math.max(this.minCameraDistance, 
                                     Math.min(this.maxCameraDistance, distance));
    }
    
    render() {
        this.renderer.render(this.scene, this.camera);
    }
    
    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    add(object) {
        this.scene.add(object);
    }
    
    getScene() {
        return this.scene;
    }
    
    getCamera() {
        return this.camera;
    }
    
    getRenderer() {
        return this.renderer;
    }
}
```

## js/Sheepdog.js

```javascript
import * as THREE from 'three';
import { Vector2D } from './Vector2D.js';

/**
 * Sheepdog class - player controlled entity
 * Toony design with smooth animations and buttery controls
 */
export class Sheepdog {
    constructor(x, z) {
        this.position = new Vector2D(x, z);
        this.velocity = new Vector2D(0, 0);
        this.targetVelocity = new Vector2D(0, 0);
        
        // Movement parameters for smooth control
        this.maxSpeed = 15; // Normal max speed
        this.sprintSpeed = 25; // Sprint max speed
        this.acceleration = 40; // How fast we reach max speed
        this.deceleration = 30; // How fast we stop
        this.turnSpeed = 8; // How fast we rotate
        
        // Stamina system
        this.maxStamina = 100;
        this.stamina = this.maxStamina;
        this.staminaDrainRate = 30; // Stamina per second when sprinting
        this.staminaRegenRate = 20; // Stamina per second when not sprinting
        this.minStaminaToSprint = 10; // Minimum stamina needed to start sprinting
        this.isSprinting = false;
        
        // Animation properties
        this.animationTime = 0;
        this.runCycle = 0;
        this.tailWag = 0;
        this.earFlap = 0;
        this.currentRotation = 0;
        this.targetRotation = 0;
        
        // Idle animation properties
        this.idleTime = 0;
        this.nextIdleAction = 0;
        this.currentIdleAction = 'breathing';
        this.idleActionDuration = 0;
        this.lookDirection = 0;
        this.targetLookDirection = 0;
        
        // Store references to animated parts
        this.animatedParts = {
            body: null,
            head: null,
            tail: null,
            ears: [],
            legs: [],
            tongue: null
        };
        
        this.mesh = null;
        this.isMoving = false;
        this.audioManager = null;
        
        // Audio tracking
        this.lastBarkTime = 0;
        this.barkCooldown = 2000; // 2 seconds between barks
        this.nearSheep = false; // Track if dog is near sheep for barking
        
        // Initialize shared resources
        this.initializeSharedResources();
    }
    
    // Static initialization for shared resources
    initializeSharedResources() {
        if (Sheepdog.sharedGeometries) return;
        
        Sheepdog.sharedGeometries = {
            // Body parts
            body: new THREE.CapsuleGeometry(0.35, 1.0, 6, 8),
            chest: new THREE.SphereGeometry(0.3, 8, 6),
            head: new THREE.SphereGeometry(0.35, 8, 6),
            snout: new THREE.ConeGeometry(0.2, 0.4, 6),
            nose: new THREE.SphereGeometry(0.08, 6, 5),
            
            // Features
            eye: new THREE.SphereGeometry(0.08, 6, 5),
            pupil: new THREE.SphereGeometry(0.04, 5, 4),
            ear: new THREE.TetrahedronGeometry(0.25, 0),
            
            // Limbs
            leg: new THREE.CapsuleGeometry(0.08, 0.4, 4, 6),
            paw: new THREE.SphereGeometry(0.12, 6, 5),
            
            // Tail segments
            tailBase: new THREE.CylinderGeometry(0.12, 0.08, 0.3, 6),
            tailMid: new THREE.CylinderGeometry(0.08, 0.06, 0.3, 6),
            tailTip: new THREE.SphereGeometry(0.08, 6, 5),
            
            // Tongue
            tongue: new THREE.BoxGeometry(0.15, 0.02, 0.2)
        };
        
        Sheepdog.sharedMaterials = {
            // Main colors
            blackFur: new THREE.MeshToonMaterial({ 
                color: 0x2a2a2a,
                emissive: 0x1a1a1a,
                emissiveIntensity: 0.1,
                fog: true
            }),
            whiteFur: new THREE.MeshToonMaterial({ 
                color: 0xffffff,
                emissive: 0xf5f5f5,
                emissiveIntensity: 0.1,
                fog: true
            }),
            
            // Features
            nose: new THREE.MeshToonMaterial({
                color: 0x222222,
                fog: true
            }),
            eye: new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                fog: false
            }),
            pupil: new THREE.MeshBasicMaterial({ 
                color: 0x000000,
                fog: false
            }),
            tongue: new THREE.MeshToonMaterial({
                color: 0xff6b9d,
                emissive: 0xff4b7d,
                emissiveIntensity: 0.2,
                fog: true
            })
        };
        
        // Create gradient map for toon shading
        const gradientTexture = new THREE.DataTexture(
            new Uint8Array([0, 0, 0, 255, 100, 100, 100, 255, 200, 200, 200, 255, 255, 255, 255, 255]),
            4, 1, THREE.RGBAFormat
        );
        gradientTexture.magFilter = THREE.NearestFilter;
        gradientTexture.minFilter = THREE.NearestFilter;
        
        // Apply gradient map
        Sheepdog.sharedMaterials.blackFur.gradientMap = gradientTexture;
        Sheepdog.sharedMaterials.whiteFur.gradientMap = gradientTexture;
        Sheepdog.sharedMaterials.nose.gradientMap = gradientTexture;
        Sheepdog.sharedMaterials.tongue.gradientMap = gradientTexture;
    }

    // Create Three.js mesh for the sheepdog
    createMesh() {
        const geom = Sheepdog.sharedGeometries;
        const mat = Sheepdog.sharedMaterials;
        
        this.mesh = new THREE.Group();
        
        // BODY GROUP (will bounce)
        const bodyGroup = new THREE.Group();
        this.animatedParts.body = bodyGroup;
        
        // Main body (black with white chest)
        const body = new THREE.Mesh(geom.body, mat.blackFur);
        body.rotation.x = Math.PI / 2; // Rotate around X axis to make it horizontal
        body.position.set(0, 0, 0);
        body.castShadow = true;
        body.receiveShadow = true;
        bodyGroup.add(body);
        
        // White chest/belly
        const chest = new THREE.Mesh(geom.chest, mat.whiteFur);
        chest.position.set(0, -0.15, 0.3);
        chest.scale.set(0.6, 0.5, 0.4);
        bodyGroup.add(chest);
        
        // HEAD GROUP
        const headGroup = new THREE.Group();
        this.animatedParts.head = headGroup;
        
        // Head (black)
        const head = new THREE.Mesh(geom.head, mat.blackFur);
        head.scale.set(1, 0.9, 1);
        headGroup.add(head);
        
        // White muzzle marking
        const muzzle = new THREE.Mesh(geom.snout, mat.whiteFur);
        muzzle.rotation.x = -Math.PI / 2;
        muzzle.position.set(0, -0.05, 0.35);
        muzzle.scale.set(0.8, 0.8, 0.9);
        headGroup.add(muzzle);
        
        // Snout (black)
        const snout = new THREE.Mesh(geom.snout, mat.blackFur);
        snout.rotation.x = -Math.PI / 2;
        snout.position.set(0, -0.05, 0.4);
        snout.scale.set(0.6, 0.6, 0.7);
        headGroup.add(snout);
        
        // Nose
        const nose = new THREE.Mesh(geom.nose, mat.nose);
        nose.position.set(0, -0.05, 0.55);
        headGroup.add(nose);
        
        // EYES
        const leftEye = new THREE.Mesh(geom.eye, mat.eye);
        leftEye.position.set(-0.12, 0.05, 0.25);
        headGroup.add(leftEye);
        
        const leftPupil = new THREE.Mesh(geom.pupil, mat.pupil);
        leftPupil.position.set(-0.12, 0.05, 0.3);
        headGroup.add(leftPupil);
        
        const rightEye = new THREE.Mesh(geom.eye, mat.eye);
        rightEye.position.set(0.12, 0.05, 0.25);
        headGroup.add(rightEye);
        
        const rightPupil = new THREE.Mesh(geom.pupil, mat.pupil);
        rightPupil.position.set(0.12, 0.05, 0.3);
        headGroup.add(rightPupil);
        
        // EARS (floppy border collie style)
        const leftEar = new THREE.Mesh(geom.ear, mat.blackFur);
        leftEar.scale.set(1, 1.5, 0.5);
        leftEar.position.set(-0.25, 0.1, -0.1);
        leftEar.rotation.set(0, 0, 0.8);
        this.animatedParts.ears.push(leftEar);
        headGroup.add(leftEar);
        
        const rightEar = new THREE.Mesh(geom.ear, mat.blackFur);
        rightEar.scale.set(1, 1.5, 0.5);
        rightEar.position.set(0.25, 0.1, -0.1);
        rightEar.rotation.set(0, 0, -0.8);
        this.animatedParts.ears.push(rightEar);
        headGroup.add(rightEar);
        
        // TONGUE (hanging out when running)
        const tongue = new THREE.Mesh(geom.tongue, mat.tongue);
        tongue.position.set(0.1, -0.2, 0.45);
        tongue.rotation.z = 0.1;
        tongue.visible = false; // Hidden by default
        this.animatedParts.tongue = tongue;
        headGroup.add(tongue);
        
        headGroup.position.set(0, 0.45, 0.7);
        bodyGroup.add(headGroup);
        
        // TAIL (segmented for wagging)
        const tailGroup = new THREE.Group();
        
        const tailBase = new THREE.Mesh(geom.tailBase, mat.blackFur);
        tailBase.rotation.z = -0.7;
        tailBase.position.set(0, 0.1, -0.6);
        tailGroup.add(tailBase);
        
        const tailMid = new THREE.Mesh(geom.tailMid, mat.blackFur);
        tailMid.rotation.z = -0.5;
        tailMid.position.set(0, 0.25, -0.8);
        tailGroup.add(tailMid);
        
        const tailTip = new THREE.Mesh(geom.tailTip, mat.whiteFur);
        tailTip.position.set(0, 0.35, -0.95);
        tailGroup.add(tailTip);
        
        this.animatedParts.tail = tailGroup;
        bodyGroup.add(tailGroup);
        
        // LEGS - spread out more for realistic dog proportions
        const legPositions = [
            { x: -0.15, z: 0.6, name: 'frontLeft' },
            { x: 0.15, z: 0.6, name: 'frontRight' },
            { x: -0.15, z: -0.6, name: 'backLeft' },
            { x: 0.15, z: -0.6, name: 'backRight' }
        ];
        
        legPositions.forEach((pos, i) => {
            const legGroup = new THREE.Group();
            
            // Upper leg (shorter)
            const leg = new THREE.Mesh(geom.leg, mat.blackFur);
            leg.position.y = -0.15;
            leg.scale.set(1, 0.7, 1); // Make legs shorter
            legGroup.add(leg);
            
            // White sock on front legs
            if (i < 2) {
                const sock = new THREE.Mesh(geom.leg, mat.whiteFur);
                sock.position.y = -0.22;
                sock.scale.set(1.1, 0.4, 1.1);
                legGroup.add(sock);
            }
            
            // Paw
            const paw = new THREE.Mesh(geom.paw, mat.blackFur);
            paw.position.y = -0.32;
            paw.scale.set(0.8, 0.8, 0.8); // Slightly smaller paws
            legGroup.add(paw);
            
            legGroup.position.set(pos.x, -0.15, pos.z);
            legGroup.userData = { 
                index: i, 
                baseX: pos.x,
                baseY: -0.15,
                baseZ: pos.z,
                name: pos.name 
            };
            
            this.animatedParts.legs.push(legGroup);
            bodyGroup.add(legGroup);
        });
        
        bodyGroup.position.y = 0.6;
        this.mesh.add(bodyGroup);
        
        // Position mesh
        this.mesh.position.set(this.position.x, 0, this.position.z);
        
        return this.mesh;
    }

    // Smooth movement with acceleration
    move(direction, bounds, deltaTime = 0.016, wantsSprint = false) {
        // Update stamina based on sprint state
        this.updateStamina(wantsSprint, deltaTime);
        
        // Determine current max speed based on sprint state
        const currentMaxSpeed = this.isSprinting ? this.sprintSpeed : this.maxSpeed;
        
        // Set target velocity based on input
        this.targetVelocity = direction.clone().normalize().multiply(currentMaxSpeed);
        
        // Smooth acceleration/deceleration
        const accelerationRate = direction.magnitude() > 0 ? this.acceleration : this.deceleration;
        const velocityDiff = this.targetVelocity.clone().subtract(this.velocity);
        const velocityChange = velocityDiff.clone().multiply(accelerationRate * deltaTime);
        
        // Apply velocity change
        this.velocity.add(velocityChange);
        
        // Limit to current max speed
        if (this.velocity.magnitude() > currentMaxSpeed) {
            this.velocity.normalize().multiply(currentMaxSpeed);
        }
        
        // Calculate new position
        const newPosition = this.position.clone().add(this.velocity.clone().multiply(deltaTime));
        
        // Check boundaries with margin
        const margin = 1;
        if (newPosition.x >= bounds.minX + margin && newPosition.x <= bounds.maxX - margin &&
            newPosition.z >= bounds.minZ + margin && newPosition.z <= bounds.maxZ - margin) {
            this.position = newPosition;
        } else {
            // Bounce off walls slightly
            this.velocity.multiply(0.5);
        }
        
        this.isMoving = this.velocity.magnitude() > 0.5;
        const speedNormalized = Math.min(this.velocity.magnitude() / this.maxSpeed, 1);
        
        // Play bark sound when actively herding sheep (near sheep and moving)
        if (this.audioManager && this.isMoving && this.nearSheep) {
            const now = Date.now();
            if (now - this.lastBarkTime > this.barkCooldown) {
                this.audioManager.playSheepdogBark();
                this.lastBarkTime = now;
            }
        }
        
        // Update mesh position and rotation
        if (this.mesh) {
            this.mesh.position.x = this.position.x;
            this.mesh.position.z = this.position.z;
            
            // Smooth rotation
            if (this.velocity.magnitude() > 0.1) {
                this.targetRotation = -this.velocity.angle() + Math.PI / 2;
            }
            
            // Normalize rotation difference
            let rotationDiff = this.targetRotation - this.currentRotation;
            while (rotationDiff > Math.PI) rotationDiff -= 2 * Math.PI;
            while (rotationDiff < -Math.PI) rotationDiff += 2 * Math.PI;
            
            // Apply smooth rotation
            this.currentRotation += rotationDiff * this.turnSpeed * deltaTime;
            this.mesh.rotation.y = this.currentRotation;
            
            // Animate
            this.animate(deltaTime);
        }
    }
    
    // Update stamina system
    updateStamina(wantsSprint, deltaTime) {
        const isMoving = this.velocity.magnitude() > 0.1;
        
        // Determine if we can/should sprint
        if (wantsSprint && isMoving && this.stamina >= this.minStaminaToSprint) {
            this.isSprinting = true;
            // Drain stamina when sprinting
            this.stamina = Math.max(0, this.stamina - this.staminaDrainRate * deltaTime);
        } else {
            this.isSprinting = false;
            // Regenerate stamina - faster when idle (not moving)
            const regenRate = isMoving ? this.staminaRegenRate : this.staminaRegenRate * 2;
            this.stamina = Math.min(this.maxStamina, this.stamina + regenRate * deltaTime);
        }
        
        // Force stop sprinting if stamina is depleted
        if (this.stamina <= 0) {
            this.isSprinting = false;
        }
    }
    
    // Get stamina information for UI
    getStaminaInfo() {
        return {
            current: this.stamina,
            max: this.maxStamina,
            percentage: (this.stamina / this.maxStamina) * 100,
            isSprinting: this.isSprinting,
            canSprint: this.stamina >= this.minStaminaToSprint
        };
    }
    
    // Animate the dog based on movement
    animate(deltaTime) {
        if (!this.animatedParts.body) return;
        
        this.animationTime += deltaTime;
        const speed = this.velocity.magnitude();
        const speedNormalized = Math.min(speed / this.maxSpeed, 1);
        
        // Running animation
        if (this.isMoving) {
            // Increase animation speed when sprinting
            const animationMultiplier = this.isSprinting ? 1.5 : 1.0;
            this.runCycle += deltaTime * speed * 0.5 * animationMultiplier;
            
            // Body bounce (more intense when sprinting)
            const bounceIntensity = this.isSprinting ? 0.1 : 0.06;
            const bounce = Math.sin(this.runCycle * 2) * speedNormalized * bounceIntensity;
            this.animatedParts.body.position.y = 0.6 + bounce;
            
            // Body lean forward when running (more when sprinting)
            const leanIntensity = this.isSprinting ? 0.25 : 0.15;
            this.animatedParts.body.rotation.x = speedNormalized * leanIntensity;
            
            // Head bob and reset idle rotations
            const headBob = Math.sin(this.runCycle * 2 + 0.5) * speedNormalized * 0.05;
            this.animatedParts.head.position.y = 0.35 + headBob;
            this.animatedParts.head.rotation.x = Math.sin(this.runCycle * 2) * speedNormalized * 0.1;
            
            // Reset idle head rotations when moving
            this.animatedParts.head.rotation.y *= 0.9; // Reset look direction
            this.animatedParts.head.rotation.z *= 0.9; // Reset head tilt
            this.lookDirection *= 0.9;
            
            // More realistic dog galloping animation
            this.animatedParts.legs.forEach((leg, i) => {
                // Front legs move together, back legs move together (dog gait)
                const isFrontLeg = i < 2;
                const isLeftLeg = i % 2 === 0;
                
                // Different phases for front and back legs
                const frontPhase = 0;
                const backPhase = Math.PI * 0.5; // Back legs slightly offset
                const sideOffset = isLeftLeg ? 0 : Math.PI * 0.1; // Slight left/right offset
                
                const phase = isFrontLeg ? frontPhase : backPhase;
                const cycleSpeed = this.runCycle * 2.5; // Slightly faster cycle
                
                // Leg lift (more subtle)
                const lift = Math.max(0, Math.sin(cycleSpeed + phase + sideOffset)) * speedNormalized;
                leg.position.y = leg.userData.baseY + lift * 0.12;
                
                // Forward/backward leg extension (more realistic)
                const extension = Math.cos(cycleSpeed + phase + sideOffset) * speedNormalized;
                leg.position.z = leg.userData.baseZ + extension * 0.15;
                
                // Leg rotation (more subtle)
                leg.rotation.x = Math.sin(cycleSpeed + phase + sideOffset) * speedNormalized * 0.4;
            });
            
            // Show tongue when running fast or sprinting
            if (this.animatedParts.tongue) {
                this.animatedParts.tongue.visible = speedNormalized > 0.6 || this.isSprinting;
                if (this.animatedParts.tongue.visible) {
                    const tongueIntensity = this.isSprinting ? 0.15 : 0.1;
                    this.animatedParts.tongue.rotation.z = Math.sin(this.runCycle * 3) * tongueIntensity;
                }
            }
        } else {
            // Enhanced idle animation system
            this.runCycle *= 0.9; // Slow down run cycle
            this.idleTime += deltaTime;
            
            // Check if it's time for a new idle action
            if (this.idleTime >= this.nextIdleAction) {
                this.chooseNextIdleAction();
            }
            
            // Perform current idle action
            this.performIdleAction(deltaTime);
            
            // Reset leg positions smoothly
            this.animatedParts.legs.forEach((leg) => {
                leg.position.y += (leg.userData.baseY - leg.position.y) * 0.1;
                leg.position.z += (leg.userData.baseZ - leg.position.z) * 0.1;
                leg.rotation.x *= 0.9;
            });
            
            // Hide tongue when idle
            if (this.animatedParts.tongue) {
                this.animatedParts.tongue.visible = false;
            }
        }
        
        // Tail wagging (faster when moving, even faster when sprinting)
        const tailSpeedMultiplier = this.isSprinting ? 1.5 : 1.0;
        this.tailWag += deltaTime * (2 + speedNormalized * 4) * tailSpeedMultiplier;
        if (this.animatedParts.tail) {
            const wagAmount = 0.3 + speedNormalized * 0.3 + (this.isSprinting ? 0.2 : 0);
            this.animatedParts.tail.rotation.y = Math.sin(this.tailWag) * wagAmount;
            this.animatedParts.tail.rotation.x = Math.cos(this.tailWag * 0.5) * wagAmount * 0.3;
        }
        
        // Ear flapping
        this.earFlap += deltaTime * (1 + speedNormalized * 2);
        this.animatedParts.ears.forEach((ear, i) => {
            const baseRotation = i === 0 ? 0.8 : -0.8;
            const flap = Math.sin(this.earFlap + i * Math.PI * 0.5) * speedNormalized * 0.2;
            ear.rotation.z = baseRotation + flap;
            ear.rotation.x = -0.2 + Math.cos(this.earFlap * 0.5) * speedNormalized * 0.1;
        });
    }

    // Choose next idle action
    chooseNextIdleAction() {
        const actions = ['breathing', 'lookAround', 'headTilt', 'earTwitch', 'stretch', 'sit'];
        const weights = [30, 25, 20, 15, 8, 2]; // Breathing most common, sitting rare
        
        // Weighted random selection
        const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
        let random = Math.random() * totalWeight;
        
        for (let i = 0; i < actions.length; i++) {
            random -= weights[i];
            if (random <= 0) {
                this.currentIdleAction = actions[i];
                break;
            }
        }
        
        // Set duration and next action time
        this.idleActionDuration = 0;
        switch (this.currentIdleAction) {
            case 'breathing':
                this.nextIdleAction = this.idleTime + 2 + Math.random() * 3; // 2-5 seconds
                break;
            case 'lookAround':
                this.nextIdleAction = this.idleTime + 1.5 + Math.random() * 2; // 1.5-3.5 seconds
                this.targetLookDirection = (Math.random() - 0.5) * Math.PI * 0.8; // Look left/right
                break;
            case 'headTilt':
                this.nextIdleAction = this.idleTime + 1 + Math.random() * 1.5; // 1-2.5 seconds
                break;
            case 'earTwitch':
                this.nextIdleAction = this.idleTime + 0.5 + Math.random() * 1; // 0.5-1.5 seconds
                break;
            case 'stretch':
                this.nextIdleAction = this.idleTime + 3 + Math.random() * 2; // 3-5 seconds
                break;
            case 'sit':
                this.nextIdleAction = this.idleTime + 4 + Math.random() * 3; // 4-7 seconds
                break;
        }
    }
    
    // Perform the current idle action
    performIdleAction(deltaTime) {
        this.idleActionDuration += deltaTime;
        
        switch (this.currentIdleAction) {
            case 'breathing':
                this.performBreathing();
                break;
            case 'lookAround':
                this.performLookAround(deltaTime);
                break;
            case 'headTilt':
                this.performHeadTilt();
                break;
            case 'earTwitch':
                this.performEarTwitch();
                break;
            case 'stretch':
                this.performStretch();
                break;
            case 'sit':
                this.performSit();
                break;
        }
    }
    
    // Individual idle animations
    performBreathing() {
        const breathe = Math.sin(this.animationTime * 2.5) * 0.025;
        this.animatedParts.body.position.y = 0.6 + breathe;
        this.animatedParts.body.rotation.x *= 0.95; // Return to neutral slowly
        
        // Gentle head movement
        if (this.animatedParts.head) {
            this.animatedParts.head.position.y = 0.45 + breathe * 0.5;
        }
    }
    
    performLookAround(deltaTime) {
        // Smooth head turning
        const lookDiff = this.targetLookDirection - this.lookDirection;
        this.lookDirection += lookDiff * 2 * deltaTime;
        
        if (this.animatedParts.head) {
            this.animatedParts.head.rotation.y = this.lookDirection;
            
            // Slight body breathing
            const breathe = Math.sin(this.animationTime * 2) * 0.02;
            this.animatedParts.body.position.y = 0.6 + breathe;
        }
    }
    
    performHeadTilt() {
        const tilt = Math.sin(this.idleActionDuration * 3) * 0.3;
        if (this.animatedParts.head) {
            this.animatedParts.head.rotation.z = tilt;
            
            // Breathing
            const breathe = Math.sin(this.animationTime * 2) * 0.02;
            this.animatedParts.body.position.y = 0.6 + breathe;
        }
    }
    
    performEarTwitch() {
        const twitch = Math.sin(this.idleActionDuration * 8) * 0.4;
        this.animatedParts.ears.forEach((ear, i) => {
            const baseRotation = i === 0 ? 0.8 : -0.8;
            ear.rotation.z = baseRotation + (i === 0 ? twitch : -twitch);
        });
        
        // Breathing
        const breathe = Math.sin(this.animationTime * 2) * 0.02;
        this.animatedParts.body.position.y = 0.6 + breathe;
    }
    
    performStretch() {
        const stretchPhase = this.idleActionDuration / 3; // 3 second stretch
        
        if (stretchPhase < 0.3) {
            // Stretch forward
            this.animatedParts.body.rotation.x = -0.2 * (stretchPhase / 0.3);
            this.animatedParts.body.position.y = 0.6 - 0.1 * (stretchPhase / 0.3);
        } else if (stretchPhase < 0.7) {
            // Hold stretch
            this.animatedParts.body.rotation.x = -0.2;
            this.animatedParts.body.position.y = 0.5;
        } else {
            // Return to normal
            const returnPhase = (stretchPhase - 0.7) / 0.3;
            this.animatedParts.body.rotation.x = -0.2 * (1 - returnPhase);
            this.animatedParts.body.position.y = 0.5 + 0.1 * returnPhase;
        }
    }
    
    performSit() {
        const sitPhase = Math.min(this.idleActionDuration / 1, 1); // 1 second to sit
        
        // Lower body and rotate back legs
        this.animatedParts.body.position.y = 0.6 - 0.2 * sitPhase;
        this.animatedParts.body.rotation.x = 0.3 * sitPhase;
        
        // Move back legs
        if (this.animatedParts.legs.length >= 4) {
            this.animatedParts.legs[2].rotation.x = -0.8 * sitPhase; // Back left
            this.animatedParts.legs[3].rotation.x = -0.8 * sitPhase; // Back right
            this.animatedParts.legs[2].position.y = this.animatedParts.legs[2].userData.baseY - 0.1 * sitPhase;
            this.animatedParts.legs[3].position.y = this.animatedParts.legs[3].userData.baseY - 0.1 * sitPhase;
        }
        
        // Gentle breathing while sitting
        const breathe = Math.sin(this.animationTime * 2) * 0.015;
        this.animatedParts.body.position.y += breathe;
    }
    
    // Stop movement
    stop() {
        this.targetVelocity.multiply(0);
        
        // Reset look direction when stopping
        this.targetLookDirection = 0;
    }
    
    setAudioManager(audioManager) {
        this.audioManager = audioManager;
    }
    
    /**
     * Update whether the dog is near sheep for barking purposes
     * @param {Array} sheep - Array of sheep to check distance to
     */
    updateNearSheepStatus(sheep) {
        if (!sheep || sheep.length === 0) {
            this.nearSheep = false;
            return;
        }
        
        const barkRadius = 12; // Slightly larger than sheep flee radius (8)
        this.nearSheep = false;
        
        // Check if any sheep are within barking distance
        for (let i = 0; i < sheep.length; i++) {
            const sheepInstance = sheep[i];
            if (sheepInstance && sheepInstance.position) {
                const distance = this.position.distanceTo(sheepInstance.position);
                if (distance < barkRadius) {
                    this.nearSheep = true;
                    break;
                }
            }
        }
    }
}
```

## js/StaminaUI.js

```javascript
/**
 * StaminaUI class - manages the stamina bar display
 */
export class StaminaUI {
    constructor() {
        this.staminaFill = document.getElementById('stamina-fill');
        this.staminaText = document.getElementById('stamina-text');
        this.staminaLabel = document.getElementById('stamina-label');
        
        // Cache DOM elements for performance
        this.elements = {
            fill: this.staminaFill,
            text: this.staminaText,
            label: this.staminaLabel
        };
        
        // Track previous state to avoid unnecessary updates
        this.previousPercentage = 100;
        this.previousState = 'normal';
    }
    
    /**
     * Update the stamina bar based on sheepdog stamina info
     * @param {Object} staminaInfo - Object containing stamina data from sheepdog
     */
    update(staminaInfo) {
        const { percentage, isSprinting, canSprint } = staminaInfo;
        const roundedPercentage = Math.round(percentage);
        
        // Only update if percentage changed to avoid unnecessary DOM manipulation
        if (roundedPercentage !== this.previousPercentage) {
            this.elements.fill.style.width = `${percentage}%`;
            this.elements.text.textContent = `${roundedPercentage}%`;
            this.previousPercentage = roundedPercentage;
        }
        
        // Determine current state for styling
        let currentState = 'normal';
        if (isSprinting) {
            currentState = 'sprinting';
        } else if (percentage <= 10) {
            currentState = 'critical';
        } else if (percentage <= 30) {
            currentState = 'low';
        }
        
        // Update styling only if state changed
        if (currentState !== this.previousState) {
            // Remove all state classes
            this.elements.fill.classList.remove('low', 'critical', 'sprinting');
            
            // Add current state class
            if (currentState !== 'normal') {
                this.elements.fill.classList.add(currentState);
            }
            
            // Update label based on state
            if (isSprinting) {
                this.elements.label.textContent = 'Sprinting!';
                this.elements.label.style.color = '#2196F3';
            } else if (!canSprint) {
                this.elements.label.textContent = 'Stamina (Exhausted)';
                this.elements.label.style.color = '#F44336';
            } else {
                this.elements.label.textContent = 'Stamina';
                this.elements.label.style.color = '#333';
            }
            
            this.previousState = currentState;
        }
    }
    
    /**
     * Show the stamina bar (called when game starts)
     */
    show() {
        const staminaBar = document.getElementById('stamina-bar');
        if (staminaBar) {
            staminaBar.classList.add('visible');
        }
    }
    
    /**
     * Hide the stamina bar (called when game ends or on start screen)
     */
    hide() {
        const staminaBar = document.getElementById('stamina-bar');
        if (staminaBar) {
            staminaBar.classList.remove('visible');
        }
    }
    
    /**
     * Reset stamina bar to full
     */
    reset() {
        this.elements.fill.style.width = '100%';
        this.elements.text.textContent = '100%';
        this.elements.label.textContent = 'Stamina';
        this.elements.label.style.color = '#333';
        this.elements.fill.classList.remove('low', 'critical', 'sprinting');
        this.previousPercentage = 100;
        this.previousState = 'normal';
    }
}
```

## js/StartScreen.js

```javascript
import * as THREE from 'three';

/**
 * StartScreen - Manages the start screen overlay and pre-game state
 */
export class StartScreen {
    constructor(sceneManager) {
        this.sceneManager = sceneManager;
        this.isActive = true;
        this.gameStarted = false;
        this.audioManager = null;
        
        // Cinematic camera settings
        this.cinematicCamera = {
            angle: 0,
            radius: 120,
            height: 80,
            speed: 0.05,
            centerX: 0,
            centerZ: 0
        };
        
        // UI elements
        this.startScreenElement = document.getElementById('start-screen');
        this.startButton = document.getElementById('start-button');
        this.gameUIElements = document.querySelectorAll('.game-ui');
        this.musicNote = document.getElementById('music-note');
        
        this.init();
    }
    
    init() {
        // Set up start button event listener
        this.startButton.addEventListener('click', () => {
            this.startGame();
        });
        
        // Set up keyboard listener for Enter key
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Enter' && this.isActive) {
                this.startGame();
            }
        });
        
        // Set up mute button
        this.setupMuteButton();
        
        // Set up music activation
        this.setupMusicActivation();
        
        // Initialize cinematic camera
        this.setupCinematicCamera();
    }
    
    setupCinematicCamera() {
        // Position camera for cinematic view of the field
        const camera = this.sceneManager.getCamera();
        camera.position.set(
            this.cinematicCamera.centerX + this.cinematicCamera.radius,
            this.cinematicCamera.height,
            this.cinematicCamera.centerZ
        );
        camera.lookAt(this.cinematicCamera.centerX, 0, this.cinematicCamera.centerZ);
    }
    
    updateCinematicCamera() {
        if (!this.isActive) return;
        
        // Slowly orbit around the field center
        this.cinematicCamera.angle += this.cinematicCamera.speed * 0.016; // Assuming 60fps
        
        const camera = this.sceneManager.getCamera();
        const x = this.cinematicCamera.centerX + Math.cos(this.cinematicCamera.angle) * this.cinematicCamera.radius;
        const z = this.cinematicCamera.centerZ + Math.sin(this.cinematicCamera.angle) * this.cinematicCamera.radius;
        
        // Smooth camera movement
        const targetPosition = new THREE.Vector3(x, this.cinematicCamera.height, z);
        camera.position.lerp(targetPosition, 0.02);
        
        // Always look at the center of the field
        const lookAtTarget = new THREE.Vector3(this.cinematicCamera.centerX, 0, this.cinematicCamera.centerZ);
        const currentLookAt = new THREE.Vector3();
        camera.getWorldDirection(currentLookAt);
        currentLookAt.multiplyScalar(-1).add(camera.position);
        currentLookAt.lerp(lookAtTarget, 0.02);
        camera.lookAt(currentLookAt);
    }
    
    startGame() {
        if (!this.isActive) return;
        
        // Play UI click sound
        if (this.audioManager) {
            this.audioManager.playUIClick();
            
            // Fade out start music and start gameplay music
            this.audioManager.fadeOutCurrentMusic(800);
            setTimeout(() => {
                this.audioManager.playGameplayMusic();
            }, 900); // Start gameplay music after fade out
        }
        
        this.isActive = false;
        this.gameStarted = true;
        
        // Hide start screen with animation
        this.startScreenElement.style.transition = 'opacity 0.8s ease-out';
        this.startScreenElement.style.opacity = '0';
        
        setTimeout(() => {
            this.startScreenElement.style.display = 'none';
            
            // Show game UI elements
            this.gameUIElements.forEach(element => {
                element.classList.add('visible');
            });
        }, 800);
        
        // Trigger game start callback if set
        if (this.onGameStart) {
            this.onGameStart();
        }
    }
    
    setGameStartCallback(callback) {
        this.onGameStart = callback;
    }
    
    setAudioManager(audioManager) {
        this.audioManager = audioManager;
        
        // Update mute button state
        this.updateMuteButton();
    }
    
    setupMuteButton() {
        this.muteToggle = document.getElementById('mute-toggle');
        if (this.muteToggle) {
            this.muteToggle.addEventListener('click', () => {
                if (this.audioManager) {
                    const isMuted = this.audioManager.toggleMute();
                    this.updateMuteButton();
                }
            });
        }
    }
    
    updateMuteButton() {
        if (!this.muteToggle || !this.audioManager) return;
        
        const isMuted = this.audioManager.isMutedState();
        const icon = isMuted ? '🔇' : '🔊';
        this.muteToggle.innerHTML = `${icon} <strong>Click</strong> - Toggle Sound`;
        this.muteToggle.title = isMuted ? 'Click to unmute sound' : 'Click to mute sound';
        
        if (isMuted) {
            this.muteToggle.classList.add('muted');
        } else {
            this.muteToggle.classList.remove('muted');
        }
    }
    
    setupMusicActivation() {
        // Listen for clicks on the start screen (but not the start button)
        const handleStartScreenClick = (event) => {
            // Don't trigger music if clicking the start button
            if (event.target.id === 'start-button' || event.target.closest('#start-button')) {
                return;
            }
            
            // Trigger music and hide the note
            if (this.audioManager && this.isActive) {
                this.audioManager.triggerStartMusic();
                if (this.musicNote) {
                    this.musicNote.style.display = 'none';
                }
            }
        };
        
        // Add click listener to start screen
        if (this.startScreenElement) {
            this.startScreenElement.addEventListener('click', handleStartScreenClick);
        }
    }
    
    isStartScreenActive() {
        return this.isActive;
    }
    
    hasGameStarted() {
        return this.gameStarted;
    }
    
    reset() {
        this.isActive = true;
        this.gameStarted = false;
        
        // Show start screen
        this.startScreenElement.style.display = 'flex';
        this.startScreenElement.style.opacity = '1';
        this.startScreenElement.style.transition = 'none';
        
        // Hide game UI elements
        this.gameUIElements.forEach(element => {
            element.classList.remove('visible');
        });
        
        // Reset cinematic camera
        this.cinematicCamera.angle = 0;
        this.setupCinematicCamera();
    }
}
```

## js/StructureBuilder.js

```javascript
import * as THREE from 'three';

/**
 * StructureBuilder - Handles fences, gates, and pasture structures
 */
export class StructureBuilder {
    constructor(scene) {
        this.scene = scene;
    }
    
    createFieldBoundaryFence(bounds, gate) {
        // Fence post geometry and material
        const postGeometry = new THREE.CylinderGeometry(0.25, 0.25, 3.5, 8);
        const postMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x5a4a3a,
            emissive: 0x1a0a00,
            emissiveIntensity: 0.05
        });
        
        // Rail geometry and material
        const railMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x6a5a4a,
            emissive: 0x1a0a00,
            emissiveIntensity: 0.05
        });
        
        // Fence parameters
        const postSpacing = 10; // Distance between posts
        const postHeight = 3.5;
        const railHeight1 = 1.2; // Lower rail
        const railHeight2 = 2.4; // Upper rail
        
        const fencePosts = [];
        
        // Create fence posts around the perimeter
        // Bottom edge (z = -100)
        for (let x = bounds.minX; x <= bounds.maxX; x += postSpacing) {
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.set(x, postHeight/2, bounds.minZ);
            post.castShadow = true;
            post.receiveShadow = true;
            this.scene.add(post);
            fencePosts.push({x: x, z: bounds.minZ, type: 'bottom'});
        }
        
        // Top edge (z = 100) - connect properly to gate posts
        for (let x = bounds.minX; x <= bounds.maxX; x += postSpacing) {
            // Skip posts that would be too close to gate posts
            const gateLeftPost = gate.position.x - gate.width/2;
            const gateRightPost = gate.position.x + gate.width/2;
            
            if (x < gateLeftPost - 1 || x > gateRightPost + 1) {
                const post = new THREE.Mesh(postGeometry, postMaterial);
                post.position.set(x, postHeight/2, bounds.maxZ);
                post.castShadow = true;
                post.receiveShadow = true;
                this.scene.add(post);
                fencePosts.push({x: x, z: bounds.maxZ, type: 'top'});
            }
        }
        
        // Left edge (x = -100)
        for (let z = bounds.minZ; z <= bounds.maxZ; z += postSpacing) {
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.set(bounds.minX, postHeight/2, z);
            post.castShadow = true;
            post.receiveShadow = true;
            this.scene.add(post);
            fencePosts.push({x: bounds.minX, z: z, type: 'left'});
        }
        
        // Right edge (x = 100)
        for (let z = bounds.minZ; z <= bounds.maxZ; z += postSpacing) {
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.set(bounds.maxX, postHeight/2, z);
            post.castShadow = true;
            post.receiveShadow = true;
            this.scene.add(post);
            fencePosts.push({x: bounds.maxX, z: z, type: 'right'});
        }
        
        // Add horizontal rails between posts
        // Bottom edge rails
        for (let x = bounds.minX; x < bounds.maxX; x += postSpacing) {
            this.createFenceRail(x, bounds.minZ, x + postSpacing, bounds.minZ, railHeight1, railMaterial);
            this.createFenceRail(x, bounds.minZ, x + postSpacing, bounds.minZ, railHeight2, railMaterial);
        }
        
        // Top edge rails - connect to gate posts properly
        const gateLeftPost = gate.position.x - gate.width/2;
        const gateRightPost = gate.position.x + gate.width/2;
        
        for (let x = bounds.minX; x < bounds.maxX; x += postSpacing) {
            const nextX = x + postSpacing;
            
            // Left side of gate - connect to left gate post
            if (nextX <= gateLeftPost + 1) {
                const endX = (nextX > gateLeftPost - 1) ? gateLeftPost : nextX;
                this.createFenceRail(x, bounds.maxZ, endX, bounds.maxZ, railHeight1, railMaterial);
                this.createFenceRail(x, bounds.maxZ, endX, bounds.maxZ, railHeight2, railMaterial);
            }
            
            // Right side of gate - connect from right gate post
            if (x >= gateRightPost - 1) {
                const startX = (x < gateRightPost + 1) ? gateRightPost : x;
                this.createFenceRail(startX, bounds.maxZ, nextX, bounds.maxZ, railHeight1, railMaterial);
                this.createFenceRail(startX, bounds.maxZ, nextX, bounds.maxZ, railHeight2, railMaterial);
            }
        }
        
        // Left edge rails
        for (let z = bounds.minZ; z < bounds.maxZ; z += postSpacing) {
            this.createFenceRail(bounds.minX, z, bounds.minX, z + postSpacing, railHeight1, railMaterial);
            this.createFenceRail(bounds.minX, z, bounds.minX, z + postSpacing, railHeight2, railMaterial);
        }
        
        // Right edge rails
        for (let z = bounds.minZ; z < bounds.maxZ; z += postSpacing) {
            this.createFenceRail(bounds.maxX, z, bounds.maxX, z + postSpacing, railHeight1, railMaterial);
            this.createFenceRail(bounds.maxX, z, bounds.maxX, z + postSpacing, railHeight2, railMaterial);
        }
        
        return fencePosts;
    }
    
    createFenceRail(x1, z1, x2, z2, height, material) {
        const distance = Math.sqrt((x2-x1)*(x2-x1) + (z2-z1)*(z2-z1));
        if (distance < 0.1) return; // Skip very short rails
        
        const railGeometry = new THREE.CylinderGeometry(0.08, 0.08, distance, 6);
        const rail = new THREE.Mesh(railGeometry, material);
        
        // Position rail at midpoint
        rail.position.set((x1 + x2) / 2, height, (z1 + z2) / 2);
        
        // Rotate rail to connect posts
        // First rotate to horizontal (from vertical default)
        rail.rotation.z = Math.PI / 2;
        
        // Then rotate around Y axis to point in the right direction
        const angle = Math.atan2(z2 - z1, x2 - x1);
        rail.rotation.y = angle;
        
        rail.castShadow = true;
        rail.receiveShadow = true;
        this.scene.add(rail);
        
        return rail;
    }

    createGateAndPasture(gate, pasture) {
        const gateElements = [];
        
        // Create gate posts - taller and more prominent
        const postGeometry = new THREE.CylinderGeometry(0.4, 0.4, gate.height + 1, 8);
        const postMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x4a3c28,
            emissive: 0x1a0a00,
            emissiveIntensity: 0.1
        });
        
        // Left post
        const leftPost = new THREE.Mesh(postGeometry, postMaterial);
        leftPost.position.set(gate.position.x - gate.width/2, (gate.height + 1)/2, gate.position.z);
        leftPost.castShadow = true;
        leftPost.receiveShadow = true;
        this.scene.add(leftPost);
        gateElements.push(leftPost);
        
        // Right post
        const rightPost = new THREE.Mesh(postGeometry, postMaterial);
        rightPost.position.set(gate.position.x + gate.width/2, (gate.height + 1)/2, gate.position.z);
        rightPost.castShadow = true;
        rightPost.receiveShadow = true;
        this.scene.add(rightPost);
        gateElements.push(rightPost);
        
        // Decorative gate arch
        const archGeometry = new THREE.CylinderGeometry(0.2, 0.2, gate.width + 1, 8);
        const archMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x6a5a4a,
            emissive: 0x2a1a00,
            emissiveIntensity: 0.1
        });
        
        const arch = new THREE.Mesh(archGeometry, archMaterial);
        arch.position.set(gate.position.x, gate.height + 0.5, gate.position.z);
        arch.rotation.z = Math.PI / 2;
        arch.castShadow = true;
        this.scene.add(arch);
        gateElements.push(arch);
        
        // Gate threshold marker (on ground) - more prominent
        const thresholdGeometry = new THREE.BoxGeometry(gate.width + 2, 0.15, 3);
        const thresholdMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xFFD700, // Gold
            emissive: 0x806000,
            emissiveIntensity: 0.3
        });
        
        const threshold = new THREE.Mesh(thresholdGeometry, thresholdMaterial);
        threshold.position.set(gate.position.x, 0.075, gate.position.z);
        this.scene.add(threshold);
        gateElements.push(threshold);
        
        // Add welcome sign above gate
        this.createWelcomeSign(gate.position.x, gate.height + 1.5, gate.position.z - 1);
        
        // Create enhanced pasture area
        const pastureElements = this.createEnhancedPasture(pasture, gate);
        
        return {
            gate: gateElements,
            pasture: pastureElements
        };
    }
    
    createWelcomeSign(x, y, z) {
        // Sign post
        const postGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 6);
        const postMaterial = new THREE.MeshPhongMaterial({ color: 0x4a3c28 });
        const signPost = new THREE.Mesh(postGeometry, postMaterial);
        signPost.position.set(x, y - 0.5, z);
        signPost.castShadow = true;
        this.scene.add(signPost);
        
        // Sign board
        const signGeometry = new THREE.BoxGeometry(3, 0.8, 0.2);
        const signMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x8B4513,
            emissive: 0x2a1a00,
            emissiveIntensity: 0.05
        });
        const signBoard = new THREE.Mesh(signGeometry, signMaterial);
        signBoard.position.set(x, y, z);
        signBoard.castShadow = true;
        this.scene.add(signBoard);
    }
    
    createEnhancedPasture(pasture, gate) {
        const pastureElements = [];
        
        // Create a more enclosed pen with proper fencing
        this.createPenFencing(pasture, pastureElements);
        
        // Enhanced pasture ground with better texture
        const pastureGeometry = new THREE.PlaneGeometry(
            pasture.maxX - pasture.minX + 4, 
            pasture.maxZ - pasture.minZ + 4
        );
        
        // Create enhanced pasture texture
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 1024;
        const context = canvas.getContext('2d');
        
        // Rich, comfortable grass for sleeping pasture
        const gradient = context.createRadialGradient(512, 512, 0, 512, 512, 512);
        gradient.addColorStop(0, '#6a8a5a');
        gradient.addColorStop(0.5, '#5a7a4a');
        gradient.addColorStop(1, '#4a6a3a');
        context.fillStyle = gradient;
        context.fillRect(0, 0, 1024, 1024);
        
        // Add clover patches
        for (let i = 0; i < 50; i++) {
            const x = Math.random() * 1024;
            const y = Math.random() * 1024;
            const radius = 20 + Math.random() * 30;
            
            const cloverGradient = context.createRadialGradient(x, y, 0, x, y, radius);
            cloverGradient.addColorStop(0, '#7a9a6a');
            cloverGradient.addColorStop(1, 'transparent');
            context.fillStyle = cloverGradient;
            context.beginPath();
            context.arc(x, y, radius, 0, Math.PI * 2);
            context.fill();
        }
        
        // Add texture details
        for (let i = 0; i < 2000; i++) {
            context.fillStyle = `rgba(${60 + Math.random() * 40}, ${120 + Math.random() * 40}, ${60 + Math.random() * 40}, 0.15)`;
            context.fillRect(Math.random() * 1024, Math.random() * 1024, 2, 2);
        }
        
        const pastureTexture = new THREE.CanvasTexture(canvas);
        pastureTexture.wrapS = THREE.RepeatWrapping;
        pastureTexture.wrapT = THREE.RepeatWrapping;
        pastureTexture.repeat.set(3, 3);
        pastureTexture.colorSpace = THREE.SRGBColorSpace;
        
        const pastureMaterial = new THREE.MeshPhongMaterial({ 
            map: pastureTexture,
            emissive: 0x1a2a1a,
            emissiveIntensity: 0.08
        });
        
        const pastureMesh = new THREE.Mesh(pastureGeometry, pastureMaterial);
        pastureMesh.rotation.x = -Math.PI / 2;
        pastureMesh.position.set(
            (pasture.minX + pasture.maxX) / 2, 
            0.02, 
            (pasture.minZ + pasture.maxZ) / 2
        );
        pastureMesh.receiveShadow = true;
        this.scene.add(pastureMesh);
        pastureElements.push(pastureMesh);
        
        // Add comfort features
        this.addPastureComfortFeatures(pasture, pastureElements);
        
        return pastureElements;
    }
    
    createPenFencing(pasture, pastureElements) {
        const fencePostGeometry = new THREE.CylinderGeometry(0.25, 0.25, 3.5, 8);
        const fencePostMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x5a4a3a,
            emissive: 0x1a0a00,
            emissiveIntensity: 0.05
        });
        
        const railMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x6a5a4a,
            emissive: 0x1a0a00,
            emissiveIntensity: 0.05
        });
        
        const postSpacing = 8;
        const railHeight1 = 1.2;
        const railHeight2 = 2.4;
        
        // Back fence (complete enclosure)
        for (let x = pasture.minX - 2; x <= pasture.maxX + 2; x += postSpacing) {
            const post = new THREE.Mesh(fencePostGeometry, fencePostMaterial);
            post.position.set(x, 1.75, pasture.maxZ + 2);
            post.castShadow = true;
            this.scene.add(post);
            pastureElements.push(post);
            
            // Add rails
            if (x < pasture.maxX + 2) {
                this.createFenceRail(x, pasture.maxZ + 2, x + postSpacing, pasture.maxZ + 2, railHeight1, railMaterial);
                this.createFenceRail(x, pasture.maxZ + 2, x + postSpacing, pasture.maxZ + 2, railHeight2, railMaterial);
            }
        }
        
        // Side fences (left and right) - stop at the boundary fence line
        for (let z = pasture.maxZ + 2; z > pasture.minZ + 2; z -= postSpacing) {
            // Left side
            const leftPost = new THREE.Mesh(fencePostGeometry, fencePostMaterial);
            leftPost.position.set(pasture.minX - 2, 1.75, z);
            leftPost.castShadow = true;
            this.scene.add(leftPost);
            pastureElements.push(leftPost);
            
            // Right side
            const rightPost = new THREE.Mesh(fencePostGeometry, fencePostMaterial);
            rightPost.position.set(pasture.maxX + 2, 1.75, z);
            rightPost.castShadow = true;
            this.scene.add(rightPost);
            pastureElements.push(rightPost);
            
            // Add rails
            if (z > pasture.minZ + 2) {
                this.createFenceRail(pasture.minX - 2, z, pasture.minX - 2, z - postSpacing, railHeight1, railMaterial);
                this.createFenceRail(pasture.minX - 2, z, pasture.minX - 2, z - postSpacing, railHeight2, railMaterial);
                this.createFenceRail(pasture.maxX + 2, z, pasture.maxX + 2, z - postSpacing, railHeight1, railMaterial);
                this.createFenceRail(pasture.maxX + 2, z, pasture.maxX + 2, z - postSpacing, railHeight2, railMaterial);
            }
        }
        
        // Add corner posts to connect with boundary fence
        // Left corner post
        const leftCornerPost = new THREE.Mesh(fencePostGeometry, fencePostMaterial);
        leftCornerPost.position.set(pasture.minX - 2, 1.75, pasture.minZ + 2);
        leftCornerPost.castShadow = true;
        this.scene.add(leftCornerPost);
        pastureElements.push(leftCornerPost);
        
        // Right corner post  
        const rightCornerPost = new THREE.Mesh(fencePostGeometry, fencePostMaterial);
        rightCornerPost.position.set(pasture.maxX + 2, 1.75, pasture.minZ + 2);
        rightCornerPost.castShadow = true;
        this.scene.add(rightCornerPost);
        pastureElements.push(rightCornerPost);
        
        // Connect corner posts to the last side fence posts
        const lastSideZ = pasture.minZ + 2 + postSpacing;
        this.createFenceRail(pasture.minX - 2, lastSideZ, pasture.minX - 2, pasture.minZ + 2, railHeight1, railMaterial);
        this.createFenceRail(pasture.minX - 2, lastSideZ, pasture.minX - 2, pasture.minZ + 2, railHeight2, railMaterial);
        this.createFenceRail(pasture.maxX + 2, lastSideZ, pasture.maxX + 2, pasture.minZ + 2, railHeight1, railMaterial);
        this.createFenceRail(pasture.maxX + 2, lastSideZ, pasture.maxX + 2, pasture.minZ + 2, railHeight2, railMaterial);
        
        // Connect the nearest boundary fence posts to gate posts to close the gaps
        const gateLeftPost = -4; // Gate left post position (gate width/2 = 4)
        const gateRightPost = 4; // Gate right post position (gate width/2 = 4)
        const gateZ = 100; // Gate is at z = 100
        
        // The nearest boundary fence posts to the gate are at x = -10 and x = +10
        const nearestLeftBoundaryPost = -10;
        const nearestRightBoundaryPost = 10;
        const boundaryZ = 100; // Boundary fence is at z = 100
        
        // Left side connection from nearest boundary post to gate post
        this.createFenceRail(nearestLeftBoundaryPost, boundaryZ, gateLeftPost, gateZ, railHeight1, railMaterial);
        this.createFenceRail(nearestLeftBoundaryPost, boundaryZ, gateLeftPost, gateZ, railHeight2, railMaterial);
        
        // Right side connection from nearest boundary post to gate post
        this.createFenceRail(nearestRightBoundaryPost, boundaryZ, gateRightPost, gateZ, railHeight1, railMaterial);
        this.createFenceRail(nearestRightBoundaryPost, boundaryZ, gateRightPost, gateZ, railHeight2, railMaterial);
    }
    
    addPastureComfortFeatures(pasture, pastureElements) {
        // Add water trough
        const troughGeometry = new THREE.BoxGeometry(4, 0.8, 1.5);
        const troughMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x666666,
            emissive: 0x111111
        });
        const trough = new THREE.Mesh(troughGeometry, troughMaterial);
        trough.position.set(pasture.maxX - 5, 0.4, pasture.maxZ - 5);
        trough.castShadow = true;
        trough.receiveShadow = true;
        this.scene.add(trough);
        pastureElements.push(trough);
        
        // Add water surface
        const waterGeometry = new THREE.PlaneGeometry(3.8, 1.3);
        const waterMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x4488cc,
            transparent: true,
            opacity: 0.8,
            emissive: 0x002244,
            emissiveIntensity: 0.1
        });
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.set(pasture.maxX - 5, 0.81, pasture.maxZ - 5);
        this.scene.add(water);
        pastureElements.push(water);
        
        // Add hay bales for comfort
        const hayGeometry = new THREE.CylinderGeometry(1.5, 1.5, 1.2, 8);
        const hayMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xDAA520,
            emissive: 0x2a1a00,
            emissiveIntensity: 0.05
        });
        
        // Place several hay bales
        const hayPositions = [
            { x: pasture.minX + 5, z: pasture.maxZ - 8 },
            { x: pasture.maxX - 10, z: pasture.minZ + 8 },
            { x: (pasture.minX + pasture.maxX) / 2, z: pasture.maxZ - 12 }
        ];
        
        hayPositions.forEach(pos => {
            const hayBale = new THREE.Mesh(hayGeometry, hayMaterial);
            hayBale.position.set(pos.x, 0.6, pos.z);
            hayBale.rotation.z = Math.PI / 2; // Lay on side
            hayBale.castShadow = true;
            hayBale.receiveShadow = true;
            this.scene.add(hayBale);
            pastureElements.push(hayBale);
        });
        
        // Tree removed from pen area for better gameplay
    }
}
```

## js/TerrainBuilder.js

```javascript
import * as THREE from 'three';

/**
 * TerrainBuilder - Handles terrain, grass, mountains, and environmental elements
 */
export class TerrainBuilder {
    constructor(scene) {
        this.scene = scene;
        this.grassMaterial = null;
        this.grassInstanceCount = 0;
    }
    
    createTerrain() {
        // Create flat terrain - extended to match grass coverage
        const terrainGeometry = new THREE.PlaneGeometry(1000, 1000);
        const terrainMaterial = new THREE.MeshPhongMaterial({
            color: 0x4a7c4a,
            emissive: 0x1a3a1a,
            emissiveIntensity: 0.1,
            shininess: 0
        });
        
        const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
        terrain.rotation.x = -Math.PI / 2;
        terrain.position.y = 0;
        terrain.receiveShadow = true;
        this.scene.add(terrain);
        
        return terrain;
    }
    
    createGrass() {
        // Create instanced grass using shaders
        const grassVertexShader = `
            varying vec2 vUv;
            varying vec3 vWorldPos;
            uniform float time;
            
            void main() {
                vUv = uv;
                
                // Get instance position
                vec3 pos = position;
                vec4 mvPosition = vec4(pos, 1.0);
                
                #ifdef USE_INSTANCING
                    mvPosition = instanceMatrix * mvPosition;
                #endif
                
                vWorldPos = (modelMatrix * mvPosition).xyz;
                
                // Wind displacement - stronger at blade tips
                float dispPower = 1.0 - cos(uv.y * 3.14159 / 2.0);
                
                // Complex wind pattern
                float windX = sin(vWorldPos.z * 0.1 + time * 2.0) * cos(vWorldPos.x * 0.1 + time * 1.5);
                float windZ = cos(vWorldPos.x * 0.15 + time * 2.5) * sin(vWorldPos.z * 0.15 + time * 2.0);
                
                float displacement = windX * (0.15 * dispPower);
                mvPosition.x += displacement;
                mvPosition.z += windZ * (0.1 * dispPower);
                
                vec4 modelViewPosition = modelViewMatrix * mvPosition;
                gl_Position = projectionMatrix * modelViewPosition;
            }
        `;
        
        const grassFragmentShader = `
            varying vec2 vUv;
            varying vec3 vWorldPos;
            uniform vec3 fogColor;
            uniform float fogNear;
            uniform float fogFar;
            
            void main() {
                // Gradient from dark at base to light at tips
                vec3 baseColor = vec3(0.2, 0.5, 0.1);
                vec3 tipColor = vec3(0.41, 0.8, 0.3);
                
                // Add some color variation based on world position
                float colorVariation = sin(vWorldPos.x * 0.5) * cos(vWorldPos.z * 0.5) * 0.1;
                
                vec3 grassColor = mix(baseColor, tipColor, vUv.y);
                grassColor += vec3(colorVariation, colorVariation * 0.5, 0.0);
                
                // Apply fog
                float depth = gl_FragCoord.z / gl_FragCoord.w;
                float fogFactor = smoothstep(fogNear, fogFar, depth);
                
                vec3 finalColor = mix(grassColor, fogColor, fogFactor);
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;
        
        const grassUniforms = {
            time: { value: 0 },
            fogColor: { value: new THREE.Color(0x87CEEB) },
            fogNear: { value: 200 },
            fogFar: { value: 600 }
        };
        
        this.grassMaterial = new THREE.ShaderMaterial({
            vertexShader: grassVertexShader,
            fragmentShader: grassFragmentShader,
            uniforms: grassUniforms,
            side: THREE.DoubleSide
        });
        
        // Create grass blade geometry - small
        const bladeGeometry = new THREE.PlaneGeometry(0.05, 0.8, 1, 4);
        bladeGeometry.translate(0, 0.4, 0); // Move pivot to base
        
        // Create instanced mesh for grass - optimized for performance
        // Reduce grass count for better performance on high-end systems
        const instanceCount = 400000; // Reduced from 800k for better performance
        this.grassInstanceCount = instanceCount;
        const grassMesh = new THREE.InstancedMesh(bladeGeometry, this.grassMaterial, instanceCount);
        
        const dummy = new THREE.Object3D();
        
        // Distribute grass instances - extend much further out
        let placedCount = 0;
        for (let i = 0; i < instanceCount && placedCount < instanceCount; i++) {
            // Random position within much larger bounds - extend to horizon
            const x = (Math.random() - 0.5) * 800; // Increased from 240 to 800
            const z = (Math.random() - 0.5) * 800; // Increased from 240 to 800
            
            // Skip grass in the pasture area
            if (z > 100 && z < 130 && Math.abs(x) < 30) {
                continue;
            }
            
            dummy.position.set(x, 0, z);
            
            // Random scale and rotation with distance-based scaling
            const distanceFromCenter = Math.sqrt(x * x + z * z);
            const distanceScale = Math.max(0.3, 1.0 - distanceFromCenter / 600); // Grass gets smaller with distance
            const scale = (0.8 + Math.random() * 0.4) * distanceScale;
            dummy.scale.setScalar(scale);
            dummy.rotation.y = Math.random() * Math.PI * 2;
            
            // Slight random tilt
            dummy.rotation.z = (Math.random() - 0.5) * 0.1;
            
            dummy.updateMatrix();
            grassMesh.setMatrixAt(placedCount, dummy.matrix);
            placedCount++;
        }
        
        grassMesh.castShadow = true;
        grassMesh.receiveShadow = true;
        this.scene.add(grassMesh);
        
        return grassMesh;
    }
    
    createTrees() {
        // Tree trunk material
        const trunkMaterial = new THREE.MeshPhongMaterial({
            color: 0x4a3a2a,
            emissive: 0x1a0a00,
            emissiveIntensity: 0.05
        });
        
        // Richer foliage materials for variety & realism
        const foliageMaterials = [
            new THREE.MeshPhongMaterial({
                color: 0x355e29,
                emissive: 0x0e1a0e,
                emissiveIntensity: 0.1,
                flatShading: true
            }),
            new THREE.MeshPhongMaterial({
                color: 0x426b33,
                emissive: 0x112411,
                emissiveIntensity: 0.1,
                flatShading: true
            }),
            new THREE.MeshPhongMaterial({
                color: 0x274b1f,
                emissive: 0x091609,
                emissiveIntensity: 0.1,
                flatShading: true
            })
        ];

        // Helper to add slight noise to a spherical geometry for a fluffier canopy
        const addCanopyNoise = (geometry, amplitude = 0.4) => {
            const positionAttr = geometry.attributes.position;
            const normal = new THREE.Vector3();
            for (let i = 0; i < positionAttr.count; i++) {
                normal.set(
                    positionAttr.getX(i),
                    positionAttr.getY(i),
                    positionAttr.getZ(i)
                ).normalize();
                const offset = (Math.random() - 0.5) * amplitude;
                positionAttr.setXYZ(
                    i,
                    positionAttr.getX(i) + normal.x * offset,
                    positionAttr.getY(i) + normal.y * offset,
                    positionAttr.getZ(i) + normal.z * offset
                );
            }
            geometry.computeVertexNormals();
        };

        const trees = [];

        /***********************
         *  DECIDUOUS TREES   *
         ***********************/
        for (let i = 0; i < 200; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 120 + Math.random() * 300; // Spread trees further out
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;

            // Keep play area clear
            if (Math.abs(x) < 120 && Math.abs(z) < 120) continue;
            if (z > 100 && z < 135 && Math.abs(x) < 35) continue;

            // Trunk
            const trunkHeight = 7 + Math.random() * 5;
            const trunkRadius = 0.6 + Math.random() * 0.5;
            const trunkGeometry = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, 8);
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, trunkHeight / 2, z);
            trunk.castShadow = true;
            this.scene.add(trunk);
            trees.push(trunk);

            // Canopy – multiple irregular lumps for an organic silhouette
            const canopyLumps = 3 + Math.floor(Math.random() * 2); // 3-4 lumps
            const materialIndex = Math.floor(Math.random() * foliageMaterials.length);

            for (let l = 0; l < canopyLumps; l++) {
                const radius = 4 + Math.random() * 2 - l * 0.5;
                const icoDetail = 1; // keeps polycount low
                const canopyGeometry = new THREE.IcosahedronGeometry(radius, icoDetail);
                addCanopyNoise(canopyGeometry, 0.5);

                const canopy = new THREE.Mesh(canopyGeometry, foliageMaterials[materialIndex]);
                canopy.position.set(
                    x + (Math.random() - 0.5) * 1.5,
                    trunkHeight + radius / 2 + l * 0.8 + Math.random() * 0.5,
                    z + (Math.random() - 0.5) * 1.5
                );
                canopy.rotation.y = Math.random() * Math.PI;
                canopy.castShadow = true;
                canopy.receiveShadow = true;
                this.scene.add(canopy);
                trees.push(canopy);
            }
        }

        /***********************
         *      PINE TREES    *
         ***********************/
        for (let i = 0; i < 80; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 140 + Math.random() * 250;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;

            if (Math.abs(x) < 120 && Math.abs(z) < 120) continue;
            if (z > 100 && z < 135 && Math.abs(x) < 35) continue;

            // Trunk
            const trunkHeight = 5 + Math.random() * 3;
            const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, trunkHeight, 6);
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, trunkHeight / 2, z);
            trunk.castShadow = true;
            this.scene.add(trunk);
            trees.push(trunk);

            // Layered foliage – stacked cones for a stylised pine
            const layers = 3 + Math.floor(Math.random() * 2); // 3-4 layers
            const baseHeight = trunkHeight;
            const pineMaterial = new THREE.MeshPhongMaterial({
                color: 0x1e4b1e,
                emissive: 0x061406,
                emissiveIntensity: 0.1,
                flatShading: true
            });

            for (let l = 0; l < layers; l++) {
                const layerRadius = 3 - l * 0.6 + Math.random() * 0.4;
                const layerHeight = 4 + Math.random() * 1.5;
                const layerGeometry = new THREE.ConeGeometry(layerRadius, layerHeight, 8, 1, true);

                addCanopyNoise(layerGeometry, 0.3);

                const layerMesh = new THREE.Mesh(layerGeometry, pineMaterial);
                layerMesh.position.set(
                    x,
                    baseHeight + l * 2 + layerHeight / 2,
                    z
                );
                layerMesh.rotation.y = Math.random() * Math.PI;
                layerMesh.castShadow = true;
                layerMesh.receiveShadow = true;
                this.scene.add(layerMesh);
                trees.push(layerMesh);
            }
        }

        return trees;
    }
    
    addEnvironmentDetails() {
        // Add rocks - placed outside the play area
        const rockGeometry = new THREE.DodecahedronGeometry(1, 0);
        const rockMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x666666,
            emissive: 0x111111,
            emissiveIntensity: 0.05,
            flatShading: true
        });
        
        const rocks = [];
        
        // Play area boundaries to avoid: X: -100 to 100, Z: -100 to 130 (including pasture)
        const playAreaBounds = {
            minX: -100,
            maxX: 100,
            minZ: -100,
            maxZ: 130
        };
        
        // Increase rock count since we have more area to fill
        for (let i = 0; i < 40; i++) {
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            let x, z;
            let attempts = 0;
            
            // Find a position outside the play area
            do {
                // Generate position in larger area (400x400)
                x = (Math.random() - 0.5) * 400;
                z = (Math.random() - 0.5) * 400;
                attempts++;
                
                // Prevent infinite loop
                if (attempts > 100) {
                    // Force placement in known safe areas
                    if (Math.random() < 0.5) {
                        // Place far left or right
                        x = Math.random() < 0.5 ? -150 - Math.random() * 100 : 150 + Math.random() * 100;
                        z = (Math.random() - 0.5) * 300;
                    } else {
                        // Place far north or south
                        x = (Math.random() - 0.5) * 300;
                        z = Math.random() < 0.5 ? -150 - Math.random() * 100 : 180 + Math.random() * 100;
                    }
                    break;
                }
            } while (
                x >= playAreaBounds.minX && x <= playAreaBounds.maxX &&
                z >= playAreaBounds.minZ && z <= playAreaBounds.maxZ
            );
            
            rock.position.set(x, 0.5, z);
            rock.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            
            const scale = 0.5 + Math.random() * 1.5;
            rock.scale.set(scale, scale * 0.7, scale);
            
            rock.castShadow = true;
            rock.receiveShadow = true;
            this.scene.add(rock);
            rocks.push(rock);
        }
        
        return rocks;
    }
    
    updateGrassAnimation() {
        if (this.grassMaterial) {
            this.grassMaterial.uniforms.time.value = performance.now() * 0.001;
        }
    }
    
    getGrassMaterial() {
        return this.grassMaterial;
    }
    
    getGrassInstanceCount() {
        return this.grassInstanceCount;
    }
}
```

## js/Vector2D.js

```javascript
/**
 * Simple 2D Vector class for XZ plane calculations
 */
export class Vector2D {
    constructor(x = 0, z = 0) {
        this.x = x;
        this.z = z;
    }

    // Set the x and z components
    set(x, z) {
        this.x = x;
        this.z = z;
        return this;
    }

    // Add another vector to this one
    add(vector) {
        this.x += vector.x;
        this.z += vector.z;
        return this;
    }

    // Subtract another vector from this one
    subtract(vector) {
        this.x -= vector.x;
        this.z -= vector.z;
        return this;
    }

    // Multiply by a scalar
    multiply(scalar) {
        this.x *= scalar;
        this.z *= scalar;
        return this;
    }

    // Divide by a scalar
    divide(scalar) {
        if (scalar !== 0) {
            this.x /= scalar;
            this.z /= scalar;
        }
        return this;
    }

    // Get the magnitude (length) of the vector
    magnitude() {
        return Math.sqrt(this.x * this.x + this.z * this.z);
    }

    // Normalize the vector (make it unit length)
    normalize() {
        const len = this.magnitude();
        if (len > 0.00001) { // Use a small epsilon to prevent division by zero/tiny number
            this.x /= len;
            this.z /= len;
        } else {
            this.x = 0;
            this.z = 0;
        }
        return this;
    }

    // Limit the magnitude of the vector
    limit(max) {
        const len = this.magnitude();
        if (len > max && len > 0.00001) { // Only normalize if magnitude is significant and over max
            this.normalize();
            this.multiply(max);
        }
        return this;
    }

    // Get distance to another vector
    distanceTo(vector) {
        const dx = this.x - vector.x;
        const dz = this.z - vector.z;
        return Math.sqrt(dx * dx + dz * dz);
    }

    // Get the angle of the vector in radians
    angle() {
        return Math.atan2(this.z, this.x);
    }

    // Set the magnitude of the vector
    setMagnitude(magnitude) {
        this.normalize();
        this.multiply(magnitude);
        return this;
    }

    // Create a copy of this vector
    clone() {
        return new Vector2D(this.x, this.z);
    }

    // Static method to create a vector from an angle
    static fromAngle(angle) {
        return new Vector2D(Math.cos(angle), Math.sin(angle));
    }

    // Static method to get a random unit vector
    static random() {
        const angle = Math.random() * Math.PI * 2;
        return Vector2D.fromAngle(angle);
    }
}
```

## MOBILE_CONTROLS.md

````markdown
# Mobile Controls Implementation

## Overview
The Sheep Dog Simulator includes comprehensive mobile controls for touch-based devices, providing a native mobile gaming experience with virtual joystick, zoom controls, sprint button, and fullscreen support.

## Features

### 1. Touch Device Detection
- Multi-method detection using touch events, user agent, pointer type, and screen size
- Supports iOS Safari, Android Chrome, and other mobile browsers
- Progressive enhancement (desktop unchanged, mobile enhanced)

### 2. Virtual Joystick (nipple.js)
- 360-degree movement control in bottom-left corner
- Dynamic loading from CDN (only on touch devices)
- Smooth movement with proper vector normalization
- Visual feedback with joystick handle movement

### 3. Zoom Slider
- Vertical slider in bottom-right corner
- Range: 20-150 camera distance units
- Real-time zoom updates synchronized with desktop mouse wheel
- Touch-optimized slider handle (44px minimum touch target)

### 4. Sprint Button
- Positioned below zoom slider in bottom-right
- Integrates with stamina system
- Visual feedback on press/release
- Emoji icon (🏃) for universal recognition

### 5. Mobile Fullscreen Support
- **Automatic Detection**: Shows fullscreen button only on mobile devices
- **Cross-Browser Compatibility**: Supports all fullscreen API variants:
  - `requestFullscreen()` (Standard)
  - `webkitRequestFullscreen()` (Safari)
  - `webkitRequestFullScreen()` (Older Safari)
  - `mozRequestFullScreen()` (Firefox)
  - `msRequestFullscreen()` (IE/Edge)
- **User Interaction Required**: Only triggers on user tap/click
- **Smart Button Management**: 
  - Appears on page load for mobile devices
  - Hides when fullscreen is activated
  - Reappears when user exits fullscreen
  - Prevents duplicate buttons
- **Visual Design**: Prominent blue button with mobile icon and clear text
- **Touch Optimized**: Proper touch feedback and accessibility

### 6. Combined Mobile UI
- Timer, sheep count, and best time in single top-center element
- Replaces separate desktop UI elements on mobile
- Compact design optimized for small screens
- Responsive font sizes and spacing

### 7. Touch Prevention
- Disables zoom, scroll, and interfering mobile behaviors
- Prevents text selection and context menus
- Optimized for gaming experience

## Features Implemented

### 🕹️ Virtual Joystick (Movement Control)
- **Library**: nipple.js v0.10.2 from CDN
- **Position**: Bottom-left corner of screen
- **Functionality**: 
  - Replaces WASD keyboard movement
  - 360-degree movement control
  - Visual feedback with blue joystick
  - Automatic show/hide based on device detection

### 🔍 Zoom Slider (Camera Control)
- **Type**: Vertical range slider
- **Position**: Bottom-right corner of screen
- **Range**: 20-150 units (same as mouse wheel zoom)
- **Functionality**:
  - Smooth camera distance adjustment
  - Synchronized with mouse wheel on desktop
  - Custom styled for mobile touch interaction

### 🏃 Sprint Button
- **Position**: Above joystick (left side)
- **Functionality**:
  - Replaces Shift key for sprinting
  - Visual feedback (color change on press)
  - Integrates with existing stamina system
  - Touch-optimized size (60x60px)

### 📱 Device Detection & Responsiveness
- **Detection**: Multiple methods for touch capability detection
- **Responsive UI**: Mobile-optimized layouts and font sizes
- **Touch Prevention**: Disabled zoom, scroll, and other interfering behaviors
- **Cross-platform**: Works on iOS, Android, and other touch devices

## Technical Implementation

### File Structure
```
js/
├── MobileControls.js     # Main mobile controls system (new)
├── InputHandler.js       # Enhanced for mobile integration
├── SceneManager.js       # Enhanced for mobile zoom
├── main.js              # Updated with mobile controls
└── ...                  # Other existing files

index.html               # Enhanced with mobile CSS and meta tags
test-mobile.html         # Mobile controls test page (new)
```

### Key Classes and Methods

#### MobileControls.js
```javascript
class MobileControls {
    constructor()                    // Initialize mobile controls
    detectTouchDevice()              // Detect touch capability
    loadNippleJS()                   // Load nipple.js library
    createJoystick()                 // Create virtual joystick
    createZoomSlider()               // Create zoom control
    createSprintButton()             // Create sprint button
    enable() / disable()             // Show/hide controls
    getMovementDirection()           // Get joystick input
    getIsSprinting()                 // Get sprint button state
    setupTouchPrevention()           // Prevent default touch behaviors
    createFullscreenButton()          // Create fullscreen button
    requestFullscreen()              // Cross-browser fullscreen API implementation
    isFullscreenSupported()          // Checks for fullscreen API availability
    setupFullscreenListeners()        // Handles fullscreen state changes
}
```

#### Enhanced InputHandler.js
```javascript
class InputHandler {
    setMobileControls(mobileControls) // Connect mobile controls
    getMovementDirection()            // Combined keyboard + mobile input
    isMoving()                       // Combined movement detection
    isSprinting()                    // Combined sprint detection
}
```

#### Enhanced SceneManager.js
```javascript
class SceneManager {
    setMobileControls(mobileControls) // Connect for zoom integration
    setupMouseControls()              // Desktop-only mouse wheel
    getCameraDistance()               // Get current zoom level
    setCameraDistance(distance)       // Set zoom level from mobile
}
```

### Mobile-Specific CSS Features

#### Viewport and Touch Behavior
```css
/* Prevent zoom and scrolling */
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">

/* Prevent touch behaviors */
body {
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
}

#canvas-container {
    touch-action: none;
    overscroll-behavior: none;
}
```

#### Responsive Design
```css
/* Mobile-optimized UI scaling */
@media (max-width: 768px) {
    #game-title { font-size: 2.5rem; }
    #instructions { padding: 10px; font-size: 12px; }
    #stamina-bar { min-width: 150px; }
    /* ... other responsive adjustments */
}
```

#### Mobile Controls Styling
```css
/* Ensure mobile controls are interactive */
#mobile-joystick,
#mobile-zoom,
#mobile-sprint {
    pointer-events: auto !important;
    z-index: 1001 !important;
}
```

## Integration Points

### 1. Input System Integration
- Mobile controls integrate seamlessly with existing InputHandler
- Keyboard and touch inputs work simultaneously (desktop + mobile)
- Pause system works with both input methods
- No disruption to existing game logic

### 2. Camera System Integration
- Mobile zoom slider synchronizes with mouse wheel zoom
- Same zoom range and behavior as desktop
- Smooth transitions and consistent camera movement

### 3. UI System Integration
- Mobile controls appear only on touch devices
- Responsive layouts for different screen sizes
- Instructions update automatically for mobile users
- Pause indicator adapts to input method

### 4. Game Loop Integration
- Mobile controls update in same game loop
- No performance impact on desktop users
- Consistent frame rate across platforms

## Browser Compatibility

### Supported Browsers
- **iOS Safari**: 13+ (full support)
- **Chrome Mobile**: 80+ (full support)
- **Firefox Mobile**: 75+ (full support)
- **Samsung Internet**: 12+ (full support)
- **Edge Mobile**: 80+ (full support)

### Feature Detection
```javascript
// Multiple detection methods for maximum compatibility
detectTouchDevice() {
    return ('ontouchstart' in window) || 
           (navigator.maxTouchPoints > 0) || 
           (navigator.msMaxTouchPoints > 0);
}
```

## Performance Considerations

### Optimizations
- **Lazy Loading**: nipple.js loads only on touch devices
- **Event Throttling**: Touch events are efficiently handled
- **Memory Management**: Proper cleanup of mobile controls
- **Minimal Overhead**: No impact on desktop performance

### Resource Usage
- **nipple.js**: ~15KB compressed
- **Additional CSS**: ~2KB
- **JavaScript**: ~8KB for mobile controls
- **Total Overhead**: <25KB for mobile functionality

## Testing

### Test Page
- `test-mobile.html` - Standalone mobile controls test
- Tests joystick, zoom slider, and sprint button
- Device detection and library loading verification
- Real-time input feedback

### Testing Checklist
- [ ] Touch device detection works correctly
- [ ] Virtual joystick responds to touch input
- [ ] Zoom slider adjusts camera distance
- [ ] Sprint button activates/deactivates properly
- [ ] No interference with desktop controls
- [ ] Responsive design works on various screen sizes
- [ ] Touch prevention stops unwanted behaviors

## Usage Instructions

### For Players
1. **Movement**: Use the blue joystick in the bottom-left corner
2. **Sprint**: Tap and hold the sprint button (🏃) above the joystick
3. **Zoom**: Use the vertical slider on the bottom-right to adjust camera distance
4. **Pause**: Tap the pause indicator when game is paused

### For Developers
1. Mobile controls initialize automatically on touch devices
2. No additional setup required beyond including MobileControls.js
3. Controls integrate with existing input system transparently
4. Use `mobileControls.getIsTouchDevice()` to check device type

## Future Enhancements

### Potential Improvements
- **Haptic Feedback**: Vibration on sprint/collision
- **Gesture Controls**: Pinch-to-zoom alternative
- **Customizable Layout**: User-adjustable control positions
- **Multiple Joysticks**: Separate movement and camera controls
- **Voice Commands**: Accessibility improvements

### Performance Optimizations
- **WebGL Optimizations**: Mobile-specific rendering adjustments
- **Battery Optimization**: Reduced frame rate options
- **Memory Management**: Further optimization for low-end devices

## Troubleshooting

### Common Issues
1. **Joystick not appearing**: Check device detection and nipple.js loading
2. **Touch events not working**: Verify touch prevention setup
3. **Zoom not synchronized**: Check SceneManager mobile controls connection
4. **Performance issues**: Consider reducing grass instances on mobile

### Debug Tools
- Browser developer tools for touch event inspection
- `test-mobile.html` for isolated testing
- Console logging in MobileControls.js for debugging

## Conclusion

The mobile controls implementation provides a complete touch-based interface for the Sheep Dog Simulator while maintaining full compatibility with desktop controls. The system is designed for performance, usability, and cross-platform compatibility, ensuring a smooth gaming experience across all devices.
````

## package.json

```json
{
  "name": "sheep-dog-sim",
  "version": "1.0.0",
  "description": "An interactive herding game where players control a sheepdog to guide sheep into a pen using boid flocking algorithms",
  "main": "index.html",
  "scripts": {
    "start": "python -m http.server 8000",
    "serve": "npx http-server -p 8000"
  },
  "keywords": [
    "game",
    "simulation",
    "boids",
    "flocking",
    "three.js",
    "herding"
  ],
  "author": "",
  "license": "MIT",
  "devDependencies": {
    "http-server": "^14.1.1",
    "stats.js": "^0.17.0"
  }
}
```

## README.md

````markdown
# Sheep Dog Simulation

A sophisticated web-based herding simulation where players control a sheepdog to guide 200 sheep through a gate into a designated pasture. The simulation features realistic boid flocking behavior, immersive 3D environments, competitive timing mechanics, and polished user experience with cinematic start screen, stamina system, pause functionality, and **full mobile touch controls**.

## 🎮 Features

### Core Gameplay
- **Interactive Herding**: Control a sheepdog using WASD keys or touch controls to guide sheep through a gate
- **Stamina System**: Sprint with Shift key or sprint button while managing stamina for strategic gameplay
- **Realistic AI**: 200 sheep with sophisticated boid flocking behavior (cohesion, separation, alignment)
- **Goal-Oriented**: Guide all sheep through the gate into the sleeping pasture
- **Competitive Timing**: Race against the clock with best time tracking

### Mobile & Touch Support 📱
- **Virtual Joystick**: Touch-based movement control using nipple.js library
- **Zoom Slider**: Vertical slider for camera distance adjustment on mobile
- **Sprint Button**: Touch-optimized sprint control with visual feedback
- **Responsive Design**: Mobile-optimized UI layouts and touch-friendly interactions
- **Cross-Platform**: Seamless experience across desktop and mobile devices

### User Experience
- **Cinematic Start Screen**: Professional start screen with orbital camera showcasing the field
- **Pause System**: Escape key or touch pauses all game systems with visual indicator
- **Stamina Management**: Visual stamina bar with color-coded states and sprint mechanics
- **Smooth Transitions**: Polished UI transitions between start screen and gameplay
- **Enhanced Controls**: Responsive movement with acceleration/deceleration and sprint system

### Visual & Environmental
- **Expansive World**: Extended grass coverage reaching to the horizon (800x800 units)
- **Realistic Terrain**: Multi-layered mountains with geometric variation
- **Detailed Forests**: Realistic trees with trunks, multiple foliage layers, and pine varieties
- **Dynamic Grass**: 800,000 animated grass instances with wind effects via shaders
- **Atmospheric Effects**: Fog system and advanced lighting for depth and immersion
- **Enhanced Sheepdog**: Detailed 3D model with realistic animations and idle behaviors

### Game Systems
- **Timer System**: Automatic timing with best score persistence in localStorage
- **Progress Tracking**: Real-time sheep count and completion status
- **Boundary System**: Intelligent field boundaries with fence structures
- **Gate Mechanics**: Directional passage detection with velocity validation
- **Performance Monitor**: Toggle-able performance statistics with 'P' key

### Technical Excellence
- **Modular Architecture**: Clean, maintainable code structure with separated concerns
- **Performance Optimized**: Instanced rendering for grass, shared geometries for efficiency
- **Responsive Design**: Dynamic camera system with mouse wheel zoom control
- **Cross-Platform**: Works on desktop and modern mobile browsers with touch controls

## 🚀 Quick Start

### Prerequisites
- Modern web browser (Chrome 80+, Firefox 75+, Safari 13+, Edge 80+)
- Local web server (Python, Node.js, or any HTTP server)
- **Mobile**: iOS 13+, Android Chrome 80+, or equivalent modern mobile browser

### Installation & Setup

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd sheep-dog
   ```

2. **Start a local web server**
   
   Using Python 3:
   ```bash
   python -m http.server 8000
   ```
   
   Using Node.js (if you have `http-server` installed):
   ```bash
   npx http-server -p 8000
   ```

3. **Open in browser**
   Navigate to `http://localhost:8000`

## 🎯 How to Play

### Desktop Controls
- **W** - Move forward
- **A** - Move left  
- **S** - Move backward
- **D** - Move right
- **Shift** - Sprint (uses stamina)
- **Escape** - Pause/Resume game
- **Mouse Wheel** - Zoom in/out
- **P** - Toggle performance statistics
- **Enter** - Start game (on start screen)

### Mobile Controls 📱
- **Virtual Joystick** (bottom-left) - Move in any direction
- **Sprint Button** 🏃 (above joystick) - Hold to sprint
- **Zoom Slider** (bottom-right) - Adjust camera distance
- **Tap Pause Indicator** - Resume when paused
- **Touch Screen** - Toggle sound

### Objective
Guide all 200 sheep through the golden gate into the pasture as quickly as possible!

### Strategy Tips
1. **Manage stamina wisely** - Sprint strategically to conserve energy for crucial moments
2. **Position strategically** - Get behind the flock relative to the gate
3. **Use flock dynamics** - Moving one sheep influences nearby sheep
4. **Apply gentle pressure** - Steady guidance works better than aggressive chasing
5. **Utilize boundaries** - Use fences to help funnel sheep toward the gate
6. **Time management** - Timer starts on first movement, so plan your approach
7. **Rest when possible** - Stamina regenerates faster when not moving

## 🏗️ Architecture

### Modular Design
The simulation uses a clean, modular architecture for maintainability and extensibility:

```
js/
├── main.js              # Main orchestrator with mobile integration (204 lines)
├── SceneManager.js      # 3D scene and rendering management (141 lines)
├── TerrainBuilder.js    # Environment creation (397 lines)
├── StructureBuilder.js  # Game structures (471 lines)
├── GameState.js         # Game logic and state management (242 lines)
├── GameTimer.js         # Timer system and best time tracking (181 lines)
├── StartScreen.js       # Start screen and cinematic camera (136 lines)
├── StaminaUI.js         # Stamina bar UI management (105 lines)
├── MobileControls.js    # Mobile touch controls system (NEW - 400+ lines)
├── Boid.js             # Base AI behavior system (248 lines)
├── OptimizedSheep.js   # High-performance sheep system (788 lines)
├── Sheepdog.js         # Enhanced player controller (683 lines)
├── InputHandler.js     # Enhanced input with mobile support (182 lines)
├── PerformanceMonitor.js # Real-time performance tracking (377 lines)
└── Vector2D.js         # 2D mathematics utilities (102 lines)
```

### Module Responsibilities

#### **MobileControls** - Touch Interface (NEW)
- Touch device detection and capability assessment
- Virtual joystick creation using nipple.js library
- Zoom slider for camera control on mobile devices
- Sprint button with touch-optimized feedback
- Touch event prevention and mobile behavior management

#### **SceneManager** - 3D Rendering (Enhanced)
- Three.js scene setup and management
- Camera control and following system
- Lighting configuration (ambient + directional)
- Mouse wheel zoom functionality (desktop) + mobile zoom integration

#### **InputHandler** - Input Management (Enhanced)
- WASD movement input handling (desktop)
- Virtual joystick integration (mobile)
- Sprint control with Shift key or touch button
- Pause system with Escape key or touch
- Cross-platform input coordination

#### **TerrainBuilder** - Environment
- Flat terrain generation (1000x1000 units)
- Instanced grass system (800,000 blades with wind shaders)
- Multi-layered mountain generation with geometric variation
- Realistic tree creation (deciduous and pine varieties)
- Environmental details (rocks, atmospheric effects)

#### **StructureBuilder** - Game Structures
- Field boundary fence system
- Gate construction with detection zones
- Pasture area with custom textures
- Fence rail connection algorithms

#### **GameState** - Logic & Configuration
- Game boundaries and parameters
- Sheep flock creation and behavior coordination
- Completion detection and UI updates
- Game state management and reset functionality
- Pause state coordination

#### **GameTimer** - Timing System
- Precision timing with performance.now()
- Best time persistence in localStorage
- New record detection and celebration
- Timer display formatting and UI updates
- Pause state handling

#### **StartScreen** - Pre-Game Experience
- Start screen overlay management
- Cinematic camera system with orbital movement
- Game launch coordination and UI transitions
- Interactive start button and keyboard support

#### **StaminaUI** - Stamina System Interface
- Stamina bar display with color-coded states
- Performance-optimized UI updates
- Visual feedback for sprinting and exhaustion
- Real-time stamina percentage display

#### **Sheepdog** - Enhanced Player Controller
- Smooth movement with acceleration/deceleration
- Stamina system with sprint mechanics
- Detailed 3D model with realistic animations
- Multiple idle behaviors for immersion

## 📱 Mobile Features

### Touch Controls
- **Virtual Joystick**: 360-degree movement control with visual feedback
- **Sprint Button**: Touch-optimized sprint control with color changes
- **Zoom Slider**: Vertical slider for smooth camera distance adjustment
- **Responsive UI**: Mobile-optimized layouts and touch-friendly sizes

### Device Detection
- **Automatic Detection**: Touch capability detection using multiple methods
- **Progressive Enhancement**: Desktop controls remain fully functional
- **Cross-Platform**: Works on iOS, Android, and other touch devices

### Performance Optimizations
- **Lazy Loading**: Mobile controls load only on touch devices
- **Efficient Events**: Optimized touch event handling
- **Memory Management**: Proper cleanup and resource management
- **Battery Friendly**: Minimal overhead for mobile devices

### Mobile-Specific Features
- **Touch Prevention**: Disabled zoom, scroll, and interfering behaviors
- **Responsive Design**: Adaptive layouts for different screen sizes
- **Visual Feedback**: Enhanced touch feedback and state indicators
- **Accessibility**: Touch-optimized button sizes and interactions

For detailed mobile implementation information, see [MOBILE_CONTROLS.md](MOBILE_CONTROLS.md).

## 🎨 Visual Features

### Enhanced Sheepdog Model
- **Detailed Design**: Procedural Border Collie with realistic proportions
- **Rich Animations**: Running, idle, breathing, looking around, ear twitching, stretching
- **Visual Feedback**: Tongue visibility when running fast, different animation speeds
- **Smooth Movement**: Acceleration-based movement with realistic turning

### Grass System
- **800,000 instances** for dense, realistic coverage
- **Shader-based animation** with complex wind patterns
- **Distance-based scaling** for realistic perspective
- **Fog integration** for atmospheric depth

### Mountain Generation
- **Multi-layered depth** with front, middle, and back mountain ranges
- **Geometric variation** with procedural vertex displacement
- **Material variety** with multiple mountain materials
- **Realistic scaling** and positioning for natural appearance

### Tree System
- **Realistic structure** with separate trunks and foliage
- **Multiple varieties** including deciduous and pine trees
- **Layered foliage** for fuller, more natural appearance
- **Strategic placement** around mountains and distant areas

### User Interface
- **Professional Start Screen**: Cinematic camera with game instructions
- **Stamina Bar**: Color-coded stamina display with state indicators
- **Pause System**: Clear pause overlay with resume instructions
- **Performance Stats**: Toggle-able FPS and rendering statistics
- **Mobile UI**: Touch-optimized controls and responsive layouts

## ⚡ Performance

### Optimizations
- **Instanced rendering** for grass (single draw call for 800k instances)
- **GPU-based sheep rendering** with single InstancedMesh for all 200 sheep
- **Vertex shader animation** for sheep movement and behavior
- **Shared geometries** for environmental objects
- **LOD considerations** with distance-based scaling
- **Efficient shadow mapping** with optimized shadow camera settings
- **Mobile optimizations** with lazy loading and efficient touch handling

### System Requirements

#### Desktop
- **Recommended**: Modern desktop with dedicated graphics
- **Minimum**: Integrated graphics with hardware acceleration enabled
- **Memory**: ~150MB for full scene with optimized rendering
- **Target Performance**: 60 FPS with 200 sheep + 800k grass instances

#### Mobile
- **iOS**: 13+ (Safari, Chrome, Firefox)
- **Android**: Chrome 80+, Firefox 75+, Samsung Internet 12+
- **Memory**: ~100MB optimized for mobile constraints
- **Target Performance**: 30-60 FPS depending on device capabilities

## 🛠️ Development

### Adding New Features
The modular architecture makes it easy to extend:

1. **New Behaviors**: Extend the `Boid` class for different AI entities
2. **Environmental Elements**: Add methods to `TerrainBuilder` for new terrain features
3. **Game Mechanics**: Extend `GameState` for new gameplay systems
4. **Visual Effects**: Enhance `SceneManager` for new rendering features
5. **UI Components**: Create new UI modules following the `StaminaUI` pattern
6. **Mobile Features**: Extend `MobileControls` for new touch interactions

### Code Style
- **ES6 Classes** for clear object-oriented structure
- **Descriptive naming** for methods and variables
- **Modular design** with single responsibility principle
- **Comprehensive comments** for complex algorithms
- **Cross-platform compatibility** considerations

## 🔧 Customization

### Adjustable Parameters (in GameState.js)
```javascript
params: {
    speed: 0.1,              // Sheep movement speed
    cohesion: 1.0,           // Flock cohesion strength  
    separationDistance: 2.0   // Minimum separation distance
}
```

### Stamina Settings (in Sheepdog.js)
```javascript
maxStamina: 100,
staminaDrainRate: 30,        // Stamina per second when sprinting
staminaRegenRate: 20,        // Stamina per second when not sprinting
minStaminaToSprint: 10,      // Minimum stamina to start sprinting
maxSpeed: 15,                // Normal movement speed
sprintSpeed: 25              // Sprint movement speed
```

### Mobile Controls Settings (in MobileControls.js)
```javascript
// Joystick configuration
joystick: {
    size: 120,               // Joystick size in pixels
    color: '#00BFFF',        // Joystick color
    threshold: 0.1,          // Movement threshold
    restOpacity: 0.7         // Opacity when not in use
}

// Zoom slider configuration
zoom: {
    min: 20,                 // Minimum zoom distance
    max: 150,                // Maximum zoom distance
    default: 80              // Default zoom level
}
```

### Environment Settings
- **Field boundaries**: Modify `bounds` object in GameState
- **Grass density**: Adjust `instanceCount` in TerrainBuilder
- **Mountain placement**: Edit `mountainLayers` arrays
- **Tree distribution**: Modify tree generation loops

## 📱 Browser Compatibility

| Platform | Browser | Minimum Version | Mobile Controls |
|----------|---------|----------------|-----------------|
| Desktop  | Chrome  | 80+            | N/A             |
| Desktop  | Firefox | 75+            | N/A             |
| Desktop  | Safari  | 13+            | N/A             |
| Desktop  | Edge    | 80+            | N/A             |
| iOS      | Safari  | 13+            | ✅ Full Support |
| iOS      | Chrome  | 80+            | ✅ Full Support |
| Android  | Chrome  | 80+            | ✅ Full Support |
| Android  | Firefox | 75+            | ✅ Full Support |
| Android  | Samsung | 12+            | ✅ Full Support |

### WebGL Requirements
- **WebGL 1.0** minimum (for Three.js compatibility)
- **Hardware acceleration** enabled for optimal performance
- **Shader support** for grass animation effects
- **Touch events** for mobile control functionality

## 🏆 Scoring System

- **Timer starts** on first movement
- **Timer stops** when all sheep pass through the gate
- **Best times** are automatically saved to localStorage
- **New records** are celebrated with special animations
- **Restart functionality** to attempt better times
- **Pause system** preserves accurate timing

## 📄 License

This project is open source and available under the MIT License. Feel free to modify, distribute, and use for educational purposes.

## 🐛 Troubleshooting

### Common Issues

**Simulation won't load:**
- Ensure you're using a web server (not file:// protocol)
- Check browser console for JavaScript errors
- Verify Three.js CDN accessibility

**Mobile controls not appearing:**
- Verify touch device detection is working
- Check that nipple.js library loads successfully
- Ensure JavaScript is enabled and no ad blockers interfere

**Poor performance:**
- Enable hardware acceleration in browser settings
- Close resource-intensive applications
- Try reducing browser zoom level
- Check if WebGL is properly enabled

**Timer not working:**
- Ensure localStorage is enabled in your browser
- Check for browser extensions blocking local storage
- Verify JavaScript is enabled

**Controls unresponsive:**
- Click on the game window to ensure focus
- Check for browser extensions intercepting input
- Verify no accessibility software is interfering
- On mobile, ensure touch events are not blocked

**Stamina system not working:**
- Ensure you're holding Shift or sprint button to sprint
- Check that the stamina bar is visible (game must be started)
- Verify the sheepdog is moving (stamina only drains during movement)

### Performance Tips
- **Desktop recommended** for best experience
- **Close unnecessary browser tabs** to free up memory
- **Update graphics drivers** for optimal WebGL performance
- **Use latest browser version** for best Three.js compatibility
- **Mobile**: Close background apps for better performance

### Mobile-Specific Tips
- **Landscape orientation** recommended for better control layout
- **Stable internet** required for CDN library loading
- **Touch calibration** may be needed on some devices
- **Battery optimization** disable for best performance

## 🤝 Contributing

Contributions are welcome! Areas for improvement:
- Additional sheep behaviors and AI states
- Weather and day/night cycle systems
- Multiple difficulty levels and objectives
- Enhanced particle effects and post-processing
- Advanced mobile features (haptic feedback, gestures)
- Sound effects and ambient audio
- Achievement system and game modes
- Multiplayer functionality
- Accessibility improvements
````

## Statistics

- Total Files: 21
- Total Characters: 297548
- Total Tokens: 0
